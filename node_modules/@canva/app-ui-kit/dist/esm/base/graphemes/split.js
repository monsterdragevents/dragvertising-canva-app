import { Control, Control_ranges, Control_values, CR, CR_value, Extend, Extend_ranges, Extend_values, LF, LF_value, Other, Prepend, Prepend_ranges, Prepend_values, Regional_Indicator, Regional_Indicator_ranges, SpacingMark, SpacingMark_ranges, SpacingMark_values, ZWJ, ZWJ_value } from './codepoint_data';
export function splitByGraphemeClusters(str) {
    const result = [];
    let brk;
    let index = 0;
    while(index < str.length && (brk = nextBreak(str, index)) < str.length){
        result.push(str.slice(index, brk));
        index = brk;
    }
    if (index < str.length) result.push(str.slice(index));
    return result;
}
function nextBreak(str, index) {
    let prev = codePointType(str.codePointAt(index));
    const mids = [];
    for(let i = index + 1; i < str.length; i++){
        if (isSurrogate(str, i - 1))
            continue;
        const next = codePointType(str.codePointAt(i));
        if (shouldBreak(prev, mids, next)) return i;
        mids.push(next);
        prev = next;
    }
    return str.length;
}
function shouldBreak(previous, mids, current) {
    if (previous === CR && current === LF)
        return false;
    if ([
        Control,
        CR,
        LF
    ].includes(previous))
        return true;
    if ([
        Control,
        CR,
        LF
    ].includes(current))
        return true;
    if (current === Extend || current === ZWJ)
        return false;
    if (current === SpacingMark)
        return false;
    if (previous === Prepend)
        return false;
    if (previous === ZWJ)
        return false;
    if (mids.includes(Regional_Indicator))
        return true;
    if (previous === Regional_Indicator && current === Regional_Indicator)
        return false;
    return true;
}
function codePointType(value) {
    if (value == null) return Other;
    else if (value === CR_value) return CR;
    else if (value === LF_value) return LF;
    else if (value === ZWJ_value) return ZWJ;
    if (checkRange(value, Prepend_values, Prepend_ranges)) return Prepend;
    else if (checkRange(value, Control_values, Control_ranges)) return Control;
    else if (checkRange(value, SpacingMark_values, SpacingMark_ranges)) return SpacingMark;
    else if (checkRange(value, Extend_values, Extend_ranges)) return Extend;
    else if (checkRange(value, new Set([]), Regional_Indicator_ranges)) return Regional_Indicator;
    return Other;
}
function checkRange(value, values, ranges) {
    if (values.has(value)) return true;
    const firstRange = ranges[0];
    const lastRange = ranges.length > 1 ? ranges[ranges.length - 1] : firstRange;
    if (firstRange[0] <= value && value <= lastRange[1]) return ranges.some(([a, b])=>a <= value && value <= b);
    return false;
}
function isSurrogate(str, pos) {
    return 0xd800 <= str.charCodeAt(pos) && str.charCodeAt(pos) <= 0xdbff && 0xdc00 <= str.charCodeAt(pos + 1) && str.charCodeAt(pos + 1) <= 0xdfff;
}
