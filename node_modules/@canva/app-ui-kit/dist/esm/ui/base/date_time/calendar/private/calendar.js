import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Preconditions } from '../../../../../base/preconditions';
import classNames from 'classnames';
import * as React from 'react';
import { checkMonth, compareDates, compareDays, compareMonthAndYear, dayOfWeekStartOfMonth, isEqualDates, key, monthDays, nextMonth, numberOfCompleteWeeks, prevMonth, toISO, toLocalDateTimeObject, toUTCDateTimeObject } from '../../utils/utils';
import styles from './calendar.css';
import { CalendarDayWithWrapper } from './day';
import { CalendarDaysOfWeekLabels } from './days_week_labels';
import { CalendarWeek as DefaultCalendarWeek, DAYS_IN_WEEK } from './week';
const WEEKS_IN_CALENDAR = 6;
const DAYS_IN_CALENDAR = DAYS_IN_WEEK * WEEKS_IN_CALENDAR;
export const Calendar = React.memo(
    ({ autoFocus = true, today = toLocalDateTimeObject(new Date()), CalendarDay = CalendarDayWithWrapper, CalendarWeek = DefaultCalendarWeek, DaysOfWeekLabels = CalendarDaysOfWeekLabels, month, year, animate, ariaLabel, ariaLabelledBy, ariaDescribedBy, locale, selected, focused, includedInTabOrder, selectedInvalid, canSelectPastDates, className, onSelect, minSelectableDate, maxSelectableDate })=>{
        const previousMonthYearRef = React.useRef({
            month,
            year
        });
        const animatedRef = React.useRef(null);
        const selectedDayRef = React.useRef(null);
        const focusedDayRef = React.useRef(null);
        React.useEffect(()=>{
            var _focusedDayRef_current;
            if (autoFocus) (_focusedDayRef_current = focusedDayRef.current) === null || _focusedDayRef_current === void 0 ? void 0 : _focusedDayRef_current.focus();
        }, [
            autoFocus
        ]);
        React.useEffect(()=>{
            if (!animate) return;
            previousMonthYearRef.current = {
                month,
                year
            };
            setTimeout(()=>{
                requestAnimationFrame(()=>{
                    if (animatedRef.current) animatedRef.current.classList.add(styles.animate);
                });
            }, 0);
        }, [
            month,
            year,
            animate
        ]);
        const onAnimationScrollRef = React.useCallback((ref)=>{
            animatedRef.current = ref;
        }, []);
        const onSelectedDayRef = React.useCallback((ref)=>{
            selectedDayRef.current = ref;
        }, []);
        const onFocusedDayRef = React.useCallback((ref)=>{
            focusedDayRef.current = ref;
        }, []);
        const handleSelect = React.useCallback((date)=>{
            onSelect === null || onSelect === void 0 ? void 0 : onSelect(toUTCDateTimeObject(date));
        }, [
            onSelect
        ]);
        const todayValue = Preconditions.checkExists(today);
        const isToday = React.useCallback((date)=>{
            return isEqualDates(date, todayValue);
        }, [
            todayValue
        ]);
        const isSelectedDate = React.useCallback((date)=>{
            if (!selected) return false;
            const dates = Array.isArray(selected) ? selected : [
                selected
            ];
            return dates.some((selectedDate)=>isEqualDates(date, selectedDate));
        }, [
            selected
        ]);
        const isFocusedDate = React.useCallback((date)=>{
            return !!(focused && isEqualDates(date, focused));
        }, [
            focused
        ]);
        const isIncludedInTabOrderDate = React.useCallback((date)=>{
            return !!(includedInTabOrder && isEqualDates(date, includedInTabOrder));
        }, [
            includedInTabOrder
        ]);
        const isPastDate = React.useCallback((date)=>{
            return compareDays(date, todayValue) < 0;
        }, [
            todayValue
        ]);
        const isDisabledDate = React.useCallback((date)=>{
            if ((!canSelectPastDates || minSelectableDate === 'today') && isPastDate(date)) return true;
            if (!!minSelectableDate && minSelectableDate !== 'today' && compareDates(date, minSelectableDate) < 0) return true;
            if (maxSelectableDate) return compareDates(date, maxSelectableDate) > 0;
            return false;
        }, [
            canSelectPastDates,
            minSelectableDate,
            maxSelectableDate,
            isPastDate
        ]);
        const isCurrentMonth = React.useCallback((date, month)=>{
            return checkMonth(date, month);
        }, []);
        const compareWithPrevious = React.useCallback(()=>{
            return compareMonthAndYear(previousMonthYearRef.current, {
                month,
                year
            });
        }, [
            month,
            year
        ]);
        const getPreviousWeeksNumber = React.useCallback(()=>{
            const comparedWithPrevious = compareWithPrevious();
            if (comparedWithPrevious < 0) return numberOfCompleteWeeks(previousMonthYearRef.current);
            if (comparedWithPrevious > 0) return numberOfCompleteWeeks({
                month,
                year
            });
            return 0;
        }, [
            compareWithPrevious,
            month,
            year
        ]);
        const getDates = React.useCallback(({ month, year })=>{
            const dates = [];
            dates.push(...monthDays({
                month,
                year
            }));
            const firstDayIndex = dayOfWeekStartOfMonth({
                month,
                year
            });
            if (firstDayIndex > 0) dates.unshift(...monthDays(prevMonth({
                month,
                year
            }), -firstDayIndex));
            if (dates.length < DAYS_IN_CALENDAR) dates.push(...monthDays(nextMonth({
                month,
                year
            }), DAYS_IN_CALENDAR - dates.length));
            return dates;
        }, []);
        const splitToWeeks = React.useCallback((days)=>{
            return days.reduce((weeks, day)=>{
                if (!weeks[weeks.length - 1] || weeks[weeks.length - 1].length >= DAYS_IN_WEEK) weeks.push([]);
                weeks[weeks.length - 1].push(day);
                return weeks;
            }, []);
        }, []);
        const renderAnimatedDays = ()=>{
            const comparedWithPrevious = compareWithPrevious();
            const previousWeeksNumber = getPreviousWeeksNumber();
            const previousMonthWeeks = comparedWithPrevious < 0 && previousWeeksNumber ? {
                count: previousWeeksNumber
            } : undefined;
            const nextMonthWeeks = comparedWithPrevious > 0 && previousWeeksNumber ? {
                count: previousWeeksNumber,
                offset: 6 - previousWeeksNumber
            } : undefined;
            return _jsx("div", {
                className: styles.animationWrap,
                children: _jsxs("div", {
                    className: classNames(styles.animationScroll, {
                        [styles.animateToPrevious]: comparedWithPrevious < 0,
                        [styles.animateToNext]: comparedWithPrevious > 0,
                        [styles.weeks4]: previousWeeksNumber === 4,
                        [styles.weeks5]: previousWeeksNumber === 5
                    }),
                    ref: onAnimationScrollRef,
                    children: [
                        previousMonthWeeks && _jsx("div", {
                            className: styles.previousMonth,
                            children: renderDays(previousMonthYearRef.current, previousMonthWeeks, 'prev')
                        }),
                        renderDays({
                            month,
                            year
                        }, undefined, 'current'),
                        nextMonthWeeks && _jsx("div", {
                            className: styles.nextMonth,
                            children: renderDays(previousMonthYearRef.current, nextMonthWeeks, 'next')
                        })
                    ]
                })
            }, `days${month}-${year}`);
        };
        const renderDays = (monthYear, weeksChunk, renderedMonth)=>{
            let weeks = splitToWeeks(getDates(monthYear));
            if (weeksChunk) {
                const offset = weeksChunk.offset || 0;
                weeks = weeks.slice(offset, offset + weeksChunk.count);
            }
            const Week = Preconditions.checkExists(CalendarWeek);
            return weeks.map((week)=>_jsx(Week, {
                    renderedMonth: renderedMonth,
                    children: week.map((day)=>renderDay(toISO(day), monthYear, renderedMonth === 'current'))
                }, key(week[0], 'week')));
        };
        const renderDay = (date, { month }, active = true)=>{
            const current = isCurrentMonth(date, month);
            const isSelected = isSelectedDate(date);
            const isFocused = isFocusedDate(date);
            const onSelectedDayRefCallback = isSelected && active ? onSelectedDayRef : undefined;
            const onFocusedDayRefCallback = isFocused ? onFocusedDayRef : undefined;
            const onDayRef = onSelectedDayRefCallback || onFocusedDayRefCallback ? (ref)=>{
                onSelectedDayRefCallback === null || onSelectedDayRefCallback === void 0 ? void 0 : onSelectedDayRefCallback(ref);
                onFocusedDayRefCallback === null || onFocusedDayRefCallback === void 0 ? void 0 : onFocusedDayRefCallback(ref);
            } : undefined;
            const Day = Preconditions.checkExists(CalendarDay);
            return _jsx(Day, {
                locale: locale,
                date: date,
                current: current,
                today: isToday(date),
                past: isPastDate(date),
                selected: isSelected,
                selectedInvalid: selectedInvalid,
                disabled: isDisabledDate(date),
                onSelect: active && onSelect ? handleSelect : undefined,
                onDayRef: onDayRef,
                includeInTabOrder: isIncludedInTabOrderDate(date)
            }, key(date, 'day'));
        };
        return _jsxs("div", {
            className: classNames(styles.calendar, className),
            role: "grid",
            "aria-label": ariaLabelledBy ? undefined : ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-describedby": ariaDescribedBy,
            children: [
                DaysOfWeekLabels && _jsx(DaysOfWeekLabels, {
                    locale: locale
                }),
                _jsx("div", {
                    className: styles.days,
                    children: animate ? renderAnimatedDays() : renderDays({
                        month,
                        year
                    }, undefined, 'current')
                })
            ]
        });
    }
);
