function applyDecs2203RFactory() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = applyDecs2203RFactory())(targetClass, memberDecs, classDecs, parentClass);
}
function _identity(x) {
    return x;
}
var _class;
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
var _initClass, _React_Component;
import { observerForClass } from '../../../../../base/mobx_react/observer_for_class';
import { UnreachableError } from '../../../../../base/preconditions';
import { Observer } from 'mobx-react-lite';
import * as React from 'react';
import { ScreenReaderContent } from '../../../a11y/screen_reader_content/screen_reader_content';
import { Button } from '../../../button/button';
import { Calendar } from '../../calendar/calendar';
import { MonthsNavigation } from '../months_navigation/months_navigation';
import { addDays, addMonths, addYears, compareDates, compareMonthAndYear, dayOfWeek, fromUTCToTimezone, getTimezoneOffset, toUTCDateTimeObject } from '../../utils/utils';
import { TimeInput } from '../../../form/time_input/time_input';
import { shift, WithKeyCombinationHandler } from '../../../key_combinations/key_combinations';
import { Column, Columns, Spacer } from '../../../layout/layout';
import styles from './date_time_picker.css';
import { DateTimePickerMessages } from './date_time_picker.messages';
import { DateTimePickerPresenter } from './date_time_picker_presenter';
let _DateTimePickerComponent;
new (_class = class extends _identity {
    constructor(){
        super(_DateTimePickerComponent), _initClass();
    }
}, (()=>{
    class DateTimePickerComponent extends (_React_Component = React.Component) {
        get date() {
            var _this__date, _this__date1;
            if (((_this__date = this._date) === null || _this__date === void 0 ? void 0 : _this__date.utc) !== this.props.date) {
                if (this.props.date == null)
                    this._date = undefined;
                else this._date = {
                    utc: this.props.date,
                    value: toUTCDateTimeObject(fromUTCToTimezone(this.props.date, this.props.timezone ? this.props.timezone.offset : getTimezoneOffset(this.props.date)))
                };
            }
            return (_this__date1 = this._date) === null || _this__date1 === void 0 ? void 0 : _this__date1.value;
        }
        get time() {
            return this.presenter.getTime(this.store);
        }
        get displayedDate() {
            return this.presenter.getDate(this.store);
        }
        get month() {
            return this.presenter.getMonth(this.store);
        }
        get year() {
            return this.presenter.getYear(this.store);
        }
        get navigationDisabled() {
            const { canSelectPastDates, minSelectableDate, maxSelectableDate } = this.props;
            let disabledNav;
            if ((!canSelectPastDates || minSelectableDate === 'today') && compareMonthAndYear(this.displayedDate, this.store.todayInTimezone) <= 0) disabledNav = 'prev';
            if (minSelectableDate && minSelectableDate !== 'today' && compareMonthAndYear(this.displayedDate, minSelectableDate) <= 0) disabledNav = 'prev';
            if (maxSelectableDate && compareMonthAndYear(this.displayedDate, maxSelectableDate) >= 0) disabledNav = disabledNav === 'prev' ? 'both' : 'next';
            return disabledNav;
        }
        moveFocusBy(delta, deltaType) {
            var _this_store_focusedDateInTimezone;
            const currentDate = (_this_store_focusedDateInTimezone = this.store.focusedDateInTimezone) !== null && _this_store_focusedDateInTimezone !== void 0 ? _this_store_focusedDateInTimezone : this.presenter.getDate(this.store);
            let newDate = currentDate;
            switch(deltaType){
                case 'day':
                    newDate = addDays(currentDate, delta);
                    break;
                case 'month':
                    newDate = addMonths(currentDate, delta);
                    break;
                case 'year':
                    newDate = addYears(currentDate, delta);
                    break;
                default:
                    throw new UnreachableError(deltaType);
            }
            const { canSelectPastDates, minSelectableDate, maxSelectableDate } = this.props;
            if ((!canSelectPastDates || minSelectableDate === 'today') && compareDates(newDate, this.store.todayInTimezone) < 0) newDate = this.store.todayInTimezone;
            if (minSelectableDate && minSelectableDate !== 'today' && compareDates(newDate, minSelectableDate) < 0) newDate = minSelectableDate;
            if (maxSelectableDate && compareDates(newDate, maxSelectableDate) > 0) newDate = maxSelectableDate;
            this.presenter.updateFocusedDate(this.store, toUTCDateTimeObject(newDate));
        }
        moveFocusToStartOfWeek() {
            var _this_store_focusedDateInTimezone;
            const currentDate = (_this_store_focusedDateInTimezone = this.store.focusedDateInTimezone) !== null && _this_store_focusedDateInTimezone !== void 0 ? _this_store_focusedDateInTimezone : this.presenter.getDate(this.store);
            const currentDayOfWeek = dayOfWeek(currentDate);
            if (currentDayOfWeek > 0) this.moveFocusBy(-currentDayOfWeek, 'day');
        }
        moveFocusToEndOfWeek() {
            var _this_store_focusedDateInTimezone;
            const currentDate = (_this_store_focusedDateInTimezone = this.store.focusedDateInTimezone) !== null && _this_store_focusedDateInTimezone !== void 0 ? _this_store_focusedDateInTimezone : this.presenter.getDate(this.store);
            const currentDayOfWeek = dayOfWeek(currentDate);
            if (currentDayOfWeek < 6) this.moveFocusBy(6 - currentDayOfWeek, 'day');
        }
        getKeyMap() {
            const keyMap = [
                [
                    'ArrowRight',
                    (e)=>{
                        e.preventDefault();
                        this.moveFocusBy(1, 'day');
                    }
                ],
                [
                    'ArrowLeft',
                    (e)=>{
                        e.preventDefault();
                        this.moveFocusBy(-1, 'day');
                    }
                ],
                [
                    'ArrowDown',
                    (e)=>{
                        e.preventDefault();
                        this.moveFocusBy(7, 'day');
                    }
                ],
                [
                    'ArrowUp',
                    (e)=>{
                        e.preventDefault();
                        this.moveFocusBy(-7, 'day');
                    }
                ],
                [
                    'Home',
                    (e)=>{
                        e.preventDefault();
                        this.moveFocusToStartOfWeek();
                    }
                ],
                [
                    'End',
                    (e)=>{
                        e.preventDefault();
                        this.moveFocusToEndOfWeek();
                    }
                ],
                [
                    'PageUp',
                    (e)=>{
                        e.preventDefault();
                        this.moveFocusBy(-1, 'month');
                    }
                ],
                [
                    'PageDown',
                    (e)=>{
                        e.preventDefault();
                        this.moveFocusBy(1, 'month');
                    }
                ],
                [
                    shift('PageUp'),
                    (e)=>{
                        e.preventDefault();
                        this.moveFocusBy(-1, 'year');
                    }
                ],
                [
                    shift('PageDown'),
                    (e)=>{
                        e.preventDefault();
                        this.moveFocusBy(1, 'year');
                    }
                ]
            ];
            return keyMap;
        }
        render() {
            return _jsx(WithKeyCombinationHandler, {
                map: this.keyMap,
                handleInputs: false,
                children: ({ ref })=>_jsx(Observer, {
                        children: ()=>{
                            const calendarLabelId = React.useId();
                            const calendarDescriptionId = React.useId();
                            var _this_store_focusedDateInTimezone, _ref;
                            return _jsxs("div", {
                                className: styles.dateTimePicker,
                                children: [
                                    _jsx(MonthsNavigation, {
                                        locale: this.props.locale,
                                        month: this.month,
                                        year: this.year,
                                        today: this.store.todayInTimezone,
                                        disabled: this.navigationDisabled,
                                        animate: this.props.animate,
                                        onChange: this.onChangeMonth,
                                        titleId: calendarLabelId
                                    }),
                                    _jsxs("div", {
                                        ref: ref,
                                        children: [
                                            _jsx(ScreenReaderContent, {
                                                id: calendarDescriptionId,
                                                children: DateTimePickerMessages.calendarDescription()
                                            }),
                                            _jsx(Calendar, {
                                                locale: this.props.locale,
                                                month: this.month,
                                                year: this.year,
                                                animate: this.props.animate,
                                                today: this.store.todayInTimezone,
                                                selected: this.date,
                                                focused: this.store.focusedDateInTimezone,
                                                includedInTabOrder: (_ref = (_this_store_focusedDateInTimezone = this.store.focusedDateInTimezone) !== null && _this_store_focusedDateInTimezone !== void 0 ? _this_store_focusedDateInTimezone : this.store.dateInTimezone) !== null && _ref !== void 0 ? _ref : this.store.todayInTimezone,
                                                selectedInvalid: this.props.selectedDayInvalid,
                                                canSelectPastDates: this.props.canSelectPastDates,
                                                minSelectableDate: this.props.minSelectableDate,
                                                maxSelectableDate: this.props.maxSelectableDate,
                                                onSelect: this.onSelectDay,
                                                ariaLabelledBy: calendarLabelId,
                                                ariaDescribedBy: calendarDescriptionId
                                            })
                                        ]
                                    }),
                                    this.props.mode === 'datetime' && _jsxs(_Fragment, {
                                        children: [
                                            _jsx(Spacer, {
                                                direction: "vertical",
                                                size: "2u"
                                            }),
                                            _jsx(TimeInput, {
                                                value: this.time,
                                                error: this.props.timeInvalid,
                                                onChange: this.onChangeTime,
                                                ariaLabel: DateTimePickerMessages.timePickerLabel(),
                                                timezone: this.store.timezone,
                                                locale: this.props.locale
                                            })
                                        ]
                                    }),
                                    _jsx(this.Footer, {})
                                ]
                            });
                        }
                    })
            });
        }
        constructor(props){
            super(props), this.onChangeMonth = (date)=>{
                this.presenter.unsetFocusedDate(this.store);
                this.presenter.updateDate(this.store, date);
                const navDisabled = this.navigationDisabled;
                if (navDisabled != null) {
                    this.presenter.updateFocusedDate(this.store, date);
                    this.moveFocusBy(0, 'day');
                }
            }, this.onSelectDay = (date)=>{
                this.presenter.updateDate(this.store, date, {
                    updateFocus: true
                });
                this.props.onChange(this.presenter.getUTCDate(this.store));
            }, this.selectToday = ()=>{
                this.presenter.updateDate(this.store, this.store.todayInTimezone, {
                    updateFocus: true
                });
                this.props.onChange(this.presenter.getUTCDate(this.store));
            }, this.clearSelectedDay = ()=>{
                this.presenter.unsetDate(this.store);
                this.presenter.unsetFocusedDate(this.store);
                this.props.onChange(undefined);
            }, this.onChangeTime = (time)=>{
                const timeMs = time !== null && time !== void 0 ? time : 0;
                this.presenter.unsetFocusedDate(this.store);
                this.presenter.updateTime(this.store, timeMs);
                this.props.onChange(this.presenter.getUTCDate(this.store));
            }, this.Footer = ()=>{
                const { clearable, showTodayButton } = this.props;
                if (!clearable && !showTodayButton) return null;
                const columnAlignment = clearable && showTodayButton ? 'spaceBetween' : clearable ? 'start' : 'end';
                return _jsxs(_Fragment, {
                    children: [
                        _jsx(Spacer, {
                            direction: "vertical",
                            size: "1.5u"
                        }),
                        _jsxs(Columns, {
                            spacing: "0",
                            align: columnAlignment,
                            children: [
                                clearable && _jsx(Column, {
                                    width: "content",
                                    children: _jsx(Button, {
                                        variant: "tertiary",
                                        onClick: this.clearSelectedDay,
                                        children: DateTimePickerMessages.clearLabel()
                                    })
                                }),
                                showTodayButton && _jsx(Column, {
                                    width: "content",
                                    children: _jsx(Button, {
                                        variant: "tertiary",
                                        onClick: this.selectToday,
                                        children: DateTimePickerMessages.todayLabel()
                                    })
                                })
                            ]
                        })
                    ]
                });
            };
            this.presenter = props.presenter || new DateTimePickerPresenter();
            this.store = props.store || this.presenter.createStore(props.date, props.locale, props.today, props.timezone);
            this.props.focusToday && this.presenter.updateFocusedDate(this.store, this.store.todayInTimezone);
            this.keyMap = this.getKeyMap();
        }
    }
    ({ c: [_DateTimePickerComponent, _initClass] } = _apply_decs_2203_r(DateTimePickerComponent, [], [
        observerForClass
    ], _React_Component));
    DateTimePickerComponent.defaultProps = {
        animate: false,
        showTodayButton: true,
        clearable: true,
        mode: 'datetime'
    };
})(), _class)();
export class DateTimePicker extends _DateTimePickerComponent {
}
