import { Preconditions, UnreachableError } from '../../../../../base/preconditions';
export const MINUTE = 60000;
export const HOUR = MINUTE * 60;
export const DAY = HOUR * 24;
const PM_PERIOD = HOUR * 12;
const MAX_HOUR_24 = 23;
const MAX_HOUR_12 = 12;
const MIN_HOUR_24 = 0;
const MIN_HOUR_12 = 1;
const MAX_MINUTE = 59;
export const MONDAY_DATE = utc(1900, 0);
export const Month = {
  JAN: 1,
  FEB: 2,
  MAR: 3,
  APR: 4,
  MAY: 5,
  JUN: 6,
  JUL: 7,
  AUG: 8,
  SEP: 9,
  OCT: 10,
  NOV: 11,
  DEC: 12
};
export const DayOfWeek = {
  MON: 0,
  TUE: 1,
  WED: 2,
  THU: 3,
  FRI: 4,
  SAT: 5,
  SUN: 6
};
const dateFormattersCache = {};
export function getTimeOfDay(date) {
  date = toDate(date);
  return toTime({
    hours: date.getUTCHours(),
    minutes: date.getUTCMinutes(),
    timeMode: 'hour24'
  });
}
export function msToTimeString(ms) {
  Preconditions.checkState(ms >= 0 && ms <= DAY, 'Time should be the number of ms from beginning of the day');
  const hours = padTime(Math.trunc(ms / HOUR));
  const minutes = padTime(Math.trunc(ms % HOUR / MINUTE));
  return `${hours}:${minutes}`;
}
export function timeStringToMs(timeString) {
  const timeParts = timeString
  .split(':', 2)
  .map(time => Number(time.slice(0, 2)));
  Preconditions.checkState(timeParts.length === 2, 'Time should be a 24-hour format string - HH:mm');
  return timeParts[0] * HOUR + timeParts[1] * MINUTE;
}
export function dayHours(dayTime, timeMode) {
  Preconditions.checkState(dayTime >= 0 && dayTime <= DAY, 'Time should be number of ms from beginning of the day');
  let hours = Math.floor(dayTime / HOUR);
  if (timeMode === 'hour12') {
    hours = hours % 12;
    return hours ? hours : 12;
  }
  return hours;
}
export function dayMinutes(dayTime) {
  Preconditions.checkState(dayTime >= 0 && dayTime <= DAY, 'Time should be number of ms from beginning of the day');
  return Math.floor(dayTime % HOUR / MINUTE);
}
export function dayPeriod(dayTime) {
  Preconditions.checkState(dayTime >= 0 && dayTime <= DAY, 'Time should be number of ms from beginning of the day');
  return dayTime >= PM_PERIOD ? 'pm' : 'am';
}
export function toTime(opts) {
  if (opts.timeMode === 'hour12') {
    opts.hours = opts.hours % 12;
    opts.hours += opts.period === 'pm' ? 12 : 0;
  }
  return opts.hours * HOUR + opts.minutes * MINUTE;
}
export function padTime(time) {
  return String(time).padStart(2, '0');
}
export function maxInputHour(timeMode) {
  return timeMode === 'hour12' ? MAX_HOUR_12 : MAX_HOUR_24;
}
export function minInputHour(timeMode) {
  return timeMode === 'hour12' ? MIN_HOUR_12 : MIN_HOUR_24;
}
export function maxInputMinutes() {
  return MAX_MINUTE;
}
export function setTimeToDate(date, dayTime) {
  date = toDate(date);
  date.setUTCHours(dayHours(dayTime), dayMinutes(dayTime), 0, 0);
  return date;
}
export function setLocalTimeToDate(date, dayTime) {
  date = toDate(date);
  date.setHours(dayHours(dayTime), dayMinutes(dayTime), 0, 0);
  return date;
}
function utc(year, month, day, hours, minutes) {
  const date = new Date(Date.UTC(year, month, day != null ? day : 1, hours || 0, minutes || 0));
  date.setUTCFullYear(year, month, day !== null && day !== void 0 ? day : 1);
  return date;
}
export function toDate(date) {
  if (date instanceof Date || typeof date === 'number') return new Date(date);else if (typeof date === 'string') return ISOtoDate(date);
  return DateObjectToDate(date);
}
function ISOtoDate(ISODate) {
  const ISOArray = ISODate.split('T');
  const dates = ISOArray[0].split('-').map(Number);
  const times = ((ISOArray[1] || '')
  ).split(':', 2)
  .map(time => Number(time.slice(0, 2)));
  return utc(dates[0], dates[1] - 1, dates[2], times[0] || 0, times[1] || 0);
}
function DateObjectToDate(
  {
    year,
    month,
    day,
    hours,
    minutes
  }
) {
  return utc(year, month - 1, day || 1, hours, minutes);
}
export function dateObjToDateString(
  {
    year,
    month,
    day
  }
) {
  return `${String(year).padStart(4, '0')}-${padTime(month)}-${padTime(day)}`;
}
export function toUTCDateTimeObject(date) {
  date = toDate(date);
  return {
    year: date.getUTCFullYear(),
    month: date.getUTCMonth() + 1,
    day: date.getUTCDate(),
    hours: date.getUTCHours(),
    minutes: date.getUTCMinutes()
  };
}
export function toDateObject(date) {
  const [year, month, day] = date.split('-').map(Number);
  if (year == null || month == null || day == null) return;
  return {
    year,
    month,
    day
  };
}
export function toLocalDateTimeObject(date) {
  date = toDate(date);
  return {
    year: date.getFullYear(),
    month: date.getMonth() + 1,
    day: date.getDate(),
    hours: date.getHours(),
    minutes: date.getMinutes()
  };
}
export function toISO(date) {
  date = toDate(date);
  return date.toISOString()
  .replace(/(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}).*/, '$1');
}
export function getTimestamp(date) {
  date = toDate(date);
  return date.getTime();
}
export function getDate(date) {
  date = toDate(date);
  return date.getUTCDate();
}
export function getMonth(date) {
  date = toDate(date);
  return date.getUTCMonth() + 1;
}
export function getYear(date) {
  date = toDate(date);
  return date.getUTCFullYear();
}
export function nextMonth(date) {
  date = toDate(date);
  return utc(date.getUTCFullYear(), date.getUTCMonth() + 1);
}
export function prevMonth(date) {
  date = toDate(date);
  return utc(date.getUTCFullYear(), date.getUTCMonth() - 1);
}
export function prevWeek(date) {
  return addDays(date, -7);
}
export function nextWeek(date) {
  return addDays(date, 7);
}
export function nextDay(date) {
  return addDays(date, 1);
}
export function prevDay(date, daysOffset = 1) {
  return addDays(date, -daysOffset);
}
export function addDays(date, daysOffset) {
  date = toDate(date);
  date.setUTCDate(date.getUTCDate() + daysOffset);
  return date;
}
export function addMonths(date, monthsOffset) {
  date = toDate(date);
  date.setUTCMonth(date.getUTCMonth() + monthsOffset);
  return date;
}
export function addYears(date, numberOfYears) {
  date = toDate(date);
  date.setUTCFullYear(date.getUTCFullYear() + numberOfYears);
  return date;
}
export function nextHour(date) {
  date = toDate(date);
  date.setHours(date.getHours() + 1);
  return date;
}
export function prevMinute(date, minsOffset = 1) {
  date = toDate(date);
  date.setMinutes(date.getMinutes() - minsOffset);
  return date;
}
export function isEqualDates(date1, date2) {
  return toISO(date1).split('T')[0] === toISO(date2).split('T')[0];
}
export function compareMonthAndYear(date1, date2) {
  date1 = toDate(date1);
  date1.setUTCDate(1);
  date2 = toDate(date2);
  date2.setUTCDate(1);
  return compareDays(date1, date2);
}
export function compareDays(date1, date2) {
  date1 = startOfDay(date1);
  date2 = startOfDay(date2);
  if (date1.getTime() === date2.getTime()) return 0;
  return date1 > date2 ? 1 : -1;
}
export function compareDates(date1, date2) {
  date1 = toDate(date1);
  date1.setUTCSeconds(0);
  date1.setUTCMilliseconds(0);
  date2 = toDate(date2);
  date2.setUTCSeconds(0);
  date2.setUTCMilliseconds(0);
  if (date1.getTime() === date2.getTime()) return 0;
  return date1 > date2 ? 1 : -1;
}
const MILLISECONDS_IN_A_DAY = 86400000;
export function differenceInDays(date1, date2, roundingMode = 'FLOOR') {
  date1 = toDate(date1);
  date2 = toDate(date2);
  const sign = date1.getTime() >= date2.getTime() ? 1 : -1;
  const absNumberOfDays = Math.abs(date1.getTime() - date2.getTime()) / MILLISECONDS_IN_A_DAY;
  const numberOfFullDays = (roundingMode === 'FLOOR' ? Math.floor(absNumberOfDays) : Math.ceil(absNumberOfDays)) * sign;
  return numberOfFullDays === 0 ? 0 : numberOfFullDays;
}
export function min(...values) {
  Preconditions.checkArgument(values.length > 0);
  let minValue = values[0];
  values.forEach(value => {
    if (compareDates(value, minValue) < 0) minValue = value;
  });
  return minValue;
}
export function max(...values) {
  Preconditions.checkArgument(values.length > 0);
  let maxValue = values[0];
  values.forEach(value => {
    if (compareDates(value, maxValue) > 0) maxValue = value;
  });
  return maxValue;
}
export function checkMonth(date, month) {
  return toDate(date).getUTCMonth() + 1 === month;
}
export function dayOfWeek(date) {
  date = toDate(date);
  const dayIndex = date.getUTCDay();
  return dayIndex ? dayIndex - 1 : 6;
}
export function dayOfWeekStartOfMonth(date) {
  date = toDate(date);
  date.setUTCDate(1);
  return dayOfWeek(date);
}
export function numberOfCompleteWeeks(date) {
  const month = getMonth(date);
  const year = getYear(date);
  let dayIndex = new Date(year, month - 1).getDay();
  dayIndex = dayIndex ? dayIndex - 1 : 6;
  return Math.floor((new Date(year, month, 0).getDate() + dayIndex) / 7);
}
export function countDaysInMonth(date) {
  date = toDate(date);
  return utc(date.getUTCFullYear(), date.getUTCMonth() + 1, 0).getUTCDate();
}
export function monthDays(date, count) {
  date = toDate(date);
  const daysOffset = countDaysInMonth(date);
  const year = date.getUTCFullYear();
  const month = date.getUTCMonth();
  const days = [];
  count = count && count < daysOffset ? count : daysOffset;
  for (let i = count > 0 ? 1 : daysOffset + count + 1; i <= (count > 0 ? count : daysOffset); i++) days.push(utc(year, month, i));
  return days;
}
export function startOfDay(date) {
  date = toDate(date);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
export function format(date, locale, type, showInLocalTimezone = false, timeMode) {
  date = toDate(date);
  if (showInLocalTimezone) {
    const timezone = getTimezone(date, locale);
    date = fromUTCToTimezone(date, timezone.offset);
  }
  if (timeMode) {
    const hourCircle = timeMode === 'hour12' ? 'h12' : 'h23';
    locale = locale + `-u-hc-${hourCircle}`;
  }
  dateFormattersCache[locale] = dateFormattersCache[locale] || {};
  if (!dateFormattersCache[locale][type]) switch (type) {
    case 'MMM YYYY':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        month: 'short',
        year: 'numeric'
      });
      break;
    case 'MMMM':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        month: 'long'
      });
      break;
    case 'DD MMMM YYYY':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        day: 'numeric',
        month: 'long',
        year: 'numeric'
      });
      break;
    case 'MMMM YYYY':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        month: 'long',
        year: 'numeric'
      });
      break;
    case 'DD MMMM':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        day: 'numeric',
        month: 'long'
      });
      break;
    case 'DD MMM':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        day: 'numeric',
        month: 'short'
      });
      break;
    case 'weekday':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        weekday: 'long'
      });
      break;
    case 'weekdayShort':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        weekday: 'short'
      });
      break;
    case 'hh:mm':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        hour: '2-digit',
        minute: '2-digit'
      });
      break;
    case 'h':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        hour: 'numeric'
      });
      break;
    case 'fullDateTimeYear':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        hour: '2-digit',
        minute: '2-digit',
        month: 'short',
        weekday: 'long',
        day: 'numeric',
        year: 'numeric'
      });
      break;
    case 'fullDateTime':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        hour: '2-digit',
        minute: '2-digit',
        month: 'short',
        weekday: 'long',
        day: 'numeric'
      });
      break;
    case 'fullDate':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        month: 'numeric',
        weekday: 'long',
        day: 'numeric',
        year: 'numeric'
      });
      break;
    case 'short':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        dateStyle: 'short'
      });
      break;
    case 'medium':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        dateStyle: 'medium'
      });
      break;
    case 'long':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        dateStyle: 'long'
      });
      break;
    case 'full':
      dateFormattersCache[locale][type] = Intl.DateTimeFormat(locale, {
        timeZone: 'UTC',
        dateStyle: 'full'
      });
      break;
    default:
      throw new UnreachableError(type);
  }
  return Preconditions.checkExists(dateFormattersCache[locale][type]).format(date);
}
export function key(date, prefix) {
  date = startOfDay(date);
  return prefix + date.getTime();
}
export function fromUTCToTimezone(date, timezoneOffset) {
  date = toDate(date);
  return new Date(date.getTime() + timezoneOffset * 1000);
}
export function fromTimezoneToUTC(date, timezoneOffset) {
  date = toDate(date);
  return new Date(date.getTime() - timezoneOffset * 1000);
}
export function getTimezone(date, locale) {
  date = toDate(date);
  const offset = getTimezoneOffset(date);
  const label = getTimeZoneLabel(date, locale);
  return {
    offset,
    label
  };
}
export function getTimezoneOffset(date) {
  date = toDate(date);
  return -(date.getTimezoneOffset() * 60);
}
function getTimeZoneLabel(date, locale) {
  date = toDate(date);
  const timeZonePart = new Intl.DateTimeFormat(locale, {
    timeZoneName: 'long'
  }).formatToParts(date).find(part => part.type === 'timeZoneName');
  return timeZonePart ? timeZonePart.value : '';
}
export function formatSecondsToTime(timeInSeconds) {
  const allMinutes = Math.floor(timeInSeconds / 60);
  const hours = Math.floor(allMinutes / 60);
  const minutes = Math.floor(allMinutes % 60);
  const seconds = Math.floor(timeInSeconds % 60);
  return `${hours > 0 ? `${padTime(hours)}:` : ''}${padTime(minutes)}:${padTime(seconds)}`;
}
export function getTimeModeByLocale(locale) {
  return Intl.DateTimeFormat(locale, {
    hour: '2-digit'
  }).resolvedOptions().hour12 === true ? 'hour12' : 'hour24';
}