import { jsx as _jsx } from "react/jsx-runtime";
import { UnreachableError } from '../../../base/preconditions';
import * as React from 'react';
import { createPortal } from 'react-dom';
import { GestureRecognizerView } from '../gestures/gesture_recognizer_view';
import { useAutoplayVideos, useDirection, useDisableDialogBlur, useDisableFocusTraps, useEnableAnimations, useEnableHighColorContrast, useEnableUserSelection, useTheme } from '../provider/provider';
import { Layers } from './internal/layers';
import { BottomSheetDragBehavior } from './internal/sheet_behavior';
import { InternalSheet } from './internal_sheet';
export const getDefaultSheetPeekHeight = (window1)=>Math.round(window1.innerHeight * 0.44);
const DEFAULT_SHEET_PEEK_HEIGHT =
typeof window !== 'undefined' ? getDefaultSheetPeekHeight(window) : undefined;
function useEaselConfiguration() {
    return {
        enableAnimations: useEnableAnimations(),
        direction: useDirection(),
        disableFocusTraps: useDisableFocusTraps(),
        enableUserSelection: useEnableUserSelection(),
        theme: useTheme(),
        enableHighColorContrast: useEnableHighColorContrast(),
        autoplayVideos: useAutoplayVideos(),
        disableDialogBlur: useDisableDialogBlur()
    };
}
const layers = new Layers();
export const LegacySheet = (props)=>_jsx(InternalSheet, {
        ...props,
        easelConfiguration: useEaselConfiguration(),
        layers: layers,
        createPortal: createPortal,
        enableLayerDraggable: false
    });
export const LegacyBottomSheet = ({ onRequestClose, onCloseAnimationComplete, peekHeightPx, ...restProps })=>{
    const [snapHeights, setSnapHeights] = React.useState([
        undefined
    ]);
    React.useEffect(()=>{
        if (peekHeightPx === 'none') {
            setSnapHeights([
                undefined
            ]);
            return;
        }
        setSnapHeights([
            DEFAULT_SHEET_PEEK_HEIGHT,
            undefined
        ]);
    }, [
        peekHeightPx
    ]);
    const [snapIndex, setSnapIndex] = React.useState(0);
    const handleDragTrigger = React.useCallback((opts)=>{
        switch(opts.direction){
            case 'opening':
                const isFullyExpanded = snapIndex + 1 === snapHeights.length;
                if (!isFullyExpanded) setSnapIndex(snapIndex + 1);
                break;
            case 'closing':
                const isSmallestHeight = snapIndex === 0;
                if (isSmallestHeight) onRequestClose && onRequestClose({
                    action: 'resize'
                });
                else setSnapIndex(snapIndex - 1);
                break;
            default:
                throw new UnreachableError(opts.direction);
        }
    }, [
        snapIndex,
        snapHeights.length,
        onRequestClose
    ]);
    const handleCloseAnimationComplete = React.useCallback(()=>{
        setSnapIndex(0);
        onCloseAnimationComplete && onCloseAnimationComplete();
    }, [
        onCloseAnimationComplete
    ]);
    return _jsx(InternalSheet, {
        ...restProps,
        easelConfiguration: useEaselConfiguration(),
        layers: layers,
        createPortal: createPortal,
        hasShadow: true,
        expandContentIntoUnsafeArea: true,
        from: "bottom",
        maxSize: undefined,
        minSize: undefined,
        scrollable: false,
        enableLayerDraggable: true,
        maxVisibleSizePx: snapHeights[snapIndex],
        onRequestClose: onRequestClose,
        onLayerDraggingThresholdTriggered: handleDragTrigger,
        onCloseAnimationComplete: handleCloseAnimationComplete
    });
};
export const LegacyDeviceFrameSheet = (props)=>_jsx(InternalSheet, {
        ...props,
        windowOverride: props.window,
        easelConfiguration: useEaselConfiguration(),
        layers: layers,
        createPortal: createPortal,
        enableLayerDraggable: false
    });
export function createDraggableLegacyBottomSheet(
    { onStateChanged, onPanning, peekSizePx, transparentOverlayOnPeek, viewportTopOffset, window: window1 }
) {
    const sheetBehavior = new BottomSheetDragBehavior(window1, onStateChanged, peekSizePx, transparentOverlayOnPeek, viewportTopOffset, onPanning);
    const recognizers = [
        sheetBehavior.recognizer
    ];
    const Handle = ({ children })=>_jsx(GestureRecognizerView, {
            recognizers: recognizers,
            children: ({ gestureRef })=>_jsx("div", {
                    ref: gestureRef,
                    children: children
                })
        });
    const Sheet = (props)=>_jsx(InternalSheet, {
            ...props,
            easelConfiguration: useEaselConfiguration(),
            from: "bottom",
            layers: layers,
            windowOverride: window1,
            createPortal: createPortal,
            sheetBehavior: sheetBehavior,
            enableLayerDraggable: false
        });
    const sheetController = sheetBehavior;
    return {
        Handle,
        Sheet,
        sheetController,
        isSwipingSheet: ()=>sheetBehavior.isSwiping
    };
}
