import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import classNames from 'classnames';
import { observer } from 'mobx-react-lite';
import * as React from 'react';
import { accessModeState } from '../../a11y/access_mode_state/access_mode_state';
import { getButtonAriaAttributes } from '../../a11y/button_aria_attributes/button_aria_attributes';
import { useIsHoveringInput } from '../../a11y/pointer_input_state/pointer_input_state';
import { ScreenReaderContent } from '../../a11y/screen_reader_content/screen_reader_content';
import { createBasicHTMLHandle } from '../../handle/handle';
import { SkipRenderOnClient } from '../../hydration/skip_render_on_client';
import { AnimatedSpinnerIcon } from '../../icons/animated_spinner/icon';
import { useEnableAnimations } from '../../provider/provider';
import { Tooltip } from '../../tooltip/tooltip';
import { useIsTruncated } from '../../typography/truncated/truncated';
import { Text } from '../../typography/typography';
import styles, { getStyle } from './button.css';
import { ButtonMessages } from './button.messages';
const getButtonContent = (props)=>{
    const { children, iconPosition = 'start', noChildWrapper, icon: Icon, LoadingIcon = AnimatedSpinnerIcon, isTruncatedRef } = props;
    const content = [];
    let displayIcon = null;
    const hiddenAttrs = {
        ['aria-hidden']: props.loading || undefined
    };
    if (Icon) displayIcon = _jsx("span", {
        className: styles.iconWrapper,
        ...hiddenAttrs,
        children: _jsx(Icon, {
            size: props.iconSize || 'medium'
        })
    }, "icon");
    if (iconPosition === 'start' || iconPosition === 'top') content.push(displayIcon);
    if (children) content.push(noChildWrapper ? children : _jsx("span", {
        className: styles.text,
        ref: isTruncatedRef,
        ...hiddenAttrs,
        children: children
    }, "content"));
    if (iconPosition === 'end') content.push(displayIcon);
    if (props.loading) {
        const loadingIconSize = props.iconSize || 'medium';
        content.push(_jsxs("span", {
            className: styles.loadingIconWrapper,
            children: [
                _jsx(LoadingIcon, {
                    size: loadingIconSize
                }),
                _jsx(ScreenReaderContent, {
                    ariaLive: "assertive",
                    children: props.loadingMessage || ButtonMessages.loading()
                })
            ]
        }, "loading"));
    }
    return content;
};
const useClassName = (isAnchor, { children, alignment = 'center', active, selected, pressed, disableActiveStyle, disclosure, loading, disabled, stretch, variant, hideOutline, iconPosition, shape, size, expandClickableArea, icon, iconSize })=>{
    const trueSize = getSize({
        children,
        iconSize,
        size,
        variant
    });
    const squareSizing = allowSquareSizing({
        children,
        variant,
        stretch,
        icon
    });
    const iconOnly = icon != null && !children;
    return classNames(styles.base, {
        [styles.anchor]: isAnchor,
        [styles.button]: variant !== 'basic',
        [styles.hideOutline]: hideOutline,
        [styles.topIcon]: iconPosition === 'top',
        [styles.startIcon]: !iconOnly && icon && (!iconPosition || iconPosition === 'start'),
        [styles.endIcon]: !iconOnly && icon && iconPosition === 'end',
        [styles.noMinWidth]: squareSizing,
        [styles.circleShape]: shape === 'circle',
        [styles.expandClickableArea]: expandClickableArea
    }, getStyle(variant), !disableActiveStyle && getStateStyle({
        active,
        disclosure,
        selected,
        pressed
    }), trueSize && getStyle(trueSize), {
        [styles.stretch]: stretch,
        [styles.loading]: loading,
        [styles.disabled]: disabled,
        [styles.startAlign]: alignment === 'start',
        [styles.centerAlign]: iconOnly || alignment === 'center',
        [styles.endAlign]: alignment === 'end',
        [styles.hoverSupported]: useIsHoveringInput(),
        [styles.animate]: useEnableAnimations(),
        [styles.tinyWidth]: trueSize === 'tiny' && squareSizing,
        [styles.xsmallWidth]: trueSize === 'xsmall' && squareSizing,
        [styles.smallWidth]: trueSize === 'small' && squareSizing,
        [styles.mediumWidth]: trueSize === 'medium' && squareSizing,
        [styles.largeWidth]: trueSize === 'large' && squareSizing
    });
};
function getStateStyle(props) {
    var _props_selected;
    const selected = (_props_selected = props.selected) !== null && _props_selected !== void 0 ? _props_selected : props.disclosure ? undefined : props.active;
    var _props_pressed;
    const pressed = (_props_pressed = props.pressed) !== null && _props_pressed !== void 0 ? _props_pressed : props.disclosure ? props.active : undefined;
    return {
        [styles.selected]: selected,
        [styles.activeDisclosure]: pressed
    };
}
export const useShouldDisableSubmit = (initialShouldDisableSubmit)=>{
    const [disableSubmit, setDisableSubmit] = React.useState(initialShouldDisableSubmit);
    React.useLayoutEffect(()=>{
        setDisableSubmit(false);
    }, []);
    return disableSubmit;
};
export const ButtonInner = observer(React.forwardRef(function ButtonInner(props, ref) {
    const buttonRef = React.useRef(null);
    React.useImperativeHandle(ref, ()=>createBasicHTMLHandle(buttonRef), [
        buttonRef
    ]);
    const composedRef = composeRefs(buttonRef, props.buttonRef, ref);
    const isSubmitButton = props.type === 'submit';
    const disabledAttribute = useShouldDisableSubmit(isSubmitButton);
    const disabledStyle = disabledAttribute || props.disabled;
    const disabled = disabledAttribute || props.disabled || props.loading;
    const className = useClassName(false, {
        ...props,
        hideOutline: accessModeState.isMouseMode,
        disabled: disabledStyle
    });
    const elevationEnabled = props.elevated && props.shape === 'circle' && props.variant !== 'contrast';
    const children = getButtonContent(props);
    const onClickImpl = props.onClick;
    const onClick = React.useCallback((e)=>{
        if (disabled) e.preventDefault();
        else onClickImpl === null || onClickImpl === void 0 ? void 0 : onClickImpl(e);
    }, [
        disabled,
        onClickImpl
    ]);
    const stopPropagationWhenDisabled = disabled ? (e)=>{
        const shouldPrevent = [
            'click',
            'mousedown',
            'mouseup',
            'submit'
        ].includes(e.type) || !('code' in e) || [
            'Enter',
            'Space'
        ].includes(e.code);
        if (shouldPrevent) {
            e.stopPropagation();
            e.preventDefault();
        }
    } : undefined;
    var _props_ariaPressed;
    return _jsx(ElevatedWrapper, {
        containerClassName: props.containerClassName,
        enabled: elevationEnabled,
        children: _jsx("button", {
            ref: composedRef,
            id: props.id,
            onMouseDown: (e)=>{
                var _props_onMouseDown;
                return accessModeState.setAccessMode('mouse') && ((_props_onMouseDown = props.onMouseDown) === null || _props_onMouseDown === void 0 ? void 0 : _props_onMouseDown.call(props, e));
            },
            className: classNames(className, props.className),
            form: props.form,
            onMouseUp: props.onMouseUp,
            onMouseEnter: props.onMouseEnter,
            onMouseLeave: props.onMouseLeave,
            onPointerDown: props.onPointerDown,
            onPointerUp: props.onPointerUp,
            onPointerLeave: props.onPointerLeave,
            onContextMenu: props.onContextMenu,
            onBlur: props.onBlur,
            onFocus: props.onFocus,
            onDragStart: props.onDragStart,
            onDragEnd: props.onDragEnd,
            draggable: props.draggable,
            onClick: onClick,
            onClickCapture: stopPropagationWhenDisabled,
            onMouseDownCapture: stopPropagationWhenDisabled,
            onKeyDownCapture: stopPropagationWhenDisabled,
            onMouseUpCapture: stopPropagationWhenDisabled,
            disabled: disabledAttribute,
            type: props.type || 'button',
            ...getButtonAriaAttributes({
                ...props,
                tagName: 'button',
                selected: (_props_ariaPressed = props.ariaPressed) !== null && _props_ariaPressed !== void 0 ? _props_ariaPressed : props.selected,
                disabled
            }),
            children: children
        })
    });
}));
export const AnchorInner = observer(React.forwardRef(function AnchorInner(props, ref) {
    const anchorRef = React.useRef(null);
    React.useImperativeHandle(ref, ()=>createBasicHTMLHandle(anchorRef), [
        anchorRef
    ]);
    const composedRef = composeRefs(anchorRef, props.buttonRef, ref);
    const semanticallyDisabled = props.disabled || props.loading;
    const targetBlank = props.target === '_blank';
    const rel = targetBlank && !props.rel ? 'noopener' : props.rel;
    const className = useClassName(true, {
        ...props,
        hideOutline: accessModeState.isMouseMode
    });
    const children = getButtonContent(props);
    let linkProps;
    if (!semanticallyDisabled) linkProps = {
        onClick: props.onClick,
        onDragStart: props.onDragStart,
        onDragEnd: props.onDragEnd,
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onContextMenu: props.onContextMenu,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        href: props.href,
        target: props.target,
        rel,
        download: props.download,
        draggable: props.draggable
    };
    else
    linkProps = {
        onClick: (e)=>e.preventDefault(),
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        href: props.href,
        target: props.target,
        download: props.download
    };
    return _jsxs("a", {
        id: props.id,
        ref: composedRef,
        ...linkProps,
        className: classNames(className, props.className),
        ...getButtonAriaAttributes({
            tagName: 'a',
            disabled: semanticallyDisabled,
            ...props
        }),
        children: [
            children,
            props.target != null && _jsx(SkipRenderOnClient, {
                tagName: "span",
                shouldRenderOnClient: ()=>targetBlank,
                children: _jsx(ScreenReaderContent, {
                    tagName: "span",
                    children: ButtonMessages.opensInNewWindow()
                })
            })
        ]
    });
}));
const ButtonWithTooltipInner = React.forwardRef(({ buttonProps, tooltipTriggerProps }, ref)=>{
    const ariaProps = getAriaProps({
        props: buttonProps,
        tooltipTriggerProps
    });
    const onMouseEnter = (event)=>{
        var _buttonProps_onMouseEnter, _tooltipTriggerProps_onMouseEnter;
        (_buttonProps_onMouseEnter = buttonProps.onMouseEnter) === null || _buttonProps_onMouseEnter === void 0 ? void 0 : _buttonProps_onMouseEnter.call(buttonProps, event);
        (_tooltipTriggerProps_onMouseEnter = tooltipTriggerProps.onMouseEnter) === null || _tooltipTriggerProps_onMouseEnter === void 0 ? void 0 : _tooltipTriggerProps_onMouseEnter.call(tooltipTriggerProps);
    };
    const onMouseLeave = (event)=>{
        var _buttonProps_onMouseLeave, _tooltipTriggerProps_onMouseLeave;
        (_buttonProps_onMouseLeave = buttonProps.onMouseLeave) === null || _buttonProps_onMouseLeave === void 0 ? void 0 : _buttonProps_onMouseLeave.call(buttonProps, event);
        (_tooltipTriggerProps_onMouseLeave = tooltipTriggerProps.onMouseLeave) === null || _tooltipTriggerProps_onMouseLeave === void 0 ? void 0 : _tooltipTriggerProps_onMouseLeave.call(tooltipTriggerProps);
    };
    const onMouseDown = (event)=>{
        var _buttonProps_onMouseDown, _tooltipTriggerProps_onMouseDown;
        (_buttonProps_onMouseDown = buttonProps.onMouseDown) === null || _buttonProps_onMouseDown === void 0 ? void 0 : _buttonProps_onMouseDown.call(buttonProps, event);
        (_tooltipTriggerProps_onMouseDown = tooltipTriggerProps.onMouseDown) === null || _tooltipTriggerProps_onMouseDown === void 0 ? void 0 : _tooltipTriggerProps_onMouseDown.call(tooltipTriggerProps);
    };
    const onFocus = (event)=>{
        var _buttonProps_onFocus, _tooltipTriggerProps_onFocus;
        (_buttonProps_onFocus = buttonProps.onFocus) === null || _buttonProps_onFocus === void 0 ? void 0 : _buttonProps_onFocus.call(buttonProps, event);
        (_tooltipTriggerProps_onFocus = tooltipTriggerProps.onFocus) === null || _tooltipTriggerProps_onFocus === void 0 ? void 0 : _tooltipTriggerProps_onFocus.call(tooltipTriggerProps);
    };
    const onBlur = (event)=>{
        var _buttonProps_onBlur, _tooltipTriggerProps_onBlur;
        (_buttonProps_onBlur = buttonProps.onBlur) === null || _buttonProps_onBlur === void 0 ? void 0 : _buttonProps_onBlur.call(buttonProps, event);
        (_tooltipTriggerProps_onBlur = tooltipTriggerProps.onBlur) === null || _tooltipTriggerProps_onBlur === void 0 ? void 0 : _tooltipTriggerProps_onBlur.call(tooltipTriggerProps);
    };
    return _jsx(ButtonInner, {
        ...buttonProps,
        ref: ref,
        ...ariaProps,
        onFocus: onFocus,
        onBlur: onBlur,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onMouseDown: onMouseDown,
        tooltipLabel: undefined
    });
});
const ButtonWithTooltip = observer(React.forwardRef(function ButtonWithTooltip(props, ref) {
    return _jsx(Tooltip, {
        label: props.tooltipLabel,
        description: props.tooltipDescription,
        shortcut: props.tooltipShortcut,
        disabled: props.tooltipDisabled,
        placement: props.tooltipPlacement,
        lineClamp: props.tooltipLineClamp,
        closeOnClick: props.tooltipCloseOnClick,
        children: (triggerProps)=>{
            return _jsx(ButtonWithTooltipInner, {
                ref: ref,
                buttonProps: props,
                tooltipTriggerProps: triggerProps
            });
        }
    });
}));
const AnchorWithTooltipInner = React.forwardRef(({ anchorProps, tooltipTriggerProps }, ref)=>{
    const ariaProps = getAriaProps({
        props: anchorProps,
        tooltipTriggerProps
    });
    const onMouseEnter = (event)=>{
        var _anchorProps_onMouseEnter, _tooltipTriggerProps_onMouseEnter;
        (_anchorProps_onMouseEnter = anchorProps.onMouseEnter) === null || _anchorProps_onMouseEnter === void 0 ? void 0 : _anchorProps_onMouseEnter.call(anchorProps, event);
        (_tooltipTriggerProps_onMouseEnter = tooltipTriggerProps.onMouseEnter) === null || _tooltipTriggerProps_onMouseEnter === void 0 ? void 0 : _tooltipTriggerProps_onMouseEnter.call(tooltipTriggerProps);
    };
    const onMouseLeave = (event)=>{
        var _anchorProps_onMouseLeave, _tooltipTriggerProps_onMouseLeave;
        (_anchorProps_onMouseLeave = anchorProps.onMouseLeave) === null || _anchorProps_onMouseLeave === void 0 ? void 0 : _anchorProps_onMouseLeave.call(anchorProps, event);
        (_tooltipTriggerProps_onMouseLeave = tooltipTriggerProps.onMouseLeave) === null || _tooltipTriggerProps_onMouseLeave === void 0 ? void 0 : _tooltipTriggerProps_onMouseLeave.call(tooltipTriggerProps);
    };
    const onMouseDown = (event)=>{
        var _anchorProps_onMouseDown, _tooltipTriggerProps_onMouseDown;
        (_anchorProps_onMouseDown = anchorProps.onMouseDown) === null || _anchorProps_onMouseDown === void 0 ? void 0 : _anchorProps_onMouseDown.call(anchorProps, event);
        (_tooltipTriggerProps_onMouseDown = tooltipTriggerProps.onMouseDown) === null || _tooltipTriggerProps_onMouseDown === void 0 ? void 0 : _tooltipTriggerProps_onMouseDown.call(tooltipTriggerProps);
    };
    const onFocus = (event)=>{
        var _anchorProps_onFocus, _tooltipTriggerProps_onFocus;
        (_anchorProps_onFocus = anchorProps.onFocus) === null || _anchorProps_onFocus === void 0 ? void 0 : _anchorProps_onFocus.call(anchorProps, event);
        (_tooltipTriggerProps_onFocus = tooltipTriggerProps.onFocus) === null || _tooltipTriggerProps_onFocus === void 0 ? void 0 : _tooltipTriggerProps_onFocus.call(tooltipTriggerProps);
    };
    const onBlur = (event)=>{
        var _anchorProps_onBlur, _tooltipTriggerProps_onBlur;
        (_anchorProps_onBlur = anchorProps.onBlur) === null || _anchorProps_onBlur === void 0 ? void 0 : _anchorProps_onBlur.call(anchorProps, event);
        (_tooltipTriggerProps_onBlur = tooltipTriggerProps.onBlur) === null || _tooltipTriggerProps_onBlur === void 0 ? void 0 : _tooltipTriggerProps_onBlur.call(tooltipTriggerProps);
    };
    return _jsx(AnchorInner, {
        ...anchorProps,
        ref: ref,
        ...ariaProps,
        onFocus: onFocus,
        onBlur: onBlur,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onMouseDown: onMouseDown,
        tooltipLabel: undefined
    });
});
export const AnchorWithTooltip = observer(React.forwardRef(function AnchorWithTooltip(props, ref) {
    return _jsx(Tooltip, {
        label: props.tooltipLabel,
        description: props.tooltipDescription,
        shortcut: props.tooltipShortcut,
        disabled: props.tooltipDisabled,
        placement: props.tooltipPlacement,
        lineClamp: props.tooltipLineClamp,
        closeOnClick: props.tooltipCloseOnClick,
        children: (triggerProps)=>_jsx(AnchorWithTooltipInner, {
                ref: ref,
                anchorProps: props,
                tooltipTriggerProps: triggerProps
            })
    });
}));
export const CircleButtonWithoutLabel = React.forwardRef((props, ref)=>{
    return _jsx(InternalButton, {
        ...props,
        shape: "circle",
        ref: ref
    });
});
export const CircleButtonWithLabel = React.forwardRef(({ variant, children, tooltipLabel: tooltipLabelProp, ...props }, ref)=>{
    const labelId = React.useId();
    const size = getSize({
        ...props,
        variant
    });
    const { isTruncated, ref: isTruncatedRef } = useIsTruncated(children);
    const tooltipLabel = tooltipLabelProp || (isTruncated ? children : undefined);
    return _jsxs("div", {
        className: classNames(styles.circleShapeWrapper, {
            [styles.circleShapeWrapperXsmall]: size === 'xsmall',
            [styles.circleShapeWrapperSmall]: size === 'small',
            [styles.circleShapeWrapperMedium]: size === 'medium',
            [styles.circleShapeWrapperLarge]: size === 'large'
        }),
        children: [
            _jsx(InternalButton, {
                ...props,
                tooltipPlacement: props.tooltipPlacement || 'top',
                shape: "circle",
                ref: ref,
                variant: variant,
                ariaLabelledBy: labelId,
                tooltipLabel: tooltipLabel
            }),
            _jsx("label", {
                className: styles.circleButtonLabel,
                children: _jsx(Text, {
                    size: "small",
                    id: labelId,
                    tagName: "span",
                    alignment: "center",
                    tone: "secondary",
                    lineClamp: 2,
                    ref: typeof children !== 'object' ? isTruncatedRef : undefined,
                    children: children
                })
            })
        ]
    });
});
function getAriaProps({ props, tooltipTriggerProps }) {
    const ariaProps = {
        ariaLabel: props.ariaLabel
    };
    if ((props.children == null || typeof props.children !== 'string') && props.ariaLabelledBy == null && props.ariaLabel == null)
    ariaProps.ariaLabel = props.tooltipDescription != null ? `${props.tooltipLabel}: ${props.tooltipDescription}` : props.tooltipLabel;
    else {
        const hasRedundantTooltip = typeof props.children !== 'object' && props.children === props.tooltipLabel || props.ariaLabel === props.tooltipLabel;
        if (!hasRedundantTooltip && props.ariaDescribedBy == null) ariaProps.ariaDescribedBy = tooltipTriggerProps.tooltipId;
    }
    return ariaProps;
}
function allowSquareSizing({ children, stretch, variant, icon }) {
    return !children && !!icon && !stretch && [
        'subtleLinkButton'
    ].indexOf(variant) === -1;
}
function getSize({ children, iconSize, size, variant }) {
    if ([
        'subtleLinkButton'
    ].indexOf(variant) !== -1) return;
    if (size && size !== 'default') return size;
    if (variant === 'basic')
    return;
    if (!children && iconSize && [
        'tiny',
        'small',
        'large'
    ].indexOf(iconSize) !== -1) return iconSize;
    return 'medium';
}
const ElevatedWrapper = observer(function ElevatedWrapper(props) {
    if (props.enabled) return _jsx("span", {
        className: classNames(styles.elevatedWrapper, props.containerClassName, props.isInsideButton && styles.elevatedWrapperInsideButton),
        children: props.children
    });
    return props.children;
});
export const InternalButton = React.forwardRef(({ tooltipLabel: tooltipLabelProp, ...props }, ref)=>{
    const { isTruncated, ref: isTruncatedRef } = useIsTruncated(props.children);
    const trackTruncation = typeof props.children !== 'object' && props.variant !== 'basic';
    const tooltipLabel = tooltipLabelProp || (isTruncated && trackTruncation ? props.children : undefined);
    if (tooltipLabel != null && tooltipLabel.length > 0) return _jsx(ButtonWithTooltip, {
        ...props,
        ref: ref,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined,
        tooltipLabel: tooltipLabel
    });
    return _jsx(ButtonInner, {
        ...props,
        ref: ref,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined,
        tooltipLabel: undefined,
        tooltipDescription: undefined
    });
});
export const InternalAnchor = React.forwardRef(({ tooltipLabel: tooltipLabelProp, ...props }, ref)=>{
    const { isTruncated, ref: isTruncatedRef } = useIsTruncated(props.children);
    const trackTruncation = typeof props.children !== 'object' && props.variant !== 'basic';
    const tooltipLabel = tooltipLabelProp || (isTruncated ? props.children : undefined);
    if (tooltipLabel != null && tooltipLabel.length > 0) return _jsx(AnchorWithTooltip, {
        ref: ref,
        ...props,
        tooltipLabel: tooltipLabel,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined
    });
    return _jsx(AnchorInner, {
        ref: ref,
        ...props,
        tooltipLabel: undefined,
        tooltipDescription: undefined,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined
    });
});
export const renderButtonOrAnchor = ({ ...props }, ref)=>{
    if (props.type === 'link') return _jsx(InternalAnchor, {
        ...props,
        ref: ref
    });
    return _jsx(InternalButton, {
        ...props,
        ref: ref
    });
};
