import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { RgbaColor, RgbColor } from '../../../../../base/color/color';
import * as React from 'react';
import { Box } from '../../../box/box';
import { NumberInput } from '../../../form/number_input/number_input';
import { TextInput } from '../../../form/text_input/text_input';
import { Swatch } from '../../../swatch/swatch';
import { Text } from '../../../typography/typography';
import styles from './color_code_input.css';
import { ColorCodeInputMessages } from './color_code_input.messages';
export function ColorCodeInput(
    { color, alpha, onChange: onChangeProp, onAlphaChange: onAlphaChangeProp, withSwatch, ariaLabel, ariaLabelledBy, ariaDescribedBy, autoFocus }
) {
    const colorInputRef = React.useRef(null);
    const recentlyBlurredRef = React.useRef(false);
    const [inputValue, setInputValue] = React.useState(color);
    const onChange = React.useCallback((value)=>{
        const inputLength = value.length;
        value = value.replace(/[^0-9a-f]/gi, '');
        const lengthDiff = inputLength - value.length;
        value = `#${value.slice(0, 6)}`;
        setInputValue(value);
        const fudgedValue = fudgeHex(value);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(fudgedValue);
        const colorInput = colorInputRef.current;
        if (colorInput) {
            const cursorPosition = colorInput.selectionStart - lengthDiff + 1;
            colorInput.value = value;
            colorInput.selectionStart = cursorPosition;
            colorInput.selectionEnd = cursorPosition;
        }
    }, [
        onChangeProp
    ]);
    const onAlphaChange = React.useCallback((alpha)=>{
        const value = isNaN(alpha) ? 0 : Math.max(0, Math.min(100, alpha)) / 100;
        onAlphaChangeProp === null || onAlphaChangeProp === void 0 ? void 0 : onAlphaChangeProp(value);
    }, [
        onAlphaChangeProp
    ]);
    const onFocus = React.useCallback(()=>{
        if (!recentlyBlurredRef.current) setTimeout(()=>{
            var _colorInputRef_current;
            return (_colorInputRef_current = colorInputRef.current) === null || _colorInputRef_current === void 0 ? void 0 : _colorInputRef_current.select();
        });
    }, []);
    const onBlur = React.useCallback(()=>{
        recentlyBlurredRef.current = true;
        setTimeout(()=>recentlyBlurredRef.current = false, 0);
    }, []);
    const colorValue = fudgeHex(inputValue) === color ? inputValue : color;
    const { r, g, b } = RgbColor.fromHexString(fudgeHex(colorValue));
    const valueWithAlpha = new RgbaColor(r, g, b, alpha).toRgbaString();
    const shouldRenderAlpha = onAlphaChangeProp != null;
    return _jsx(TextInput, {
        inputClassName: styles.input,
        start: withSwatch ? _jsx(Swatch, {
            size: "xxsmall",
            fill: [
                valueWithAlpha
            ]
        }) : undefined,
        value: colorValue,
        end: shouldRenderAlpha && _jsxs(Box, {
            display: "flex",
            alignItems: "center",
            paddingEnd: "1u",
            className: styles.numInputWrapper,
            children: [
                _jsx(NumberInput, {
                    className: styles.numInput,
                    inputClassName: styles.numInputField,
                    value: Math.round(alpha * 100),
                    borderless: true,
                    max: 100,
                    min: 0,
                    onChange: onAlphaChange,
                    ariaLabel: ColorCodeInputMessages.alphaInputLabel()
                }),
                _jsx(Text, {
                    tone: "tertiary",
                    children: "%"
                })
            ]
        }),
        disableSpellcheck: true,
        onChange: onChange,
        onFocus: onFocus,
        onBlur: onBlur,
        ref: colorInputRef,
        textAlignCenter: !withSwatch && !shouldRenderAlpha,
        autoFocus: autoFocus,
        ariaLabel: ariaLabel,
        ariaLabelledBy: ariaLabelledBy,
        ariaDescribedBy: ariaDescribedBy
    });
}
const fudgeHex = (hex)=>{
    hex = hex.toLowerCase().replace(/[^0-9a-f]/g, '').slice(0, 6);
    hex = hex || 'ffffff';
    if (hex.length <= 3) {
        hex += '0'.repeat(3 - hex.length);
        hex = hex[0].repeat(2) + hex[1].repeat(2) + hex[2].repeat(2);
    } else if (hex.length < 6) hex += '0'.repeat(6 - hex.length);
    return `#${hex}`;
};
