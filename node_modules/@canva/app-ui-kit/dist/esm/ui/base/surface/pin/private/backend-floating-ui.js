import { arrow, autoUpdate, flip, hide, offset, platform, shift, useFloating } from '@floating-ui/react';
import composeRefs from '@seznam/compose-react-refs';
import * as React from 'react';
import { getVisualViewport } from '../../../device_capabilities/visual_viewport';
import { baseUnit } from '../../../metrics/metrics';
import { useDirection } from '../../../provider/provider';
import { useStableFunction } from '../../../stable_function/stable_function';
const BOUNDARY_PADDING_MAP = {
    ['0']: 0,
    ['1u']: baseUnit
};
export function useFloatingUiBackend({ placement: backendPlacement, enableFlip, rtlAware, offset: backendOffset, boundary, boundaryPadding: backendBoundaryPadding, onCalculateLayout }) {
    var _middlewareData_hide;
    const arrowRef = React.useRef(null);
    const contentRef = React.useRef(null);
    const bootstrapDirection = useDirection();
    const isRtl = React.useCallback(()=>{
        if (!rtlAware) return false;
        return bootstrapDirection === 'RTL';
    }, [
        bootstrapDirection,
        rtlAware
    ]);
    const boundaryPadding = BOUNDARY_PADDING_MAP[backendBoundaryPadding];
    const { stickyPlacement, store, enableStickyPlacementRef, cachedPlacementRef } = useStickyPlacement(boundaryPadding);
    const isRtlDirection = isRtl();
    let floatingUiPlacement = getFloatingUiPlacement(backendPlacement, isRtlDirection);
    if (enableStickyPlacementRef.current && cachedPlacementRef.current != null) floatingUiPlacement = cachedPlacementRef.current;
    const calculateLayout = useStableFunction(({ placement, reference, content })=>{
        if (onCalculateLayout == null)
            return;
        const visualViewport = getVisualViewport();
        var _visualViewport_width;
        const viewportWidth = (_visualViewport_width = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _visualViewport_width !== void 0 ? _visualViewport_width : window.innerWidth;
        var _visualViewport_height;
        const viewportHeight = (_visualViewport_height = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _visualViewport_height !== void 0 ? _visualViewport_height : window.innerHeight;
        const availableWidth = viewportWidth - 2 * boundaryPadding;
        let availableHeight = viewportHeight - 2 * boundaryPadding;
        const isVerticalPlacement = placement.startsWith('bottom') || placement.startsWith('top');
        if (isVerticalPlacement) {
            const referenceTop = reference.top;
            const referenceBottom = referenceTop + reference.height;
            const availableHeightTop = referenceTop;
            const availableHeightBottom = viewportHeight - referenceBottom;
            const availableHeightFromReference = Math.max(availableHeightTop, availableHeightBottom);
            availableHeight = Math.min(viewportHeight, availableHeightFromReference) - boundaryPadding - backendOffset.main;
        }
        onCalculateLayout({
            reference,
            content,
            available: {
                width: availableWidth,
                height: availableHeight
            }
        });
    });
    const { refs: { setReference, setFloating }, floatingStyles, update, middlewareData, placement } = useFloating({
        platform: {
            ...platform,
            isRTL: isRtl
        },
        strategy: 'fixed',
        placement: floatingUiPlacement,
        whileElementsMounted: (reference, floating, update)=>{
            const onUpdate = ()=>{
                calculateLayout({
                    placement: floatingUiPlacement,
                    reference: reference.getBoundingClientRect(),
                    content: floating.getBoundingClientRect()
                });
                update();
            };
            return autoUpdate(reference, floating, onUpdate);
        },
        middleware: [
            enableFlip && stickyPlacement({
                backendOffset
            }),
            offset({
                mainAxis: backendOffset.main,
                crossAxis: backendOffset.cross
            }),
            enableFlip && !enableStickyPlacementRef.current && flip({
                flipAlignment: false,
                padding: boundaryPadding,
                boundary: boundary === 'viewport' ? 'clippingAncestors' : boundary,
                rootBoundary: typeof window !== 'undefined' ? getViewportRect() : undefined
            }),
            shift({
                padding: boundaryPadding,
                crossAxis: true,
                boundary: boundary === 'viewport' ? 'clippingAncestors' : boundary
            }),
            enableFlip && store(),
            arrow({
                element: arrowRef
            }),
            {
                name: 'hide',
                fn: (state)=>{
                    var _focusElement_ownerDocument;
                    const { rects: { reference } } = state;
                    const focusElement = window.document.activeElement;
                    var _focusElement_ownerDocument_defaultView;
                    const Node = ((_focusElement_ownerDocument_defaultView = focusElement === null || focusElement === void 0 ? void 0 : (_focusElement_ownerDocument = focusElement.ownerDocument) === null || _focusElement_ownerDocument === void 0 ? void 0 : _focusElement_ownerDocument.defaultView) !== null && _focusElement_ownerDocument_defaultView !== void 0 ? _focusElement_ownerDocument_defaultView : window).Node;
                    const isFocusInContent = focusElement instanceof Node && contentRef.current instanceof Node && contentRef.current.contains(focusElement);
                    const enabled = !isFocusInContent && !(reference.width === 0 && reference.height === 0 && reference.x === 0 && reference.y === 0);
                    if (!enabled) return {};
                    return hide({
                        boundary: boundary === 'viewport' ? getViewportRect() : boundary
                    }).fn(state);
                }
            }
        ]
    });
    React.useLayoutEffect(()=>{
        const arrow = arrowRef.current;
        if (arrow != null) updateArrow(arrow, middlewareData, placement);
    }, [
        middlewareData,
        placement
    ]);
    return {
        setReference,
        contentProps: {
            ref: composeRefs(setFloating, contentRef),
            style: {
                ...floatingStyles,
                visibility: ((_middlewareData_hide = middlewareData.hide) === null || _middlewareData_hide === void 0 ? void 0 : _middlewareData_hide.referenceHidden) ? 'hidden' : 'visible'
            }
        },
        setArrow: useStableFunction((arrow)=>{
            arrowRef.current = arrow;
            if (arrow != null) updateArrow(arrow, middlewareData, placement);
        }),
        update
    };
}
const ARROW_ROTATION_MAP = {
    ['left']: '90deg',
    ['right']: '-90deg',
    ['top']: '180deg',
    ['bottom']: '0deg'
};
function updateArrow(arrow, middlewareData, placement) {
    var _middlewareData_arrow, _middlewareData_arrow1;
    const x = (_middlewareData_arrow = middlewareData.arrow) === null || _middlewareData_arrow === void 0 ? void 0 : _middlewareData_arrow.x;
    const y = (_middlewareData_arrow1 = middlewareData.arrow) === null || _middlewareData_arrow1 === void 0 ? void 0 : _middlewareData_arrow1.y;
    const side = placement.split('-')[0];
    arrow.style.setProperty('position', 'absolute');
    arrow.style.setProperty('left', x != null ? `${x}px` : '');
    arrow.style.setProperty('top', y != null ? `${y}px` : '');
    arrow.style.setProperty('right', '');
    arrow.style.setProperty('bottom', '');
    arrow.style.setProperty(side, '100%');
    arrow.style.setProperty('transform', `rotate(${ARROW_ROTATION_MAP[side]})`);
}
const FLOATING_UI_PLACEMENT_MAP = {
    ['start-top']: {
        ltr: 'left-start',
        rtl: 'right-start'
    },
    ['start-center']: {
        ltr: 'left',
        rtl: 'right'
    },
    ['start-bottom']: {
        ltr: 'left-end',
        rtl: 'right-end'
    },
    ['end-top']: {
        ltr: 'right-start',
        rtl: 'left-start'
    },
    ['end-center']: {
        ltr: 'right',
        rtl: 'left'
    },
    ['end-bottom']: {
        ltr: 'right-end',
        rtl: 'left-end'
    },
    ['top-start']: {
        ltr: 'top-start',
        rtl: 'top-start'
    },
    ['top-center']: {
        ltr: 'top',
        rtl: 'top'
    },
    ['top-end']: {
        ltr: 'top-end',
        rtl: 'top-end'
    },
    ['bottom-start']: {
        ltr: 'bottom-start',
        rtl: 'bottom-start'
    },
    ['bottom-center']: {
        ltr: 'bottom',
        rtl: 'bottom'
    },
    ['bottom-end']: {
        ltr: 'bottom-end',
        rtl: 'bottom-end'
    }
};
function getFloatingUiPlacement(placement, isRtl) {
    const mapping = FLOATING_UI_PLACEMENT_MAP[placement];
    return isRtl ? mapping.rtl : mapping.ltr;
}
function useStickyPlacement(boundaryPadding) {
    const contentHeightRef = React.useRef(undefined);
    const cachedPlacementRef = React.useRef(undefined);
    const enableStickyPlacementRef = React.useRef(false);
    const stickyPlacement = useStableFunction(({ backendOffset })=>({
            name: 'stickyPlacement',
            options: [
                backendOffset
            ],
            fn: ({ rects: { floating }, elements: { reference: referenceEl } })=>{
                if (cachedPlacementRef.current == null)
                    return {};
                const cachedPlacement = cachedPlacementRef.current;
                const viewportHeight = window.innerHeight;
                const referenceRect = referenceEl.getBoundingClientRect();
                const referenceTop = referenceRect.top;
                const additionalPadding = backendOffset.main + boundaryPadding;
                const contentHeight = floating.height;
                let hasEnoughSpaceInCurrentPlacement = false;
                if (cachedPlacement.startsWith('top')) {
                    const availableHeightTop = referenceTop - additionalPadding;
                    hasEnoughSpaceInCurrentPlacement = contentHeight <= availableHeightTop;
                } else if (cachedPlacement.startsWith('bottom')) {
                    const referenceBottom = referenceTop + referenceRect.height;
                    const availableHeightBottom = viewportHeight - referenceBottom - additionalPadding;
                    hasEnoughSpaceInCurrentPlacement = contentHeight <= availableHeightBottom;
                } else return {};
                if (!enableStickyPlacementRef.current && contentHeightRef.current !== contentHeight && hasEnoughSpaceInCurrentPlacement)
                    enableStickyPlacementRef.current = true;
                if (enableStickyPlacementRef.current && !hasEnoughSpaceInCurrentPlacement) {
                    enableStickyPlacementRef.current = false;
                    cachedPlacementRef.current = undefined;
                }
                return {};
            }
        }));
    const store = useStableFunction(()=>({
            name: 'store',
            fn: ({ placement: currentPlacement, rects: { floating } })=>{
                contentHeightRef.current = floating.height;
                if (!enableStickyPlacementRef.current) cachedPlacementRef.current = currentPlacement;
                return {};
            }
        }));
    return {
        stickyPlacement,
        store,
        enableStickyPlacementRef,
        cachedPlacementRef
    };
}
function getViewportRect() {
    let width = document.documentElement.clientWidth;
    let height = document.documentElement.clientHeight;
    let x = 0;
    let y = 0;
    const visualViewport = getVisualViewport();
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
        const iframe = window.frameElement;
        if (iframe) {
            const iframeRect = iframe.getBoundingClientRect();
            x = visualViewport.offsetLeft - iframeRect.left;
            y = visualViewport.offsetTop - iframeRect.top;
        }
    }
    return {
        x,
        y,
        width,
        height
    };
}
