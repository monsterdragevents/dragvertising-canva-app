import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import classNames from 'classnames';
import * as React from 'react';
import Measure from 'react-measure';
import { CSSTransition } from 'react-transition-group';
import { baseUnit } from '../../../metrics/metrics';
import { useEnableAnimations } from '../../../provider/provider';
import { useStableFunction } from '../../../stable_function/stable_function';
import { SurfaceHeader } from '../../header/header';
import { ContentContainer } from '../../internal/content_container';
import { Pin } from '../../pin/pin';
import { Arrow } from './arrow';
import styles, { customProperties } from './popover.css';
const WIDTH_CLASS = {
    ['16u']: styles.width16U,
    ['32u']: styles.width32U,
    ['40u']: styles.width40U,
    ['45u']: styles.width45U,
    ['52u']: styles.width52U,
    ['reference']: styles.widthReference,
    ['auto']: styles.widthAuto
};
export const isReferenceObject = (reference)=>{
    const refObj = reference;
    return refObj && typeof refObj.getBoundingClientRect === 'function';
};
export function Popover(
    { id: idProp, open, onRequestClose, onCloseComplete, onScroll, blockOutsidePointerEvents = false, reference, placement = 'auto', width = 'auto', widthMode = 'fixed', offset = '1u', arrow = false, children, title, description, header, headerStart, headerEnd, headerAlignment, headerDivider = 'always', footer, ...contentContainerProps }
) {
    const defaultId = React.useId();
    const id = idProp || defaultId;
    const PinComponent = useEnableAnimations() ? TransitionPin : StaticPin;
    const contentContainerRef = React.useRef(null);
    const contentContainerClassName = classNames(styles.contentContainer, WIDTH_CLASS[width], widthMode === 'maximum' && styles.widthModeMaximum);
    const onCalculateLayout = React.useCallback((data)=>{
        const element = contentContainerRef.current;
        if (element == null) return;
        element.style.setProperty(customProperties.referenceWidth, `${Math.floor(data.reference.width)}px`);
        element.style.setProperty(customProperties.availableWidth, `${data.available.width}px`);
        element.style.setProperty(customProperties.availableHeight, `${data.available.height}px`);
    }, []);
    const pinRef = React.useRef(null);
    const contentHeightRef = React.useRef(0);
    const updatePinPosition = React.useCallback(()=>{
        var _pinRef_current;
        (_pinRef_current = pinRef.current) === null || _pinRef_current === void 0 ? void 0 : _pinRef_current.update();
    }, []);
    const onResize = React.useCallback((contentRect)=>{
        var _contentRect_client;
        var _contentRect_client_height;
        const contentHeight = (_contentRect_client_height = (_contentRect_client = contentRect.client) === null || _contentRect_client === void 0 ? void 0 : _contentRect_client.height) !== null && _contentRect_client_height !== void 0 ? _contentRect_client_height : 0;
        if (contentHeightRef.current !== contentHeight) {
            contentHeightRef.current = contentHeight;
            updatePinPosition();
        }
    }, [
        updatePinPosition
    ]);
    const [isScrolled, setIsScrolled] = React.useState(false);
    const scrollTopRef = React.useRef(0);
    const handleScroll = React.useCallback((e)=>{
        var _e_target;
        var _e_target_scrollTop;
        const scrollTop = (_e_target_scrollTop = (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.scrollTop) !== null && _e_target_scrollTop !== void 0 ? _e_target_scrollTop : 0;
        onScroll === null || onScroll === void 0 ? void 0 : onScroll({
            scrollTop
        });
        if (headerDivider !== 'when-scrolled') return;
        if (scrollTopRef.current === 0 && scrollTop > 0 || scrollTopRef.current > 0 && scrollTop === 0) {
            scrollTopRef.current = scrollTop;
            setIsScrolled(scrollTop > 0);
        }
    }, [
        onScroll,
        setIsScrolled,
        headerDivider
    ]);
    const showHeaderDivider = headerDivider === 'always' || headerDivider === 'when-scrolled' && isScrolled;
    const onOutsidePointerDown = React.useCallback(({ target })=>{
        if (onRequestClose && target !== 'reference')
        onRequestClose();
    }, [
        onRequestClose
    ]);
    const resolvedReference = typeof reference === 'function' ? reference({
        disclosure: true,
        pressed: open,
        active: open,
        ariaControls: open ? id : undefined,
        ariaHasPopup: contentContainerProps.role
    }) : reference;
    const standardHeader = title != null ? _jsx(SurfaceHeader, {
        title: title,
        description: description,
        start: headerStart,
        end: headerEnd,
        alignment: headerAlignment,
        divider: false
    }) : undefined;
    return _jsx(PinComponent, {
        ref: pinRef,
        placement: placement,
        offset: resolveOffset(offset),
        open: open,
        onOutsidePointerDown: onOutsidePointerDown,
        onCloseComplete: onCloseComplete,
        blockOutsidePointerEvents: blockOutsidePointerEvents,
        onCalculateLayout: onCalculateLayout,
        reference: resolvedReference,
        children: ({ setArrow })=>_jsx(Measure, {
                onResize: onResize,
                client: true,
                children: ({ measureRef })=>_jsxs(ContentContainer, {
                        ref: composeRefs(contentContainerRef, measureRef),
                        className: contentContainerClassName,
                        id: id,
                        onRequestEscape: onRequestClose,
                        onScroll: handleScroll,
                        ...contentContainerProps,
                        children: [
                            arrow ? _jsx(Arrow, {
                                ref: setArrow
                            }) : null,
                            (standardHeader != null || header != null) && _jsxs("div", {
                                className: classNames(styles.header, {
                                    [styles.headerBorder]: showHeaderDivider
                                }),
                                children: [
                                    standardHeader,
                                    header
                                ]
                            }),
                            _jsx("div", {
                                className: styles.content,
                                children: children
                            }),
                            footer != null && _jsx("div", {
                                className: styles.footer,
                                children: footer
                            })
                        ]
                    })
            })
    });
}
const TRANSITION_DURATION = parseInt(styles.transitionTime, 10);
const TRANSITION_CLASS_NAMES = {
    appear: styles.visible,
    appearActive: styles.visible,
    appearDone: styles.visible,
    enter: styles.visible,
    enterActive: styles.visible,
    enterDone: styles.visible,
    exit: styles.hidden,
    exitActive: styles.hidden,
    exitDone: styles.hidden
};
const TransitionPin = React.forwardRef(
    function TransitionPin({ open, onCloseComplete, children, ...props }, ref) {
        const [transitionOpen, setTransitionOpen] = React.useState(open);
        const wrapper = (children)=>
            _jsx(SuspendableCssTransition, {
                classNames: TRANSITION_CLASS_NAMES,
                open: open,
                onEnter: ()=>setTransitionOpen(true),
                onExiting: ()=>setTransitionOpen(false),
                onExited: onCloseComplete,
                timeout: TRANSITION_DURATION,
                children: children
            });
        const wrappedChildren = typeof children === 'function' ? (options)=>wrapper(children(options)) : wrapper(children);
        return _jsx(Pin, {
            ...props,
            ref: ref,
            open: open || transitionOpen,
            children: wrappedChildren
        });
    }
);
const StaticPin = React.forwardRef(function StaticPin({ open, onCloseComplete, children, ...props }, ref) {
    const prevOpen = React.useRef(open);
    React.useEffect(()=>{
        if (prevOpen.current && !open)
            onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
        prevOpen.current = open;
    }, [
        open,
        onCloseComplete
    ]);
    const wrappedChildren = typeof children === 'function' ? (options)=>_jsx("div", {
            className: styles.visible,
            children: children(options)
        }) : _jsx("div", {
        className: styles.visible,
        children: children
    });
    return _jsx(Pin, {
        ...props,
        ref: ref,
        open: open,
        children: wrappedChildren
    });
});
function resolveOffset(offset) {
    if (typeof offset === 'object') return offset;
    return {
        main: offset === '0' ? 0 : parseUnitMultiplier(offset),
        cross: 0
    };
}
const parseUnitMultiplier = (value)=>parseFloat(value.slice(0, -1)) * baseUnit;
function SuspendableCssTransition({ children, classNames, onEnter, onExited, onExiting, open, timeout }) {
    const stableOnExiting = useStableFunction(onExiting !== null && onExiting !== void 0 ? onExiting : ()=>{});
    const stableOnExited = useStableFunction(onExited !== null && onExited !== void 0 ? onExited : ()=>{});
    const nodeRef = React.useRef(null);
    React.useEffect(()=>{
        if (open)
            return;
        const timerId = setTimeout(stableOnExiting, timeout);
        return ()=>clearTimeout(timerId);
    }, [
        timeout,
        stableOnExiting,
        open
    ]);
    React.useEffect(()=>stableOnExited, [
        stableOnExited
    ]);
    return _jsx(CSSTransition, {
        in: open,
        appear: true,
        timeout: timeout,
        classNames: classNames,
        onEnter: onEnter,
        nodeRef: nodeRef,
        children: _jsx("div", {
            ref: nodeRef,
            children: children
        })
    });
}
