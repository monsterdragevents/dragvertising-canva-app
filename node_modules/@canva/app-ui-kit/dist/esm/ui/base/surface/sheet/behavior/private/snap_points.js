import { Preconditions, UnreachableError } from '../../../../../../base/preconditions';
import * as React from 'react';
import { baseUnit } from '../../../../metrics/metrics';
import { getSafeAreaInsets } from '../../../../platform_quirks/get_safe_area_insets';
import { useStableFunction } from '../../../../stable_function/stable_function';
const minTopClearance = 2 * baseUnit;
export function useResolvedSnapPoints({ snapPoints, getScrollHeight }) {
    const resolved = React.useRef(undefined);
    const get = useStableFunction(()=>{
        if (resolved.current != null)
            return resolved.current;
        const scrollHeight = snapPoints.some((snapPoint)=>snapPoint.type === 'auto') ? getScrollHeight() : 0;
        const pending = [];
        for(let index = 0; index < snapPoints.length; index++){
            const height = resolveSnapPoint(snapPoints[index], scrollHeight);
            const resolvedIndex = pending.findIndex((point)=>point.height === height);
            if (resolvedIndex === -1) pending.push({
                height,
                indices: [
                    index
                ]
            });
            else pending[resolvedIndex].indices.push(index);
        }
        resolved.current = pending;
        return resolved.current;
    });
    const clear = useStableFunction(()=>{
        resolved.current = undefined;
    });
    return {
        snapPointControls: {
            get,
            clear
        }
    };
}
function resolveSnapPoint(snapPoint, elHeight) {
    const { top, bottom } = getSafeAreaInsets();
    const availableHeight = window.innerHeight - Math.max(top, minTopClearance) - bottom;
    const percentHeight = availableHeight / 100 * snapPoint.height + bottom;
    switch(snapPoint.type){
        case 'fixed':
            return percentHeight;
        case 'auto':
            return Math.min(elHeight, percentHeight);
        default:
            throw new UnreachableError(snapPoint);
    }
}
export function pointForIndex(points, snapPointIndex) {
    return Preconditions.checkExists(points.find((point)=>point.indices.includes(snapPointIndex)));
}
