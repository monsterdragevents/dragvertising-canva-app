import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import { Preconditions, UnreachableError } from '../../../../../base/preconditions';
import classNames from 'classnames';
import * as React from 'react';
import { CSSTransition } from 'react-transition-group';
import { getVirtualKeyboardOverlayHeight } from '../../../device_capabilities/keyboard';
import { useViewportHeightVariance } from '../../../device_capabilities/viewport_variance';
import { useViewportContainerSize } from '../../../device_capabilities/visual_viewport';
import { Layer } from '../../../layer/layer';
import { Spacer } from '../../../layout/layout';
import { baseUnit } from '../../../metrics/metrics';
import { MobileEventHandler } from '../../../mobile_event_handler/mobile_event_handler';
import { getSafeAreaInsets } from '../../../platform_quirks/get_safe_area_insets';
import { useEnableAnimations } from '../../../provider/provider';
import { SurfaceHeader, SurfaceHeaderCloseButton } from '../../header/header';
import { ContentContainer } from '../../internal/content_container';
import { useScrollPaddingRefs } from '../../internal/scroll_padding';
import { useSheetControls, useSheetDrag, useSheetScroll } from '../behavior/behavior';
import { useContentScrollable } from './content_scrollable';
import styles, { customProperties } from './sheet.css';
export const Sheet = React.forwardRef(
    function Sheet({ open, onOpenComplete, onCloseComplete, onBackButton, backdropVisible = true, ...inner }, ref) {
        const Wrapper = useEnableAnimations() ? TransitionWrapper : StaticWrapper;
        const handleBackButton = React.useCallback((event)=>{
            var _inner_onRequestClose;
            if (!open || onBackButton == null && inner.onRequestClose == null) return;
            event.stopPropagation();
            if (onBackButton) {
                onBackButton(event);
                return;
            }
            (_inner_onRequestClose = inner.onRequestClose) === null || _inner_onRequestClose === void 0 ? void 0 : _inner_onRequestClose.call(inner, {
                action: 'backButton'
            });
        }, [
            open,
            onBackButton,
            inner
        ]);
        return _jsx(Wrapper, {
            open: open,
            onOpenComplete: onOpenComplete,
            onCloseComplete: onCloseComplete,
            backdropVisible: backdropVisible,
            children: _jsx(MobileEventHandler, {
                onBackButton: handleBackButton,
                children: _jsx(SheetInner, {
                    ...inner,
                    backdropVisible: backdropVisible,
                    handleRef: ref
                })
            })
        });
    }
);
const TRANSITION_DURATION = parseInt(styles.transitionTime, 10);
const TRANSITION_CLASS_NAMES = {
    appear: styles.transitioning,
    enter: styles.transitioning,
    exit: styles.transitioning,
    appearActive: styles.visible,
    appearDone: styles.visible,
    enterActive: styles.visible,
    enterDone: styles.visible
};
function TransitionWrapper({ open: propOpen, onOpenComplete, onCloseComplete, backdropVisible, children }) {
    const [transitionOpen, setTransitionOpen] = React.useState(propOpen);
    const nodeRef = React.useRef(null);
    return _jsx(Layer, {
        open: propOpen || transitionOpen,
        markOutsideInert: backdropVisible,
        children: _jsx(CSSTransition, {
            in: propOpen,
            appear: true,
            timeout: TRANSITION_DURATION,
            classNames: TRANSITION_CLASS_NAMES,
            onEnter: ()=>setTransitionOpen(true),
            onEntered: ()=>onOpenComplete === null || onOpenComplete === void 0 ? void 0 : onOpenComplete(),
            onExited: ()=>{
                setTransitionOpen(false);
                onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
            },
            nodeRef: nodeRef,
            children: _jsx("div", {
                ref: nodeRef,
                children: children
            })
        })
    });
}
function StaticWrapper({ open, onCloseComplete, backdropVisible, children }) {
    const prevOpen = React.useRef(open);
    React.useEffect(()=>{
        if (prevOpen.current && !open)
            onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
        prevOpen.current = open;
    }, [
        open,
        onCloseComplete
    ]);
    return _jsx(Layer, {
        open: open,
        markOutsideInert: backdropVisible,
        children: _jsx("div", {
            className: styles.visible,
            children: children
        })
    });
}
const heightMap = {
    ['half']: 50,
    ['full']: 100
};
const dismissPoint = {
    type: 'fixed',
    height: 0
};
function resolveHeight(height) {
    if (height === 'auto') height = {
        autoUpTo: 'full'
    };
    return typeof height === 'string' ? {
        type: 'fixed',
        height: heightMap[height]
    } : {
        type: 'auto',
        height: heightMap[height.autoUpTo]
    };
}
function SheetInner({ handleRef, height = 'auto', scrollToResizeBelow, onRequestClose, onScroll, backdropVisible, handleSafeAreaInsetBottom = true, id, children, title, description, header, headerStart, headerEnd, headerAlignment, headerDivider = 'always', footer, handleVisible = 'auto', ...contentContainerProps }) {
    var _containerRef_current;
    const heights = Array.isArray(height) ? height : [
        height
    ];
    Preconditions.checkArgument(heights.length > 0, 'Sheets require at least one height value');
    const snapPoints = [
        ...heights.map(resolveHeight),
        ...(onRequestClose != null ? [
            dismissPoint
        ] : [])
    ];
    const [snapPointIndex, setSnapPointIndex] = useStabilizedSnapPoint(snapPoints);
    const containerRef = React.useRef(null);
    const footerRef = React.useRef(null);
    const contentRef = React.useRef(null);
    const endMarkerRef = React.useRef(null);
    React.useImperativeHandle(handleRef, ()=>({
            setHeight: (height)=>{
                const newPoint = resolveHeight(height);
                const newIndex = snapPoints.findIndex((point)=>pointsEqual(point, newPoint));
                Preconditions.checkArgument(newIndex !== -1);
                setSnapPointIndex(newIndex);
            },
            scrollTo: (options)=>{
                var _contentRef_current;
                return (_contentRef_current = contentRef.current) === null || _contentRef_current === void 0 ? void 0 : _contentRef_current.scrollTo(options);
            },
            getBoundingClientRect: ()=>{
                var _contentRef_current;
                return (_contentRef_current = contentRef.current) === null || _contentRef_current === void 0 ? void 0 : _contentRef_current.getBoundingClientRect();
            },
            get scrollTop () {
                var _contentRef_current;
                return (_contentRef_current = contentRef.current) === null || _contentRef_current === void 0 ? void 0 : _contentRef_current.scrollTop;
            },
            get scrollLeft () {
                var _contentRef_current1;
                return (_contentRef_current1 = contentRef.current) === null || _contentRef_current1 === void 0 ? void 0 : _contentRef_current1.scrollLeft;
            },
            get scrollHeight () {
                var _contentRef_current2;
                return (_contentRef_current2 = contentRef.current) === null || _contentRef_current2 === void 0 ? void 0 : _contentRef_current2.scrollHeight;
            },
            get scrollWidth () {
                var _contentRef_current3;
                return (_contentRef_current3 = contentRef.current) === null || _contentRef_current3 === void 0 ? void 0 : _contentRef_current3.scrollWidth;
            },
            get clientHeight () {
                var _contentRef_current4;
                return (_contentRef_current4 = contentRef.current) === null || _contentRef_current4 === void 0 ? void 0 : _contentRef_current4.clientHeight;
            },
            get clientWidth () {
                var _contentRef_current5;
                return (_contentRef_current5 = contentRef.current) === null || _contentRef_current5 === void 0 ? void 0 : _contentRef_current5.clientWidth;
            },
            get offsetHeight () {
                var _contentRef_current6;
                return (_contentRef_current6 = contentRef.current) === null || _contentRef_current6 === void 0 ? void 0 : _contentRef_current6.offsetHeight;
            },
            get offsetWidth () {
                var _contentRef_current7;
                return (_contentRef_current7 = contentRef.current) === null || _contentRef_current7 === void 0 ? void 0 : _contentRef_current7.offsetWidth;
            }
        }));
    const { resizing, controls } = useSheetControls({
        snapPoints,
        snapPointIndex,
        setSnapPointIndex: (index)=>{
            if (onRequestClose != null && snapPoints[index] === dismissPoint) {
                onRequestClose({
                    action: 'resize'
                });
                return;
            }
            setSnapPointIndex(index);
        },
        getScrollHeight: ()=>{
            var _endMarkerRef_current, _footerRef_current;
            var _endMarkerRef_current_offsetTop;
            const endMarkerTop = (_endMarkerRef_current_offsetTop = (_endMarkerRef_current = endMarkerRef.current) === null || _endMarkerRef_current === void 0 ? void 0 : _endMarkerRef_current.offsetTop) !== null && _endMarkerRef_current_offsetTop !== void 0 ? _endMarkerRef_current_offsetTop : 0;
            var _footerRef_current_clientHeight;
            const footerHeight = (_footerRef_current_clientHeight = (_footerRef_current = footerRef.current) === null || _footerRef_current === void 0 ? void 0 : _footerRef_current.clientHeight) !== null && _footerRef_current_clientHeight !== void 0 ? _footerRef_current_clientHeight : 0;
            const dragHandleContainerHeight = baseUnit;
            return dragHandleContainerHeight + endMarkerTop + footerHeight + getSafeAreaInsets().bottom;
        },
        setOffset: (offset, snapPointHeight)=>requestAnimationFrame(()=>{
                const el = containerRef.current;
                if (el == null) return;
                let finalOffset = offset;
                if (offset != null && offset > 0) {
                    if (el.clientHeight === snapPointHeight) finalOffset = undefined;
                }
                el.style.transform = finalOffset != null ? `translateY(${-finalOffset}px)` : '';
                const footerEl = footerRef.current;
                if (footerEl == null) return;
                const footerDisplacementY = el.clientHeight - (snapPointHeight !== null && snapPointHeight !== void 0 ? snapPointHeight : 0);
                footerEl.style.transform = finalOffset != null ? `translateY(${finalOffset - footerDisplacementY}px)` : '';
            })
    });
    const viewportDifferenceHeight = useViewportHeightVariance();
    const visualViewport = useViewportContainerSize();
    const virtualKeyboardHeight = getVirtualKeyboardOverlayHeight() + 'px';
    const hasHandle = handleVisible === 'auto' && snapPoints.length > 1;
    const snapPoint = snapPoints[snapPointIndex];
    var _containerRef_current_clientHeight;
    const snapHeight = calculateSnapHeight(snapPoint, resizing, (_containerRef_current_clientHeight = (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.clientHeight) !== null && _containerRef_current_clientHeight !== void 0 ? _containerRef_current_clientHeight : 0);
    const onRequestCloseByBackdrop = React.useCallback(()=>{
        onRequestClose === null || onRequestClose === void 0 ? void 0 : onRequestClose({
            action: 'backdrop'
        });
    }, [
        onRequestClose
    ]);
    const [isScrolled, setIsScrolled] = React.useState(false);
    const scrollTopRef = React.useRef(0);
    const handleScroll = React.useCallback(({ scrollTop })=>{
        onScroll === null || onScroll === void 0 ? void 0 : onScroll({
            scrollTop
        });
        if (headerDivider !== 'when-scrolled') return;
        if (scrollTopRef.current === 0 && scrollTop > 0 || scrollTopRef.current > 0 && scrollTop === 0) {
            scrollTopRef.current = scrollTop;
            setIsScrolled(scrollTop > 0);
        }
    }, [
        onScroll,
        headerDivider,
        setIsScrolled,
        scrollTopRef
    ]);
    const { containerRef: scrollPaddingContainerRef, headerRef: scrollPaddingHeaderRef, footerRef: scrollPaddingFooterRef } = useScrollPaddingRefs();
    let content = _jsxs(_Fragment, {
        children: [
            children,
            _jsx("div", {
                ref: endMarkerRef
            })
        ]
    });
    const showHeaderDivider = headerDivider === 'always' || headerDivider === 'when-scrolled' && isScrolled;
    let endDecorator;
    if (headerEnd == null && onRequestClose != null) endDecorator = _jsx(SurfaceHeaderCloseButton, {
        onClick: ()=>onRequestClose()
    });
    else endDecorator = headerEnd === 'none' ? undefined : headerEnd;
    const standardHeader = title != null ? _jsx(SurfaceHeader, {
        title: title,
        description: description,
        start: headerStart,
        end: endDecorator,
        alignment: headerAlignment,
        divider: false
    }) : undefined;
    const hasDecorations = standardHeader != null || header != null || footer != null;
    if (hasDecorations) content = _jsxs(_Fragment, {
        children: [
            (standardHeader != null || header != null) && _jsxs("div", {
                ref: scrollPaddingHeaderRef,
                className: classNames(styles.header, {
                    [styles.headerBorder]: showHeaderDivider
                }),
                children: [
                    standardHeader,
                    header
                ]
            }),
            _jsx("div", {
                className: styles.content,
                children: content
            }),
            footer != null && _jsx("div", {
                className: styles.footer,
                ref: composeRefs(footerRef, scrollPaddingFooterRef),
                children: footer
            })
        ]
    });
    const visualViewportOffsetTop = visualViewport ? `${visualViewport.offsetTop}px` : undefined;
    const visualViewportHeight = visualViewport ? `${visualViewport.height}px` : undefined;
    return _jsx("div", {
        className: classNames(styles.sheetContainer, backdropVisible && styles.backdrop, hasDecorations && styles.hasDecorations),
        style: {
            [customProperties.visualViewportOffsetTop]: visualViewportOffsetTop,
            [customProperties.virtualKeyboardHeight]: virtualKeyboardHeight
        },
        children: _jsx("div", {
            className: styles.safeAreaHandler,
            style: {
                [customProperties.viewportDifferenceHeight]: viewportDifferenceHeight
            },
            children: _jsxs("div", {
                className: classNames(styles.sheet, snapPoint.type === 'auto' && styles.auto, resizing && styles.resizing),
                style: {
                    [customProperties.snapHeight]: snapHeight,
                    [customProperties.visualViewportHeight]: visualViewportHeight
                },
                ref: containerRef,
                children: [
                    backdropVisible && onRequestClose != null && _jsx("div", {
                        role: "none",
                        className: styles.dismissArea,
                        onClick: onRequestCloseByBackdrop
                    }),
                    hasHandle ? _jsx(SheetDragHandle, {
                        controls: controls
                    }) : _jsx(Spacer, {
                        size: "1u"
                    }),
                    _jsx(SheetContent, {
                        ref: contentRef,
                        scrollPaddingRef: scrollPaddingContainerRef,
                        scrollToResizeBelow: scrollToResizeBelow && resolveHeight(scrollToResizeBelow),
                        controls: controls,
                        handleSafeAreaInsetBottom: handleSafeAreaInsetBottom,
                        id: id,
                        onScroll: handleScroll,
                        ...contentContainerProps,
                        children: content
                    })
                ]
            })
        })
    });
}
function useStabilizedSnapPoint(snapPoints) {
    const [index, setIndex] = React.useState(0);
    const previousSnapPoints = React.useRef(snapPoints);
    React.useLayoutEffect(()=>{
        const previousPoint = previousSnapPoints.current[index];
        if (!pointsEqual(snapPoints[index], previousPoint)) {
            let newIndex = snapPoints.findIndex((point)=>pointsEqual(point, previousPoint));
            if (newIndex === -1) newIndex = 0;
            setIndex(newIndex);
        }
        previousSnapPoints.current = snapPoints;
    }, [
        snapPoints,
        index
    ]);
    return [
        Math.min(index, snapPoints.length - 1),
        setIndex
    ];
}
const pointsEqual = (a, b)=>a != null && b != null && a.type === b.type && a.height === b.height;
function calculateSnapHeight(snapPoint, resizing, containerHeight) {
    switch(snapPoint.type){
        case 'fixed':
            return snapPoint.height + '%';
        case 'auto':
            if (!resizing)
                return snapPoint.height + '%';
            return containerHeight - getSafeAreaInsets().bottom + 'px';
        default:
            throw new UnreachableError(snapPoint);
    }
}
function SheetDragHandle({ controls }) {
    const { dragRef } = useSheetDrag({
        controls
    });
    return _jsx("div", {
        className: styles.dragHandleContainer,
        ref: dragRef,
        children: _jsx("div", {
            className: styles.dragHandle
        })
    });
}
const SheetContent = React.forwardRef(
    function SheetContent({ controls, scrollToResizeBelow, handleSafeAreaInsetBottom, onScroll, id, children, scrollPaddingRef, ...contentContainerProps }, ref) {
        const { contentRef } = useSheetScroll({
            controls,
            scrollToResizeBelow
        });
        const { hasScroll, contentScrollRef } = useContentScrollable();
        const imperativeScrollRef = useImperativeScrollRef(ref);
        const handleScroll = React.useCallback((e)=>{
            var _e_target;
            var _e_target_scrollTop;
            const scrollTop = (_e_target_scrollTop = (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.scrollTop) !== null && _e_target_scrollTop !== void 0 ? _e_target_scrollTop : 0;
            onScroll === null || onScroll === void 0 ? void 0 : onScroll({
                scrollTop
            });
        }, [
            onScroll
        ]);
        return _jsx(ContentContainer, {
            ref: composeRefs(contentRef, contentScrollRef, imperativeScrollRef, scrollPaddingRef),
            id: id,
            className: classNames(styles.contentContainer, {
                [styles.handleSafeAreaInsetBottom]: handleSafeAreaInsetBottom,
                [styles.noTouchAction]: !hasScroll
            }),
            onScroll: handleScroll,
            ...contentContainerProps,
            children: children
        });
    }
);
function useImperativeScrollRef(ref) {
    const innerRef = React.useRef(null);
    React.useImperativeHandle(ref, ()=>({
            scrollTo: (options)=>{
                const el = innerRef === null || innerRef === void 0 ? void 0 : innerRef.current;
                if (el == null) return;
                if (typeof options === 'number') el.scrollTo(0, options);
                else el.scrollTo(options);
            },
            getBoundingClientRect: ()=>{
                var _innerRef_current;
                return (_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.getBoundingClientRect();
            },
            get scrollTop () {
                var _innerRef_current;
                return (_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.scrollTop;
            },
            get scrollLeft () {
                var _innerRef_current1;
                return (_innerRef_current1 = innerRef.current) === null || _innerRef_current1 === void 0 ? void 0 : _innerRef_current1.scrollLeft;
            },
            get scrollHeight () {
                var _innerRef_current2;
                return (_innerRef_current2 = innerRef.current) === null || _innerRef_current2 === void 0 ? void 0 : _innerRef_current2.scrollHeight;
            },
            get scrollWidth () {
                var _innerRef_current3;
                return (_innerRef_current3 = innerRef.current) === null || _innerRef_current3 === void 0 ? void 0 : _innerRef_current3.scrollWidth;
            },
            get clientHeight () {
                var _innerRef_current4;
                return (_innerRef_current4 = innerRef.current) === null || _innerRef_current4 === void 0 ? void 0 : _innerRef_current4.clientHeight;
            },
            get clientWidth () {
                var _innerRef_current5;
                return (_innerRef_current5 = innerRef.current) === null || _innerRef_current5 === void 0 ? void 0 : _innerRef_current5.clientWidth;
            },
            get offsetHeight () {
                var _innerRef_current6;
                return (_innerRef_current6 = innerRef.current) === null || _innerRef_current6 === void 0 ? void 0 : _innerRef_current6.offsetHeight;
            },
            get offsetWidth () {
                var _innerRef_current7;
                return (_innerRef_current7 = innerRef.current) === null || _innerRef_current7 === void 0 ? void 0 : _innerRef_current7.offsetWidth;
            }
        }));
    return innerRef;
}
