import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import classnames from 'classnames';
import * as React from 'react';
import Measure from 'react-measure';
import { AspectRatio } from '../../aspect_ratio/aspect_ratio';
import { PlusIcon } from '../../icons/plus/icon';
import { ClickableSwatch, DeletableSwatch, getBorderRadiusStyles, StaticSwatch } from './internal_swatch';
import { ColorStripes as SvgColorStripes } from './svg_color';
import styles from './swatch.css';
import { SwatchMessages } from './swatch.messages';
import { fixPrecisionError, generateSwatchLabel, getSwatchName, getValidGradientString, toStripePosition, toStripeWidth, useContrastingColors } from './swatch_util';
const getClassName = ({
  size,
  shape,
  stretch,
  aspectRatio
}) => {
  const fluidStyles = {
    [styles.stretch]: stretch,
    [styles.aspectRatio]: stretch && aspectRatio
  };
  const sizeStyles = {
    [styles.xxsmall]: size === 'xxsmall',
    [styles.xsmall]: size === 'xsmall',
    [styles.small]: size === 'small',
    [styles.medium]: size === 'medium',
    [styles.large]: size === 'large'
  };
  const borderRadiusStyles = getBorderRadiusStyles(shape, size);
  return classnames(styles.swatch, sizeStyles, fluidStyles, borderRadiusStyles);
};
const getBackgroundClassName = ({
  variant,
  fill,
  contrastingColors,
  isCheckeredBgPresent,
  areNoColorsApplied
}) => {
  const variantStyles = {
    [styles.outline]: variant === 'outline'
  };
  const fillStyles = {
    [styles.colorSpectrumCircular]: areNoColorsApplied || fill === 'circularSpectrum' || contrastingColors === 'circularSpectrum',
    [styles.colorSpectrumLinear]: fill === 'linearSpectrum',
    [styles.colorTransparent]: isCheckeredBgPresent
  };
  return classnames(styles.background, variantStyles, fillStyles);
};
const getInlineStyles = (colors, width) => {
  if (!(colors === null || colors === void 0 ? void 0 : colors.length)) return undefined;
  const backgroundImage = colors.map(color => {
    if (typeof color === 'string') return getValidGradientString(color);
    if (color == null)
      return getValidGradientString('transparent');
    return undefined;
  }).filter(Boolean).join(', ');
  const backgroundSize = colors.length > 1 ? `${colors.map((c, i) => toStripeWidth(width, colors.length)).join(', ')}` : undefined;
  const backgroundPositionX = colors.length > 1 ? `${colors.map((c, i) => toStripePosition(i, colors.length - 1)).join(', ')}` : undefined;
  const backgroundRepeat = colors.length > 1 ? 'no-repeat' : undefined;
  return {
    backgroundImage,
    backgroundRepeat,
    backgroundSize,
    backgroundPositionX
  };
};
const getSwatchContent = ({
  areAllColorsTransparent,
  isCheckeredBgPresent,
  colors,
  width,
  height
}) => {
  if (colors == null || colors.every(c => c === undefined || typeof c === 'string')) {
    const inlineStyles = getInlineStyles(colors, width !== null && width !== void 0 ? width : 0);
    if (areAllColorsTransparent) return {
      node: _jsx("span", {
        className: styles.strike
      })
    };
    if (isCheckeredBgPresent) return {
      node: _jsx("span", {
        className: classnames(styles.colors),
        style: inlineStyles
      })
    };
    return {
      backgroundStyles: inlineStyles
    };
  }
  return {
    node: _jsx(SvgColorStripes, {
      className: styles.colors,
      fills: colors,
      width: width ? fixPrecisionError(width) : 1,
      height: height ? fixPrecisionError(height) : 1
    })
  };
};
export const Swatch = React.forwardRef(({
  fill,
  size = 'medium',
  variant = 'solid',
  shape = 'circle',
  Icon,
  onClick,
  active,
  selected,
  pressed,
  disabled,
  disclosure,
  role,
  tabIndex,
  tooltipLabel,
  disableTooltip,
  stretch,
  colorNames,
  rgbToCmyk,
  id,
  ariaLabel,
  tooltipDescription,
  ariaDescribedBy,
  ariaLabelledBy,
  onDelete,
  deleteButtonVisibility = 'on-hover',
  aspectRatio,
  ariaHasPopup,
  ariaControls
}, ref) => {
  const [spanBounds, setSpanBounds] = React.useState({});
  const contrastingColors = useContrastingColors(fill, variant === 'contrast');
  const colors = contrastingColors instanceof Array ? contrastingColors : undefined;
  const areNoColorsApplied = (colors === null || colors === void 0 ? void 0 : colors.length) === 0;
  const isAtleastOneColorTransparent = !areNoColorsApplied && (colors === null || colors === void 0 ? void 0 : colors.some(c => !c)) || false;
  const areAllColorsTransparent = !areNoColorsApplied && (colors === null || colors === void 0 ? void 0 : colors.every(c => !c)) || false;
  const isCheckeredBgPresent = fill !== 'linearSpectrum' && fill !== 'circularSpectrum' && contrastingColors !== 'circularSpectrum' && !areNoColorsApplied;
  const className = getClassName({
    size,
    shape,
    stretch,
    aspectRatio
  });
  const backgroundClassName = getBackgroundClassName({
    variant,
    fill,
    contrastingColors,
    isCheckeredBgPresent,
    areNoColorsApplied
  });
  const content = getSwatchContent({
    areAllColorsTransparent,
    isCheckeredBgPresent,
    colors,
    width: spanBounds.width,
    height: spanBounds.height
  });
  const defaultLabel = React.useMemo(() => generateSwatchLabel({
    colors,
    rgbToCmyk,
    areNoColorsApplied,
    areAllColorsTransparent,
    isAtleastOneColorTransparent,
    fill
  }), [colors, rgbToCmyk, areNoColorsApplied, areAllColorsTransparent, isAtleastOneColorTransparent, fill]);
  const nameLabel = React.useMemo(() => getSwatchName(colors, colorNames), [colors, colorNames]);
  var _ref;
  const tooltipLabelText = !disableTooltip ? (_ref = tooltipLabel !== null && tooltipLabel !== void 0 ? tooltipLabel : nameLabel) !== null && _ref !== void 0 ? _ref : defaultLabel : '';
  const tooltipDescriptionText = tooltipDescription !== null && tooltipDescription !== void 0 ? tooltipDescription : nameLabel ? defaultLabel : undefined;
  const ariaLabelText = ariaLabel !== null && ariaLabel !== void 0 ? ariaLabel : defaultLabel;
  const isClickable = !!onClick;
  const isDeletable = !!onDelete;
  const staticRef = React.useRef(null);
  const clickableRef = React.useRef(null);
  const deletableRef = React.useRef(null);
  React.useImperativeHandle(ref, () => ({
    focus: () => {
      var _this;
      var _clickableRef_current, _ref;
      (_this = (_ref = (_clickableRef_current = clickableRef.current) !== null && _clickableRef_current !== void 0 ? _clickableRef_current : deletableRef.current) !== null && _ref !== void 0 ? _ref : staticRef.current) === null || _this === void 0 ? void 0 : _this.focus();
    },
    blur: () => {
      var _this;
      var _clickableRef_current, _ref;
      (_this = (_ref = (_clickableRef_current = clickableRef.current) !== null && _clickableRef_current !== void 0 ? _clickableRef_current : deletableRef.current) !== null && _ref !== void 0 ? _ref : staticRef.current) === null || _this === void 0 ? void 0 : _this.blur();
    }
  }));
  const swatch = _jsxs(StaticSwatch, {
    ref: staticRef,
    className: className,
    ariaLabel: ariaLabelText,
    ariaLabelledBy: ariaLabelledBy,
    ariaDescribedBy: ariaDescribedBy,
    id: id,
    isRoot: !isDeletable && !isClickable,
    children: [_jsx(Measure, {
      bounds: true,
      onResize: ({
        bounds
      }) => setSpanBounds(bounds !== null && bounds !== void 0 ? bounds : {}),
      children: ({
        measureRef
      }) => _jsx("span", {
        ref: measureRef,
        className: backgroundClassName,
        style: content.backgroundStyles,
        children: content.node
      })
    }), Icon && _jsx("span", {
      className: styles.icon,
      children: Icon()
    })]
  });
  const interactiveSwatch = isClickable ? _jsx(ClickableSwatch, {
    ref: clickableRef,
    size: size,
    shape: shape,
    onClick: onClick,
    active: active,
    selected: selected,
    pressed: pressed,
    disabled: disabled,
    disclosure: disclosure,
    ariaLabel: ariaLabelText,
    role: role,
    tabIndex: tabIndex,
    stretch: stretch,
    aspectRatio: aspectRatio,
    ariaHasPopup: ariaHasPopup,
    ariaControls: ariaControls,
    tooltipLabel: tooltipLabelText,
    tooltipDescription: tooltipDescriptionText,
    disableTooltip: disableTooltip,
    isRoot: !isDeletable,
    children: swatch
  }) : swatch;
  const fluidSwatch = stretch && aspectRatio ? _jsx(AspectRatio, {
    ratio: aspectRatio,
    children: interactiveSwatch
  }) : interactiveSwatch;
  const swatchWithDeleteButton = isDeletable ? _jsx(DeletableSwatch, {
    ref: deletableRef,
    onDelete: onDelete,
    stretch: stretch,
    aspectRatio: aspectRatio,
    deleteButtonVisibility: deleteButtonVisibility,
    disableTooltip: disableTooltip,
    isRoot: true,
    children: fluidSwatch
  }) : fluidSwatch;
  return swatchWithDeleteButton;
});
const iconSizeMap = {
  ['xxsmall']: 'tiny',
  ['xsmall']: 'small',
  ['small']: 'small',
  ['medium']: 'small',
  ['large']: 'medium'
};
export const AddColorButton = props => {
  const {
    ariaLabel,
    tooltipLabel,
    size = 'medium'
  } = props;
  const Icon = () => _jsx("span", {
    className: styles.iconOverlay,
    children: _jsx(PlusIcon, {
      size: iconSizeMap[size],
      tone: "primary"
    })
  });
  return _jsx(Swatch, {
    ...props,
    fill: "circularSpectrum",
    tooltipLabel: tooltipLabel !== null && tooltipLabel !== void 0 ? tooltipLabel : SwatchMessages.addColor(),
    ariaLabel: ariaLabel !== null && ariaLabel !== void 0 ? ariaLabel : SwatchMessages.addColor(),
    Icon: Icon
  });
};