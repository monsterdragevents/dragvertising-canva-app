import { UnreachableError } from '../../../../base/preconditions';
import { getSpaceValue } from '../../metrics/metrics';
import { generateStyle } from '../../responsive/responsive';
import resetStyles from './_reset.css';
import { getStyle as getAlignmentStyle } from './alignment.css';
import { getStyle as getBackgroundStyle } from './background.css';
import { getStyle as getBorderStyle } from './border.css';
import displayStyles, { customProperties as displayProperties } from './display.css';
import flexStyles, { customProperties as flexProperties } from './flex.css';
import paddingStyles, { customProperties as paddingProperties } from './padding.css';
import { getStyle as getPositionStyle } from './position.css';
import { getStyle as getShadowStyle } from './shadow.css';
import { getStyle as getSizeStyle } from './size.css';
export function resetAtom(reset) {
    if (reset) return resetStyles.reset;
    return null;
}
export const displays = [
    'block',
    'none',
    'flex',
    'inline-flex'
];
export const getDisplayClassNames = (display)=>[
        display && displayStyles.hasDisplay
    ];
const displayPropertyMap = {
    default: displayProperties.defaultDisplay,
    smallUp: displayProperties.smallUpDisplay,
    mediumUp: displayProperties.mediumUpDisplay,
    largeUp: displayProperties.largeUpDisplay,
    xLargeUp: displayProperties.xLargeUpDisplay
};
export const getDisplayStyles = (display)=>({
        ...(display && generateStyle(displayPropertyMap, display))
    });
export const backgroundTones = [
    'contrast',
    'assist',
    'positive',
    'info',
    'warn',
    'critical',
    'neutralLow',
    'assistLow',
    'positiveLow',
    'infoLow',
    'warnLow',
    'criticalLow',
    'checkered',
    'neutral',
    'neutralSubtle',
    'elevationSurfaceSunken',
    'elevationSurface',
    'elevationSurfaceRaised',
    'elevationSurfaceFloating',
    'feedbackOverlay',
    'feedbackHint',
    'feedbackHintSubtle',
    'feedbackPositive',
    'feedbackPositiveSubtle',
    'feedbackInfo',
    'feedbackInfoSubtle',
    'feedbackWarn',
    'feedbackWarnSubtle',
    'feedbackCritical',
    'feedbackCriticalSubtle'
];
export function backgroundAtom(background) {
    if (!background) return null;
    return getBackgroundStyle(`${background}Background`);
}
export const borders = [
    'none',
    'standard',
    'critical',
    'low'
];
export const borderRadiuses = [
    'none',
    'legacyStandard',
    'legacyLarge',
    'elementSmall',
    'element',
    'elementRelaxed',
    'container',
    'containerLarge',
    'tag',
    'baseUnit',
    'elementSharp',
    'elementStandard',
    'elementRound',
    'elementSoft',
    'elementSoftest',
    'containerStandard',
    'containerSoft',
    'containerSoftest'
];
export function borderAtom(border) {
    if (!border || border === 'none') return null;
    return getBorderStyle(`${border}Border`);
}
export function borderPositionAtom({ top, bottom, start, end }) {
    return [
        top && getBorderStyle(`${top}BorderTop`),
        bottom && getBorderStyle(`${bottom}BorderBottom`),
        start && getBorderStyle(`${start}BorderStart`),
        end && getBorderStyle(`${end}BorderEnd`)
    ];
}
export function borderRadiusAtom(borderRadius) {
    if (!borderRadius || borderRadius === 'none') return null;
    return getBorderStyle(`${borderRadius}BorderRadius`);
}
export const shadows = [
    'none',
    'surface',
    'surfaceHigh',
    'handle',
    'elevationSurfaceFloating',
    'elevationHandleRaised',
    'elevationSurfaceRaised'
];
export function shadowAtom(shadow) {
    if (!shadow || shadow === 'none') return null;
    return getShadowStyle(`${shadow}Shadow`);
}
export const sizes = [
    'unset',
    'full'
];
export function widthAtom(width) {
    if (!width || width === 'unset') return null;
    return getSizeStyle(`${width}Width`);
}
export function heightAtom(height) {
    if (!height || height === 'unset') return null;
    return getSizeStyle(`${height}Height`);
}
export const minSizes = [
    '0',
    'minTouchableArea'
];
export function minWidthAtom(minWidth) {
    switch(minWidth){
        case '0':
            return getSizeStyle(`minWidth0`);
        case 'minTouchableArea':
            return getSizeStyle(`minWidthMinTouchableArea`);
        default:
            return null;
    }
}
export function minHeightAtom(minHeight) {
    switch(minHeight){
        case '0':
            return getSizeStyle(`minHeight0`);
        case 'minTouchableArea':
            return getSizeStyle(`minHeightMinTouchableArea`);
        default:
            return null;
    }
}
export const getPaddingClassNames = (padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd)=>[
        (padding || paddingX || paddingY || paddingTop || paddingBottom || paddingStart || paddingEnd) && paddingStyles.hasPadding
    ];
const paddingPropertyMap = {
    default: paddingProperties.padding,
    smallUp: paddingProperties.smallUpPadding,
    mediumUp: paddingProperties.mediumUpPadding,
    largeUp: paddingProperties.largeUpPadding,
    xLargeUp: paddingProperties.xLargeUpPadding
};
const paddingXPropertyMap = {
    default: paddingProperties.paddingX,
    smallUp: paddingProperties.smallUpPaddingX,
    mediumUp: paddingProperties.mediumUpPaddingX,
    largeUp: paddingProperties.largeUpPaddingX,
    xLargeUp: paddingProperties.xLargeUpPaddingX
};
const paddingYPropertyMap = {
    default: paddingProperties.paddingY,
    smallUp: paddingProperties.smallUpPaddingY,
    mediumUp: paddingProperties.mediumUpPaddingY,
    largeUp: paddingProperties.largeUpPaddingY,
    xLargeUp: paddingProperties.xLargeUpPaddingY
};
const paddingTopPropertyMap = {
    default: paddingProperties.paddingTop,
    smallUp: paddingProperties.smallUpPaddingTop,
    mediumUp: paddingProperties.mediumUpPaddingTop,
    largeUp: paddingProperties.largeUpPaddingTop,
    xLargeUp: paddingProperties.xLargeUpPaddingTop
};
const paddingBottomPropertyMap = {
    default: paddingProperties.paddingBottom,
    smallUp: paddingProperties.smallUpPaddingBottom,
    mediumUp: paddingProperties.mediumUpPaddingBottom,
    largeUp: paddingProperties.largeUpPaddingBottom,
    xLargeUp: paddingProperties.xLargeUpPaddingBottom
};
const paddingStartPropertyMap = {
    default: paddingProperties.paddingStart,
    smallUp: paddingProperties.smallUpPaddingStart,
    mediumUp: paddingProperties.mediumUpPaddingStart,
    largeUp: paddingProperties.largeUpPaddingStart,
    xLargeUp: paddingProperties.xLargeUpPaddingStart
};
const paddingEndPropertyMap = {
    default: paddingProperties.paddingEnd,
    smallUp: paddingProperties.smallUpPaddingEnd,
    mediumUp: paddingProperties.mediumUpPaddingEnd,
    largeUp: paddingProperties.largeUpPaddingEnd,
    xLargeUp: paddingProperties.xLargeUpPaddingEnd
};
export const getPaddingStyles = (padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd)=>({
        ...(padding && generateStyle(paddingPropertyMap, padding, getSpaceValue)),
        ...(paddingX && generateStyle(paddingXPropertyMap, paddingX, getSpaceValue)),
        ...(paddingY && generateStyle(paddingYPropertyMap, paddingY, getSpaceValue)),
        ...(paddingTop && generateStyle(paddingTopPropertyMap, paddingTop, getSpaceValue)),
        ...(paddingBottom && generateStyle(paddingBottomPropertyMap, paddingBottom, getSpaceValue)),
        ...(paddingStart && generateStyle(paddingStartPropertyMap, paddingStart, getSpaceValue)),
        ...(paddingEnd && generateStyle(paddingEndPropertyMap, paddingEnd, getSpaceValue))
    });
export const getFlexDirectionClassNames = (direction)=>[
        direction && flexStyles.hasFlexDirection
    ];
export const flexDirections = [
    'row',
    'column',
    'row-reverse'
];
const flexDirectionPropertyMap = {
    default: flexProperties.flexDirection,
    smallUp: flexProperties.smallUpFlexDirection,
    mediumUp: flexProperties.mediumUpFlexDirection,
    largeUp: flexProperties.largeUpFlexDirection,
    xLargeUp: flexProperties.xLargeUpFlexDirection
};
export const getFlexDirectionStyles = (flexDirection)=>({
        ...(flexDirection && generateStyle(flexDirectionPropertyMap, flexDirection))
    });
export const flexWraps = [
    'noWrap',
    'wrap'
];
export function flexWrapAtom(flexWrap) {
    switch(flexWrap){
        case undefined:
            return;
        case 'noWrap':
            return flexStyles.noWrap;
        case 'wrap':
            return flexStyles.wrap;
        default:
            throw new UnreachableError(flexWrap);
    }
}
export const flexItemBehaviors = [
    'initial',
    'auto',
    'none'
];
export function getFlexItemBehaviorClassNames(flex) {
    switch(flex){
        case undefined:
            return;
        case 'initial':
            return flexStyles.flexItemInitial;
        case 'auto':
            return flexStyles.flexItemAuto;
        case 'none':
            return flexStyles.flexItemNone;
        default:
            throw new UnreachableError(flex);
    }
}
export const justifyContents = [
    'normal',
    'center',
    'start',
    'end',
    'spaceBetween'
];
export function justifyContentAtom(justifyContent, display) {
    if (!justifyContent) return null;
    if (display === 'flex' && (justifyContent === 'start' || justifyContent === 'end'))
    return getAlignmentStyle(`${justifyContent}FlexJustifyContent`);
    return getAlignmentStyle(`${justifyContent}JustifyContent`);
}
export const alignItems = [
    'stretch',
    'center',
    'start',
    'end'
];
export function alignItemsAtom(alignItems, display) {
    if (!alignItems) return null;
    if (display === 'flex' && (alignItems === 'start' || alignItems === 'end'))
    return getAlignmentStyle(`${alignItems}FlexAlignItems`);
    return getAlignmentStyle(`${alignItems}AlignItems`);
}
export const alignSelves = [
    'stretch',
    'center',
    'start',
    'end'
];
export function alignSelfAtom(parentType, alignSelf) {
    if (!alignSelf) return null;
    if (parentType === 'flex' && (alignSelf === 'start' || alignSelf === 'end'))
    return getAlignmentStyle(`${alignSelf}FlexAlignSelf`);
    return getAlignmentStyle(`${alignSelf}AlignSelf`);
}
export const positions = [
    'static',
    'relative',
    'absolute',
    'sticky'
];
export function positionAtom(position) {
    if (!position || position === 'static') return null;
    return getPositionStyle(`${position}Position`);
}
export const positionInsets = [
    '0'
];
export function positionInsetAtom(inset) {
    if (!inset) return null;
    return getPositionStyle(`inset${inset}`);
}
export function positionStartAtom(inset) {
    if (!inset) return null;
    return getPositionStyle(`start${inset}`);
}
export function positionEndAtom(inset) {
    if (!inset) return null;
    return getPositionStyle(`end${inset}`);
}
export function positionTopAtom(inset) {
    if (!inset) return null;
    return getPositionStyle(`top${inset}`);
}
export function positionBottomAtom(inset) {
    if (!inset) return null;
    return getPositionStyle(`bottom${inset}`);
}
