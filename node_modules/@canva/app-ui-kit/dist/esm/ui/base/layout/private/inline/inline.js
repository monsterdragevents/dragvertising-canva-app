import { jsx as _jsx } from "react/jsx-runtime";
import classNames from 'classnames';
import { $mobx, toJS } from 'mobx';
import * as React from 'react';
import { commonPropsToDOMProps } from '../../../box/common_props/common_props';
import { getSpaceValue } from '../../../metrics/metrics';
import { generateStyle } from '../../../responsive/responsive';
import styles, { customProperties } from './inline.css';
export const alignXs = [
    'start',
    'center',
    'end',
    'spaceBetween'
];
export const alignYs = [
    'start',
    'center',
    'end',
    'stretch'
];
export const breakpoints = [
    'small',
    'medium',
    'large',
    'xLarge'
];
const spacingPropertyMap = {
    default: customProperties.spacing,
    smallUp: customProperties.smallUpSpacing,
    mediumUp: customProperties.mediumUpSpacing,
    largeUp: customProperties.largeUpSpacing,
    xLargeUp: customProperties.xLargeUpSpacing
};
const alignPropertyMap = {
    default: customProperties.align,
    smallUp: customProperties.smallUpAlign,
    mediumUp: customProperties.mediumUpAlign,
    largeUp: customProperties.largeUpAlign,
    xLargeUp: customProperties.xLargeUpAlign
};
const alignYPropertyMap = {
    default: customProperties.alignY,
    smallUp: customProperties.smallUpAlignY,
    mediumUp: customProperties.mediumUpAlignY,
    largeUp: customProperties.largeUpAlignY,
    xLargeUp: customProperties.xLargeUpAlignY
};
const getAlignValue = (align)=>align !== 'spaceBetween' ? align : 'space-between';
const getInlineAlignYValue = (alignY)=>alignY === 'start' || alignY === 'end' ? `flex-${alignY}` : alignY;
export const Inline = React.forwardRef(
    ({ children, spacing, align, alignY, collapseBelow, collapsed, tagName: TagName = 'div', ...rest }, ref)=>{
        const isList = TagName === 'ul' || TagName === 'ol';
        const isPhrasingContent = TagName === 'span';
        const ContainerTagName = isPhrasingContent ? 'span' : 'div';
        const childTagName = isList ? 'li' : isPhrasingContent ? 'span' : 'div';
        return (_jsx(ContainerTagName, {
                className: styles.container,
                ref: ref,
                children: _jsx(TagName, {
                    className: classNames(styles.inline, collapseBelow && collapseBelowClassNames[collapseBelow], collapsed && styles.collapsed),
                    style: {
                        ...(spacing && generateStyle(spacingPropertyMap, spacing, getSpaceValue)),
                        ...(align && generateStyle(alignPropertyMap, align, getAlignValue)),
                        ...(alignY && generateStyle(alignYPropertyMap, alignY, getInlineAlignYValue))
                    },
                    ...commonPropsToDOMProps(rest),
                    children: wrapOrCloneChildren(children, childTagName)
                })
            }));
    }
);
Inline.displayName = 'Inline';
function wrapOrCloneChildren(children, TagName) {
    return React.Children.map(flattenChildren(children), (child)=>{
        if (!child) return null;
        if (TagName === 'li' && React.isValidElement(child) && child.type === 'li') return React.cloneElement(child, {
            className: classNames(child.props.className, styles.element)
        });
        return _jsx(TagName, {
            className: styles.element,
            children: child
        });
    });
}
function isFragment(node) {
    return React.isValidElement(node) && node.type === React.Fragment;
}
function flattenChildren(children, depth = 0, keys = []) {
    const childrenWithoutObservability = Array.isArray(children) ? children.map((node)=>{
        var _node_$mobx;
        return (node === null || node === void 0 ? void 0 : (_node_$mobx = node[$mobx]) === null || _node_$mobx === void 0 ? void 0 : _node_$mobx.proxy_) != null ? toJS(node) : node;
    }) : children;
    return React.Children.toArray(childrenWithoutObservability).reduce((acc, node, nodeIndex)=>{
        if (isFragment(node)) acc.push(...flattenChildren(node.props.children, depth + 1, keys.concat(node.key || nodeIndex)));
        else {
            if (React.isValidElement(node)) acc.push(React.cloneElement(node, {
                key: keys.concat(String(node.key)).join('.')
            }));
            else if (typeof node === 'string' || typeof node === 'number') acc.push(node);
        }
        return acc;
    }, []);
}
const collapseBelowClassNames = {
    ['small']: styles.collapseBelowSmall,
    ['medium']: styles.collapseBelowMedium,
    ['large']: styles.collapseBelowLarge,
    ['xLarge']: styles.collapseBelowXLarge
};
