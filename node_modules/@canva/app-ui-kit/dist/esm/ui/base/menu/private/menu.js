import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { Preconditions } from '../../../../base/preconditions';
import classNames from 'classnames';
import { observer } from 'mobx-react-lite';
import * as React from 'react';
import { accessModeState } from '../../a11y/access_mode_state/access_mode_state';
import { Box } from '../../box/box';
import { BaseAnchor, BaseButton } from '../../button/base_button/base_button';
import { Button } from '../../button/button';
import { useControllableValue } from '../../controllable_value/controllable_value';
import { Divider } from '../../divider/divider';
import { ChevronDownIcon } from '../../icons/chevron_down/icon';
import { ChevronRightIcon } from '../../icons/chevron_right/icon';
import { Column, Columns, Rows, Spacer } from '../../layout/layout';
import { useIsTruncated } from '../../typography/truncated/truncated';
import { InheritColor, Text } from '../../typography/typography';
import styles, { getStyle } from './menu.css';
import { MenuMessages } from './menu.messages';
const MenuContext = React.createContext(undefined);
export const ITEM_HEIGHT_MULTIPIER = 5;
export const DIVIDER_HEIGHT_MULTIPIER = 2;
export const TEXT_DIVIDER_HEIGHT_MULTIPIER = 4;
const getMenuSpaceStyle = (spacing, variant = 'regular', direction = 'vertical')=>{
    const menuSpace = spacing || (direction === 'horizontal' ? '1u' : variant === 'regular' ? '0' : '0.5u');
    switch(menuSpace){
        case '0.5u':
            return getStyle('spacing050');
        case '1u':
            return getStyle('spacing1');
        default:
            return;
    }
};
export const Menu = React.forwardRef(function Menu(props, ref) {
    const navigationRole = props.role === 'navigation';
    const [hasToggleMenu, setHasToggleMenu] = React.useState(false);
    const menuClassName = classNames(styles.menu, !navigationRole && props.className, getMenuSpaceStyle(props.spacing, props.variant, props.direction), {
        [styles.rounded]: props.variant === 'rounded',
        [styles.bleedX]: !!props.bleedX,
        [styles.horizontal]: props.role !== 'listbox' && props.direction === 'horizontal',
        [styles.hasToggleMenu]: hasToggleMenu
    });
    var _props_tagName;
    const content = _jsx(Box, {
        id: props.id,
        ariaActiveDescendant: props.ariaActiveDescendant,
        ariaMultiSelectable: props.ariaMultiSelectable,
        ariaLabel: props.ariaLabel,
        ariaLabelledBy: props.ariaLabelledBy,
        tagName: (_props_tagName = props.tagName) !== null && _props_tagName !== void 0 ? _props_tagName : 'ul',
        role: props.role === 'navigation' ? 'list' : props.role,
        ref: ref,
        className: menuClassName,
        children: props.children
    });
    const maybeWrappedContent = navigationRole ? _jsx("nav", {
        className: navigationRole && props.className,
        children: content
    }) : content;
    const context = React.useMemo(()=>({
            menuRole: props.role,
            menuDirection: props.role !== 'listbox' ? props.direction : undefined,
            menuVariant: props.variant,
            menuSpacing: props.spacing,
            registerToggleMenu: ()=>setHasToggleMenu(true)
        }), [
        props.role,
        props.direction,
        props.variant,
        props.spacing
    ]);
    return _jsx(MenuContext.Provider, {
        value: context,
        children: maybeWrappedContent
    });
});
function getMenuItemRoles(menuRole) {
    switch(menuRole){
        case 'menu':
        case 'menubar':
            return {
                boxRole: 'none',
                buttonRole: 'menuitem'
            };
        case 'listbox':
        case 'group':
            return {
                boxRole: 'option',
                buttonRole: undefined
            };
        default:
            return {
                boxRole: undefined,
                buttonRole: undefined
            };
    }
}
export const MenuItem = React.memo(
    function MenuItem({ id, buttonId, children, className, active, selected, pressed, disabled, disclosure, draggable, onFocus, onBlur, onMouseEnter, onMouseLeave, tabIndex, start, end, label, description, lineClamp, buttonRef, tooltipLabel, tooltipDisabled, tooltipLineClamp, tooltipPlacement, tooltipShortcut, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaHasPopup, ariaControls, ariaSelected, ariaCurrent, href, target, onClick, onContextMenu }) {
        const context = Preconditions.checkExists(React.useContext(MenuContext), 'MenuItem should not be used outside of a Menu');
        const { boxRole, buttonRole } = getMenuItemRoles(context.menuRole);
        return _jsx(Box, {
            tagName: "li",
            id: id,
            role: boxRole,
            className: styles.menuItem,
            ariaDisabled: disabled,
            ariaSelected: ariaSelected,
            children: _jsx(MenuItemButton, {
                id: buttonId,
                role: buttonRole,
                tabIndex: tabIndex,
                buttonRef: buttonRef,
                className: className,
                href: href,
                target: target,
                onClick: onClick,
                start: start,
                end: end,
                label: label,
                description: description,
                lineClamp: lineClamp,
                alignment: context.menuDirection === 'horizontal' ? 'center' : 'start',
                active: active,
                selected: selected,
                pressed: pressed,
                disabled: disabled,
                disclosure: disclosure,
                draggable: draggable,
                onFocus: onFocus,
                onBlur: onBlur,
                onMouseEnter: onMouseEnter,
                onMouseLeave: onMouseLeave,
                onContextMenu: onContextMenu,
                tooltipLabel: tooltipLabel,
                tooltipDisabled: tooltipDisabled,
                tooltipLineClamp: tooltipLineClamp,
                tooltipPlacement: tooltipPlacement,
                tooltipShortcut: tooltipShortcut,
                ariaLabel: ariaLabel,
                ariaLabelledBy: ariaLabelledBy,
                ariaDescribedBy: ariaDescribedBy,
                ariaHasPopup: ariaHasPopup,
                ariaControls: ariaControls,
                ariaCurrent: ariaCurrent,
                children: children
            })
        });
    }
);
const Clickable = React.forwardRef((props, ref)=>{
    return props.href ? _jsx(BaseAnchor, {
        ref: ref,
        ...props
    }) : _jsx(BaseButton, {
        ref: ref,
        ...props
    });
});
export const MenuItemButton = observer(function MenuItemButton({ id, role, alignment, children, className, active, selected, pressed, disabled, draggable, disclosure, onClick, onFocus, onBlur, onMouseEnter, onMouseLeave, onContextMenu, tabIndex, start, end, label, description, lineClamp, buttonRef, tooltipLabel: tooltipLabelProp, tooltipDisabled, tooltipLineClamp, tooltipPlacement, tooltipShortcut, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaHasPopup, ariaControls, ariaSelected, ariaCurrent, href, target }) {
    const childrenIsTextLike = typeof children === 'string' || typeof children === 'number';
    const textContent = label !== null && label !== void 0 ? label : childrenIsTextLike ? children.toString() : undefined;
    const { isTruncated, ref: isTruncatedRef } = useIsTruncated(textContent);
    const tooltipLabel = tooltipLabelProp !== null && tooltipLabelProp !== void 0 ? tooltipLabelProp : isTruncated ? textContent : undefined;
    const hideOutline = accessModeState.isMouseMode;
    const labelId = React.useId();
    const descriptionId = React.useId();
    const buttonClassName = classNames(styles.menuItemButton, {
        [styles.hideOutline]: hideOutline
    }, className);
    const contentNodes = [];
    if (children != null && !childrenIsTextLike) contentNodes.push(children);
    else {
        textContent !== undefined && contentNodes.push(_jsx(Text, {
            ref: textContent != null ? isTruncatedRef : undefined,
            id: label ? labelId : undefined,
            tagName: "span",
            tone: InheritColor,
            alignment: alignment,
            lineClamp: lineClamp,
            className: styles.menuItemButtonLabel,
            children: textContent
        }, contentNodes.length));
        label && description && contentNodes.push(_jsx(Text, {
            id: descriptionId,
            tagName: "span",
            size: "small",
            tone: "tertiary",
            alignment: alignment,
            children: description
        }, contentNodes.length));
    }
    const content = contentNodes.length > 1 ? _jsx(Rows, {
        tagName: "span",
        spacing: "0",
        children: contentNodes
    }) : contentNodes;
    const setRef = React.useCallback((handle)=>{
        if (buttonRef == null) return;
        var _handle_dangerouslyGetElement;
        const element = (_handle_dangerouslyGetElement = handle === null || handle === void 0 ? void 0 : handle.dangerouslyGetElement()) !== null && _handle_dangerouslyGetElement !== void 0 ? _handle_dangerouslyGetElement : null;
        if (typeof buttonRef === 'function') buttonRef(element);
        else buttonRef.current = element;
    }, [
        buttonRef
    ]);
    return _jsx(Clickable, {
        id: id,
        role: role,
        tabIndex: tabIndex,
        ref: setRef,
        className: buttonClassName,
        active: active,
        selected: active !== null && active !== void 0 ? active : selected,
        pressed: pressed,
        disabled: disabled,
        draggable: draggable,
        disclosure: disclosure,
        onClick: onClick,
        onFocus: onFocus,
        onBlur: onBlur,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onContextMenu: onContextMenu,
        tooltipLabel: tooltipLabel,
        tooltipDisabled: tooltipDisabled,
        tooltipLineClamp: tooltipLineClamp,
        tooltipPlacement: tooltipPlacement,
        tooltipShortcut: tooltipShortcut,
        ariaLabel: ariaLabel,
        ariaLabelledBy: label ? labelId : ariaLabelledBy,
        ariaDescribedBy: description ? descriptionId : ariaDescribedBy,
        ariaHasPopup: ariaHasPopup,
        ariaControls: ariaControls,
        ariaCurrent: ariaCurrent,
        href: href,
        target: target,
        width: "full",
        alignItems: "center",
        tone: "tertiary",
        children: start || end ? _jsxs(Columns, {
            tagName: "span",
            alignY: "center",
            spacing: "1u",
            children: [
                start ? renderDecorator(typeof start === 'function' ? start() : start) : null,
                _jsx(Column, {
                    tagName: "span",
                    children: content
                }),
                end ? renderDecorator(typeof end === 'function' ? end() : end) : null
            ]
        }) : content
    });
});
export const renderDecorator = (decorator)=>React.isValidElement(decorator) && decorator.type === React.Fragment ? _jsx(_Fragment, {
        children: React.Children.map(decorator.props.children, (child)=>child && renderDecorator(child))
    }) : _jsx(Column, {
        tagName: "span",
        width: "content",
        children: decorator
    });
export const MenuDivider = React.memo(function MenuDivider({ id, children }) {
    const context = Preconditions.checkExists(React.useContext(MenuContext), 'MenuDivider should not be used outside of a Menu');
    const dividerDirection = context.menuDirection === 'horizontal' ? 'vertical' : 'horizontal';
    const showChildren = context.menuDirection !== 'horizontal' && children;
    return _jsxs("li", {
        role: "none",
        id: id,
        children: [
            _jsx("div", {
                className: styles.menuDivider,
                children: _jsx(Divider, {
                    direction: dividerDirection
                })
            }),
            showChildren && _jsx(Text, {
                size: "small",
                weight: "bold",
                tagName: "div",
                tone: "secondary",
                className: styles.menuDividerText,
                children: children
            })
        ]
    });
});
export const ToggleMenu = React.forwardRef(
    function ToggleMenu({ id, menuId: menuIdProp, labelId: labelIdProp, label, labelNode, disabled, draggable, start, end, active, selected, buttonRef, tooltipLabel, tooltipPlacement, href, onClick, onToggleClick, onContextMenu, toggleLabel, defaultExpanded, expanded: expandedProp, buttonClassName, ...props }, ref) {
        const [expanded, setExpanded] = useControllableValue({
            value: expandedProp,
            defaultValue: defaultExpanded,
            onChange: onToggleClick
        });
        const toggleExpanded = React.useCallback(()=>setExpanded(!expanded), [
            expanded,
            setExpanded
        ]);
        const context = React.useContext(MenuContext);
        React.useEffect(()=>{
            context === null || context === void 0 ? void 0 : context.registerToggleMenu();
        }, [
            context
        ]);
        const Icon = expanded ? ChevronDownIcon : ChevronRightIcon;
        const generatedMenuId = React.useId();
        const menuId = menuIdProp !== null && menuIdProp !== void 0 ? menuIdProp : generatedMenuId;
        const generatedLabelId = React.useId();
        const labelId = labelIdProp !== null && labelIdProp !== void 0 ? labelIdProp : generatedLabelId;
        const toggleButtonProps = {
            onClick: toggleExpanded,
            disclosure: true,
            ariaControls: expanded ? menuId : undefined,
            open: expanded,
            disableActiveStyle: true
        };
        const showSeparateToggleButton = href || onClick;
        const menuItemClickProps = showSeparateToggleButton ? {
            href,
            onClick
        } : {
            ...toggleButtonProps
        };
        return _jsxs(Box, {
            ref: ref,
            tagName: context ? 'li' : 'div',
            id: id,
            className: styles.toggleMenuBox,
            children: [
                _jsx(MenuItemButton, {
                    id: labelId,
                    className: buttonClassName,
                    active: active,
                    selected: selected,
                    disabled: disabled,
                    start: _jsxs(_Fragment, {
                        children: [
                            showSeparateToggleButton ? _jsx(Spacer, {
                                size: "1u",
                                direction: "horizontal"
                            }) : _jsxs(Box, {
                                tagName: "span",
                                className: styles.toggleMenuIconBox,
                                children: [
                                    _jsx(Spacer, {
                                        size: "1u",
                                        direction: "horizontal"
                                    }),
                                    _jsx(Icon, {
                                        size: "small",
                                        className: styles.toggleMenuIcon
                                    })
                                ]
                            }),
                            typeof start === 'function' ? start() : start
                        ]
                    }),
                    end: end,
                    lineClamp: 1,
                    buttonRef: buttonRef,
                    onContextMenu: onContextMenu,
                    tooltipLabel: tooltipLabel,
                    tooltipPlacement: tooltipPlacement,
                    ariaLabel: labelNode ? label : undefined,
                    draggable: draggable,
                    ...menuItemClickProps,
                    children: labelNode || label
                }),
                showSeparateToggleButton && _jsx(Button, {
                    className: styles.toggleButton,
                    variant: "tertiary",
                    iconSize: "small",
                    icon: Icon,
                    ariaLabel: (toggleLabel !== null && toggleLabel !== void 0 ? toggleLabel : expanded) ? MenuMessages.collapseMenu(label) : MenuMessages.expandMenu(label),
                    disabled: disabled,
                    ...toggleButtonProps
                }),
                expanded && props.children && _jsx(Menu, {
                    id: menuId,
                    ariaLabelledBy: labelId,
                    variant: context === null || context === void 0 ? void 0 : context.menuVariant,
                    spacing: context === null || context === void 0 ? void 0 : context.menuSpacing,
                    ...props
                })
            ]
        });
    }
);
