import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { UnreachableError } from '../../../../base/preconditions';
import classNames from 'classnames';
import * as React from 'react';
import Transition, { ENTERED, ENTERING } from 'react-transition-group/Transition';
import { useIsMouseAccessMode } from '../../a11y/access_mode_state/access_mode_state';
import { useIdentifiers } from '../../a11y/identifier/identifier';
import { useIsMouseInput } from '../../a11y/pointer_input_state/pointer_input_state';
import { ScreenReaderContent } from '../../a11y/screen_reader_content/screen_reader_content';
import { Box } from '../../box/box';
import { LayerLevel } from '../../layer/layer';
import { Rows } from '../../layout/layout';
import { baseUnit } from '../../metrics/metrics';
import { PixelDensityResponsiveImage } from '../../responsive_image/responsive_image';
import { Shortcut } from '../../shortcut/shortcut';
import { Pin } from '../../surface/pin/pin';
import { ThemeBoundary } from '../../theme/theme';
import { Text } from '../../typography/typography';
import styles from './internal_tooltip.css';
function isRenderTrigger(children) {
    return typeof children === 'function';
}
const MOTION_DURATION_MS = 150;
const FADE_IN_DELAY = 150;
const FADE_OUT_DELAY = 0;
export function InternalTooltip(props) {
    const { label, description, disabled = false, mode } = props;
    const timer = React.useRef(undefined);
    const [open, setOpen] = React.useState(false);
    const openRef = React.useRef(false);
    const withDelay = React.useCallback((cb, delay)=>{
        window.clearTimeout(timer.current);
        if (!delay) return Promise.resolve(cb());
        return new Promise((resolve)=>{
            timer.current = window.setTimeout(()=>{
                cb();
                resolve();
            }, delay);
        });
    }, []);
    const showTooltip = React.useCallback((delay = FADE_IN_DELAY)=>{
        return withDelay(()=>setOpen(true), delay);
    }, [
        withDelay
    ]);
    const hideTooltip = React.useCallback(()=>{
        return withDelay(()=>setOpen(false), FADE_OUT_DELAY);
    }, [
        withDelay
    ]);
    const onDocumentKeydown = React.useCallback((e)=>{
        if (e.key === 'Escape' && openRef.current) {
            e.stopPropagation();
            hideTooltip();
        }
    }, [
        hideTooltip
    ]);
    React.useEffect(()=>{
        document.addEventListener('keydown', onDocumentKeydown, {
            capture: true
        });
        return ()=>{
            document.removeEventListener('keydown', onDocumentKeydown, {
                capture: true
            });
        };
    }, [
        onDocumentKeydown
    ]);
    React.useEffect(()=>{
        openRef.current = open;
    }, [
        open
    ]);
    React.useEffect(()=>{
        if (disabled) hideTooltip();
    }, [
        disabled,
        hideTooltip
    ]);
    const screenReaderLabel = description != null ? `${label}: ${description}` : label;
    if (mode === 'toggletip') return _jsx(BaseToggleTip, {
        ...props,
        hideTooltip: hideTooltip,
        open: open,
        screenReaderLabel: screenReaderLabel,
        showTooltip: showTooltip,
        disabled: disabled
    });
    return _jsx(BaseTooltip, {
        ...props,
        hideTooltip: hideTooltip,
        open: open,
        screenReaderLabel: screenReaderLabel,
        showTooltip: showTooltip,
        disabled: disabled
    });
}
function BaseTooltip({ children, closeOnClick = true, disabled, forwardedRef, hideTooltip, open, screenReaderLabel, showTooltip, ...props }) {
    const [tooltipId] = useIdentifiers(1);
    const isMouseInput = useIsMouseInput();
    const isMouseAccessMode = useIsMouseAccessMode();
    const showTooltipIfMouseInput = React.useCallback(()=>{
        if (disabled || !isMouseInput) return;
        showTooltip();
    }, [
        disabled,
        showTooltip,
        isMouseInput
    ]);
    const showTooltipIfKeyboardMode = React.useCallback(()=>{
        if (disabled || isMouseAccessMode) return;
        showTooltip(0);
    }, [
        disabled,
        showTooltip,
        isMouseAccessMode
    ]);
    const renderedChildren = React.useMemo(()=>{
        if (isRenderTrigger(children)) return children({
            onBlur: hideTooltip,
            onFocus: showTooltipIfKeyboardMode,
            onMouseDown: closeOnClick ? hideTooltip : undefined,
            onMouseEnter: showTooltipIfMouseInput,
            onMouseLeave: hideTooltip,
            tabIndex: 0,
            tooltipId
        });
    }, [
        children,
        closeOnClick,
        hideTooltip,
        showTooltipIfKeyboardMode,
        showTooltipIfMouseInput,
        tooltipId
    ]);
    if (isRenderTrigger(children)) return (_jsxs(_Fragment, {
            children: [
                _jsx(StatelessTooltip, {
                    ...props,
                    open: open,
                    children: renderedChildren
                }),
                _jsx(ScreenReaderContent, {
                    asLabelTextOnly: true,
                    id: tooltipId,
                    children: screenReaderLabel
                })
            ]
        }));
    return closeOnClick ?
    _jsx("div", {
        onMouseEnter: showTooltipIfMouseInput,
        onMouseLeave: hideTooltip,
        onMouseDown: hideTooltip,
        ref: forwardedRef,
        className: props.expandTooltipWrapper ? styles.expand : undefined,
        children: _jsx(StatelessTooltip, {
            ...props,
            children: children,
            open: open
        })
    }) : _jsx("div", {
        onMouseEnter: showTooltipIfMouseInput,
        onMouseLeave: hideTooltip,
        ref: forwardedRef,
        className: props.expandTooltipWrapper ? styles.expand : undefined,
        children: _jsx(StatelessTooltip, {
            ...props,
            children: children,
            open: open
        })
    });
}
function BaseToggleTip({ open, hideTooltip, showTooltip, children, screenReaderLabel, ...props }) {
    const [renderScreenReaderLabel, setRenderScreenReaderLabel] = React.useState(false);
    const showToggletip = React.useCallback(async (e)=>{
        e.currentTarget.focus({
            preventScroll: true
        });
        setRenderScreenReaderLabel(false);
        await showTooltip(0);
        setTimeout(()=>setRenderScreenReaderLabel(true), 50);
    }, [
        showTooltip,
        setRenderScreenReaderLabel
    ]);
    const renderedChildren = React.useMemo(()=>{
        return children({
            onClick: showToggletip,
            onBlur: hideTooltip
        });
    }, [
        children,
        hideTooltip,
        showToggletip
    ]);
    return (_jsxs(_Fragment, {
            children: [
                _jsx(StatelessTooltip, {
                    ...props,
                    open: open,
                    children: renderedChildren
                }),
                _jsx(ScreenReaderContent, {
                    role: "status",
                    ariaRelevant: "all",
                    children: renderScreenReaderLabel ? screenReaderLabel : ''
                })
            ]
        }));
}
export function TooltipContent(props) {
    const { id, label, description, align = 'center', shortcut, lineClamp, thumbnail, mode } = props;
    const shortcutElement = shortcut ? _jsx(Shortcut, {
        className: styles.shortcut,
        combination: shortcut,
        size: "small"
    }) : null;
    const lines = lineClamp ? [
        label
    ] : label.trim().split('\n');
    const labelContent = lines.length === 1 ? _jsx(Text, {
        size: "small",
        weight: "bold",
        tagName: "div",
        lineClamp: lineClamp,
        tone: "primary",
        className: styles.label,
        alignment: align,
        id: id,
        children: label
    }) : _jsx("div", {
        className: styles.label,
        id: id,
        children: lines.map((line, i)=>_jsx(Text, {
                size: "small",
                alignment: align,
                tone: "primary",
                children: line
            }, i))
    });
    const descriptionContent = description != null && _jsx(Text, {
        size: "small",
        tone: "secondary",
        alignment: align,
        className: styles.description,
        children: description
    });
    const thumbnailContent = thumbnail != null && _jsx("div", {
        className: styles.thumbnail,
        children: typeof thumbnail === 'string' ? _jsx("img", {
            src: thumbnail,
            alt: ""
        }) : _jsx(PixelDensityResponsiveImage, {
            sources: thumbnail,
            alt: ""
        })
    });
    const ariaProps = mode === 'toggletip' ? {} : {
        ['role']: 'tooltip'
    };
    return _jsx(ThemeBoundary, {
        light: "dark",
        dark: "dark",
        classicLight: "dark",
        classicDark: "dark",
        children: ({ className })=>_jsx(TooltipBox, {
                className: className,
                display: "flex",
                flexDirection: "row",
                ...ariaProps,
                children: _jsxs(Rows, {
                    spacing: "0",
                    align: align,
                    children: [
                        thumbnailContent,
                        labelContent,
                        descriptionContent,
                        shortcutElement
                    ]
                })
            })
    });
}
export function TooltipBox({ className, children, ...props }) {
    return _jsx(Box, {
        className: classNames(className, styles.tooltip),
        background: "surface",
        borderRadius: "element",
        paddingX: "1u",
        paddingY: "0.5u",
        ...props,
        children: children
    });
}
export function TooltipArrow({ inset = true }) {
    const paths = _jsxs(_Fragment, {
        children: [
            _jsx("path", {
                d: "M15 16L10.3972 11.67335C9.04995 10.40695 6.95006 10.40695 5.60282 11.67335L1 16L15 16Z",
                className: styles.arrowInner
            }),
            _jsx("path", {
                d: "M15 16L10.3972 11.67335C9.04995 10.40695 6.95006 10.40695 5.60282 11.67335L1 16L2.46004 16L6.28773 12.40198C7.25004 11.4974 8.74996 11.4974 9.71228 12.40198L13.54 16L15 16Z",
                className: styles.arrowOutline
            })
        ]
    });
    return _jsx("svg", {
        width: "16",
        height: "16",
        viewBox: "0 0 16 16",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        className: styles.arrow,
        children: inset ? _jsx("g", {
            transform: "translate(0, -6)",
            children: paths
        }) : paths
    });
}
export function StatelessTooltip({ children, placement = 'bottom', open, arrow = true, refObj, direction, ...contentProps }) {
    return _jsx(TransitionPin, {
        open: open,
        blockInsidePointerEvents: true,
        reference: refObj !== null && refObj !== void 0 ? refObj : children,
        placement: getPinPlacement(placement, direction),
        offset: {
            main: baseUnit,
            cross: 0
        },
        level: LayerLevel.TOOLTIPS,
        children: ({ style, childRef, setArrow })=>_jsxs("div", {
                ref: childRef,
                style: style,
                children: [
                    _jsx(TooltipContent, {
                        ...contentProps
                    }),
                    arrow ? _jsx("div", {
                        ref: setArrow,
                        className: styles.arrowWrapper,
                        children: _jsx(TooltipArrow, {
                            inset: false
                        })
                    }) : null
                ]
            })
    });
}
const PIN_PLACEMENT_MAP = {
    ['left-start']: {
        ltr: 'start-top',
        rtl: 'end-top'
    },
    ['left']: {
        ltr: 'start-center',
        rtl: 'end-center'
    },
    ['left-end']: {
        ltr: 'start-bottom',
        rtl: 'end-bottom'
    },
    ['right-start']: {
        ltr: 'end-top',
        rtl: 'start-top'
    },
    ['right']: {
        ltr: 'end-center',
        rtl: 'start-center'
    },
    ['right-end']: {
        ltr: 'end-bottom',
        rtl: 'start-bottom'
    },
    ['top']: {
        ltr: 'top-center',
        rtl: 'top-center'
    },
    ['bottom']: {
        ltr: 'bottom-center',
        rtl: 'bottom-center'
    }
};
function getPinPlacement(placement, direction) {
    const mapping = PIN_PLACEMENT_MAP[placement];
    switch(direction){
        case undefined:
            return mapping.ltr;
        case 'LTR':
            return {
                placement: mapping.ltr,
                rtlAware: false
            };
        case 'RTL':
            return {
                placement: mapping.rtl,
                rtlAware: false
            };
        default:
            throw new UnreachableError(direction);
    }
}
function TransitionPin({ open, children, ...props }) {
    const [transitionOpen, setTransitionOpen] = React.useState(open);
    const childRef = React.useRef(null);
    return _jsx(Pin, {
        ...props,
        open: open || transitionOpen,
        children: ({ setArrow })=>_jsx(Transition, {
                in: open,
                appear: true,
                timeout: MOTION_DURATION_MS,
                onEnter: ()=>setTransitionOpen(true),
                onExited: ()=>setTransitionOpen(false),
                nodeRef: childRef,
                children: (state)=>children({
                        style: {
                            transition: `opacity ${MOTION_DURATION_MS}ms ease-in-out`,
                            opacity: state === ENTERING || state === ENTERED ? 1 : 0
                        },
                        childRef,
                        setArrow
                    })
            })
    });
}
