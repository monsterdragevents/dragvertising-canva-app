import { jsx as _jsx } from "react/jsx-runtime";
import * as mobx from 'mobx';
import { observer } from 'mobx-react-lite';
import * as React from 'react';
import { baseUnit } from '../../metrics/metrics';
import { InternalTooltip, StatelessTooltip } from '../internal/internal_tooltip';
import { TooltipPresenter } from './tooltip_presenter';
const FADE_OUT_DELAY = 2000;
export const Tooltip = React.forwardRef((props, ref)=>_jsx(InternalTooltip, {
        ...props,
        forwardedRef: ref
    }));
export const TriggeredTooltip = observer((props)=>{
    const [presenter] = React.useState(()=>new TooltipPresenter());
    const { autoclose = true, state, ...rest } = props;
    React.useEffect(()=>{
        const disposer = mobx.autorun(()=>{
            if (autoclose && state.open) presenter.hideTooltip(props, FADE_OUT_DELAY);
        });
        return ()=>disposer();
    }, [
        autoclose,
        state,
        presenter,
        rest,
        props
    ]);
    return _jsx(StatelessTooltip, {
        ...rest,
        open: state.open,
        mode: "tooltip"
    });
});
export const FloatingTooltip = observer((props)=>{
    const refObj = React.useMemo(()=>new FloatingTooltipReferenceObject({
            info: props
        }), [
        props
    ]);
    const [info, setInfo] = React.useState(props);
    const { arrow, open, label, placement = 'right-end', direction, x, y } = props;
    React.useEffect(()=>{
        if (open)
        setInfo({
            label,
            placement,
            direction,
            x,
            y
        });
    }, [
        open,
        label,
        placement,
        direction,
        x,
        y
    ]);
    return _jsx(StatelessTooltip, {
        label: info.label,
        open: open,
        arrow: !!arrow,
        refObj: refObj,
        placement: info.placement,
        direction: info.direction,
        mode: "tooltip"
    });
});
class FloatingTooltipReferenceObject {
    get left() {
        return this.tooltip.info.x - FloatingTooltipReferenceObject.horizontalOffset;
    }
    get top() {
        return this.tooltip.info.y - FloatingTooltipReferenceObject.verticalOffset;
    }
    get width() {
        return 2 * FloatingTooltipReferenceObject.horizontalOffset;
    }
    get height() {
        return 2 * FloatingTooltipReferenceObject.verticalOffset;
    }
    get right() {
        return this.left + this.width;
    }
    get bottom() {
        return this.top + this.height;
    }
    get clientWidth() {
        return this.width;
    }
    get clientHeight() {
        return this.height;
    }
    get x() {
        return this.tooltip.info.x;
    }
    get y() {
        return this.tooltip.info.y;
    }
    toJSON() {
        const { bottom, height, left, right, top, width, x, y } = this;
        return {
            bottom,
            height,
            left,
            right,
            top,
            width,
            x,
            y
        };
    }
    getBoundingClientRect() {
        return this;
    }
    constructor(tooltip){
        this.tooltip = tooltip;
    }
}
FloatingTooltipReferenceObject.horizontalOffset = 3 * baseUnit;
FloatingTooltipReferenceObject.verticalOffset = 8 * baseUnit;
