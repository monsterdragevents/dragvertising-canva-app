import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import classNames from 'classnames';
import { Observer, observer } from 'mobx-react-lite';
import * as React from 'react';
import { accessModeState } from '../../a11y/access_mode_state/access_mode_state';
import { useIsMouseInput } from '../../a11y/pointer_input_state/pointer_input_state';
import styles from './badge_container.css';
const paddingStyleClassMap = {
    ['compact']: styles.compact,
    ['standard']: undefined
};
const transitionClassMap = {
    ['fade']: styles.fxFade,
    ['slide']: styles.fxSlide,
    ['none']: styles.fxAppear
};
export const BadgeContainer = React.forwardRef(
    ({ children, paddingStyle = 'standard', className, ariaLabel, ariaLabelledBy, ariaDescribedBy, onMouseEnter, onMouseLeave, onMouseUp, onMouseDown, role }, ref)=>_jsx(Observer, {
            children: ()=>_jsx("div", {
                    ref: ref,
                    className: classNames(styles.container, styles.hoverTrigger, paddingStyleClassMap[paddingStyle], className, {
                        [styles.focusVisible]: accessModeState.isKeyboardMode
                    }),
                    role: role,
                    "aria-label": ariaLabel,
                    "aria-labelledby": ariaLabelledBy,
                    "aria-describedby": ariaDescribedBy,
                    onMouseEnter: onMouseEnter,
                    onMouseLeave: onMouseLeave,
                    onMouseUp: onMouseUp,
                    onMouseDown: onMouseDown,
                    children: children
                })
        })
);
export function BadgeGroup({ location, visibility = 'always', transition, children, stretch, className }) {
    return _jsx("span", {
        className: classNames(styles.badgeGroup, location && getLocationClasses(location), transition ? transitionClassMap[transition] : styles.defaultFx, {
            [styles.hoverTarget]: visibility === 'on-hover',
            [styles.pinning]: location != null,
            [styles.stretch]: stretch
        }, className),
        children: children
    });
}
export const VisibleOnHover = ({ children, transition, showOnTouchDevice = false })=>{
    const isMouseInput = useIsMouseInput();
    if (!isMouseInput && !showOnTouchDevice) return null;
    return _jsx("span", {
        className: classNames(styles.badgeGroup, transition ? transitionClassMap[transition] : styles.defaultFx, {
            [styles.hoverTarget]: isMouseInput
        }),
        children: children
    });
};
export const SwapOnHover = ({ onHover, children })=>_jsxs("span", {
        className: styles.swapOnHoverWrapper,
        children: [
            _jsx("span", {
                className: styles.hideOnHover,
                children: children
            }),
            _jsx("span", {
                className: styles.showOnHover,
                children: onHover
            })
        ]
    });
function getLocationClasses(location) {
    return {
        [styles.top]: location === 'top-start' || location === 'top-end',
        [styles.bottom]: location === 'bottom-start' || location === 'bottom-end',
        [styles.left]: location === 'top-start' || location === 'bottom-start' || location === 'center-start',
        [styles.right]: location === 'top-end' || location === 'bottom-end' || location === 'center-end',
        [styles.verticalCenter]: location === 'center-start' || location === 'center-end'
    };
}
export const ExtendedBadgeVisibilityTrigger = observer(React.forwardRef(
    ({ children, tagName: TagName = 'div', role, className, onMouseEnter, onMouseLeave, onMouseUp, onMouseDown, ariaLabel, ariaLabelledBy, ariaDescribedBy }, ref)=>{
        return _jsx(TagName, {
            className: classNames(className, styles.hoverTrigger, {
                [styles.focusVisible]: accessModeState.isKeyboardMode
            }),
            onMouseEnter: onMouseEnter,
            onMouseLeave: onMouseLeave,
            onMouseUp: onMouseUp,
            onMouseDown: onMouseDown,
            "aria-label": ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-describedby": ariaDescribedBy,
            role: role,
            ref: ref,
            children: children
        });
    }
));
