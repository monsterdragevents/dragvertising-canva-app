import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import classNames from 'classnames';
import { action, reaction } from 'mobx';
import { observer } from 'mobx-react-lite';
import * as React from 'react';
import { Button } from '../../button/button';
import { createBasicHTMLHandle, useHandleRef } from '../../handle/handle';
import { ChevronRightIcon } from '../../icons/chevron_right/icon';
import { Spacer } from '../../layout/layout';
import { Menu, MenuDivider, MenuItem, MenuItemButton } from '../../menu/menu';
import { baseUnit } from '../../metrics/metrics';
import { Flyout } from '../../surface/flyout/flyout';
import styles from './flyout_menu.css';
import { FlyoutMenuStore, useFlyoutMenuAutoFocus, useFlyoutMenuContext, useFlyoutMenuHover, useFlyoutMenuKeyboardNavigation, useFlyoutMenuKeyCombinations, useFlyoutMenuStore, useNavigableRef, useNestedTriggerHover } from './flyout_menu_util';
export { FlyoutMenuStore, MenuDivider as FlyoutMenuDivider, useNavigableRef };
export function StatelessFlyoutMenu(props) {
    const { trigger = (props)=> _jsx(Button, {
            ...props,
            ref: props.focusRef
        }), label, disabled, open, flyoutPlacement = 'bottom-start', flyoutOffset, blockOutsidePointerEvents, captureFocus = false, id, role, ariaLabel, ariaLabelledBy, tagName: TagName = 'div', triggerFocusRef, triggerContainerRef, tone = 'secondary', size, icon, iconSize, iconPosition, onRequestClose, onRequestOpen, onClose, tooltipLabel, tooltipDisabled, tooltipPlacement, title, description, headerStart, headerEnd, headerDivider = 'always', header, footer } = props;
    const className = classNames(styles.triggerContainer, props.className);
    const onRequestToggle = React.useCallback(()=>{
        if (!open) onRequestOpen();
        else onRequestClose();
    }, [
        open,
        onRequestClose,
        onRequestOpen
    ]);
    return (_jsx(TagName, {
            ref: triggerContainerRef,
            className: className,
            role: role,
            children: _jsx(Flyout, {
                open: open,
                captureFocus: captureFocus,
                onRequestClose: onRequestClose,
                onCloseComplete: onClose,
                blockOutsidePointerEvents: blockOutsidePointerEvents,
                placement: flyoutPlacement,
                offset: flyoutOffset,
                width: "52u",
                dangerouslySetWidthMode: "maximum",
                title: title,
                description: description,
                headerStart: headerStart,
                headerEnd: headerEnd,
                headerDivider: headerDivider,
                header: header,
                footer: footer,
                trigger: ({ ariaControls, disclosure, active, pressed })=>{
                    return trigger({
                        id,
                        disabled,
                        ariaHasPopup: 'menu',
                        variant: tone,
                        size,
                        icon,
                        iconSize,
                        iconPosition,
                        ariaLabel,
                        ariaLabelledBy,
                        focusRef: triggerFocusRef,
                        onClick: onRequestToggle,
                        onRequestToggle,
                        tooltipLabel,
                        tooltipDisabled,
                        tooltipPlacement,
                        ariaControls,
                        disclosure,
                        active,
                        pressed,
                        children: label
                    });
                },
                children: ({ mode })=>_jsx(Menu, {
                        role: "menu",
                        ref: props.menuContainerRef,
                        className: classNames(styles.flyoutMenuContent),
                        ariaLabelledBy: id,
                        children: typeof props.children === 'function' ? props.children({
                            mode
                        }) : props.children
                    })
            })
        }));
}
export const FlyoutMenu = observer(React.forwardRef((props, ref)=>{
    const FlyoutMenuContext = useFlyoutMenuContext(props.store);
    const parentFlyoutMenuStore = useFlyoutMenuStore();
    const navigableRef = useNavigableRef();
    const isControlled = props.open != null;
    const isNested = parentFlyoutMenuStore != null;
    const { store } = FlyoutMenuContext;
    store.parentStore = parentFlyoutMenuStore;
    var _props_open;
    const isOpen = (_props_open = props.open) !== null && _props_open !== void 0 ? _props_open : store.open;
    const openRef = React.useRef(isOpen);
    openRef.current = isOpen;
    const onRequestOpen = React.useMemo(()=>{
        var _props_onRequestToggle;
        return (_props_onRequestToggle = props.onRequestToggle) !== null && _props_onRequestToggle !== void 0 ? _props_onRequestToggle : action(()=>{
            store.open = true;
        });
    }, [
        store,
        props.onRequestToggle
    ]);
    const onRequestClose = React.useMemo(()=>{
        var _props_onRequestToggle;
        return (_props_onRequestToggle = props.onRequestToggle) !== null && _props_onRequestToggle !== void 0 ? _props_onRequestToggle : action(()=>{
            store.open = false;
        });
    }, [
        store,
        props.onRequestToggle
    ]);
    const open = React.useCallback(()=>{
        if (!openRef.current) onRequestOpen();
    }, [
        onRequestOpen
    ]);
    const close = React.useCallback(()=>{
        if (openRef.current) onRequestClose();
    }, [
        onRequestClose
    ]);
    const keyboardNavigation = useFlyoutMenuKeyboardNavigation({
        store,
        onExit: props.captureFocus ? undefined : onRequestClose
    });
    const { triggerRef: triggerKeyCombinationRef, menuRef: menuKeyCombinationRef } = useFlyoutMenuKeyCombinations({
        isNested,
        isControlled,
        open,
        close,
        moveToFirst: keyboardNavigation.moveToFirst,
        moveToLast: keyboardNavigation.moveToLast
    });
    const { ref: triggerFocusRef } = useFlyoutMenuAutoFocus(isOpen);
    const { ref: menuHoverRef } = useFlyoutMenuHover({
        store,
        isOpen,
        close
    });
    const { onOpen } = props;
    React.useEffect(()=>{
        return reaction(()=>store.open, (open)=>{
            if (open == null) return;
            if (open) onOpen === null || onOpen === void 0 ? void 0 : onOpen();
        });
    }, [
        store,
        onOpen
    ]);
    const { trigger = isNested ? (props)=> _jsx(NestedFlyoutMenuButton, {
            ref: props.focusRef,
            ...props
        }) : (props)=> _jsx(Button, {
            ref: props.focusRef,
            ...props
        }) } = props;
    const triggerId = React.useId();
    const captureFocus = props.captureFocus || isOpen;
    var _props_id;
    return _jsx(FlyoutMenuContext.Provider, {
        value: store,
        children: _jsx(StatelessFlyoutMenu, {
            trigger: trigger,
            open: isOpen,
            disabled: props.disabled,
            triggerContainerRef: composeRefs(triggerKeyCombinationRef, props.triggerContainerRef),
            triggerFocusRef: composeRefs(triggerFocusRef, navigableRef, props.triggerFocusRef),
            menuContainerRef: composeRefs(menuKeyCombinationRef, menuHoverRef, props.menuContainerRef, keyboardNavigation.ref),
            onRequestClose: onRequestClose,
            onRequestOpen: onRequestOpen,
            onClose: props.onClose,
            blockOutsidePointerEvents: props.blockOutsidePointerEvents,
            flyoutPlacement: isNested ? 'end-top' : props.flyoutPlacement,
            flyoutOffset: isNested ? {
                main: -baseUnit / 4,
                cross: -baseUnit
            } : undefined,
            label: props.label,
            tone: props.tone,
            size: props.size,
            icon: props.icon,
            iconSize: props.iconSize,
            tagName: isNested ? 'li' : 'div',
            className: props.className,
            iconPosition: props.iconPosition,
            captureFocus: captureFocus,
            id: (_props_id = props.id) !== null && _props_id !== void 0 ? _props_id : triggerId,
            role: isNested ? 'none' : undefined,
            ariaLabel: props.ariaLabel,
            ariaLabelledBy: props.ariaLabelledBy,
            tooltipLabel: props.tooltipLabel,
            tooltipDisabled: props.tooltipDisabled,
            tooltipPlacement: props.tooltipPlacement,
            title: props.title,
            description: props.description,
            headerStart: props.headerStart,
            headerEnd: props.headerEnd,
            header: props.header,
            headerDivider: props.headerDivider,
            footer: props.footer,
            children: props.children
        })
    });
}));
export const FlyoutMenuContent = React.forwardRef(function FlyoutMenuContent(props, ref) {
    const FlyoutMenuContext = useFlyoutMenuContext(props.store);
    const keyboardNavigation = useFlyoutMenuKeyboardNavigation({
        store: FlyoutMenuContext.store,
        onExit: props.onRequestClose
    });
    const className = classNames(styles.flyoutMenuContent, props.className);
    const { ref: menuHoverRef } = useFlyoutMenuHover({
        store: FlyoutMenuContext.store
    });
    React.useEffect(keyboardNavigation.moveToFirst, []);
    return _jsx(FlyoutMenuContext.Provider, {
        value: FlyoutMenuContext.store,
        children: _jsx(Menu, {
            role: "menu",
            className: className,
            ref: composeRefs(ref, menuHoverRef, keyboardNavigation.ref),
            children: props.children
        })
    });
});
const NestedFlyoutMenuButton = React.memo(React.forwardRef((props, handleRef)=>{
    const store = useFlyoutMenuStore();
    const timeout = React.useRef(undefined);
    const { onRequestToggle } = props;
    var _props_pressed;
    const open = (_props_pressed = props.pressed) !== null && _props_pressed !== void 0 ? _props_pressed : props.active;
    const onMouseEnter = React.useCallback(()=>{
        clearTimeout(timeout.current);
        if (!open) timeout.current = setTimeout(()=>{
            var _store_parentStore;
            if ((store === null || store === void 0 ? void 0 : (_store_parentStore = store.parentStore) === null || _store_parentStore === void 0 ? void 0 : _store_parentStore.currentlyOpenMenu) == null) onRequestToggle();
        }, 400);
    }, [
        store,
        open,
        onRequestToggle
    ]);
    const onMouseLeave = React.useCallback(()=>{
        clearTimeout(timeout.current);
    }, []);
    const onClick = React.useCallback(()=>{
        if (!open) {
            clearTimeout(timeout.current);
            onRequestToggle();
        }
    }, [
        open,
        onRequestToggle
    ]);
    const { ref: hoverRef } = useNestedTriggerHover({
        isOpen: open
    });
    const buttonRef = useHandleRef(handleRef, createBasicHTMLHandle);
    return _jsx(MenuItemButton, {
        onClick: props.disabled ? undefined : onClick,
        onMouseEnter: props.disabled ? undefined : onMouseEnter,
        onMouseLeave: props.disabled ? undefined : onMouseLeave,
        buttonRef: composeRefs(hoverRef, buttonRef),
        pressed: open,
        selected: props.selected,
        disabled: props.disabled,
        disclosure: true,
        ariaHasPopup: "menu",
        id: props.id,
        role: "menuitem",
        ariaControls: props.ariaControls,
        ariaLabel: props.ariaLabel,
        ariaLabelledBy: props.ariaLabelledBy,
        tabIndex: -1,
        start: props.iconPosition !== 'end' && props.icon && _jsx(props.icon, {
            size: "medium"
        }),
        end: _jsxs(_Fragment, {
            children: [
                _jsx(Spacer, {
                    direction: "horizontal",
                    size: "6u"
                }),
                props.iconPosition === 'end' && props.icon && _jsx(props.icon, {
                    size: "medium"
                }),
                _jsx(ChevronRightIcon, {
                    size: "medium"
                })
            ]
        }),
        children: props.children
    });
}));
export const FlyoutMenuItem = React.forwardRef(function FlyoutMenuItem(props, ref) {
    const navigableRef = useNavigableRef({
        disabled: props.disabled
    });
    return _jsx(MenuItem, {
        tabIndex: -1,
        buttonRef: composeRefs(navigableRef, ref),
        className: props.className,
        label: props.label,
        description: props.description,
        disabled: props.disabled,
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        start: props.start,
        end: _jsxs(_Fragment, {
            children: [
                _jsx(Spacer, {
                    direction: "horizontal",
                    size: "6u"
                }),
                typeof props.end === 'function' ? props.end() : props.end
            ]
        }),
        href: props.href,
        target: props.target,
        onClick: props.onClick,
        active: props.active,
        selected: props.selected,
        tooltipDisabled: props.tooltipDisabled,
        tooltipLabel: props.tooltipLabel,
        tooltipLineClamp: props.tooltipLineClamp,
        tooltipPlacement: props.tooltipPlacement,
        tooltipShortcut: props.tooltipShortcut,
        children: props.children
    });
});
