import { makeObservable } from '../../../../base/make_observable/make_observable';
import { observable } from 'mobx';
import * as React from 'react';
import { useKeyboardNavigation } from '../../a11y/keyboard_navigation/use_keyboard_navigation';
import { dangerouslyGetHTMLElement } from '../../handle/handle';
import { shift, useKeyCombinationHandler } from '../../key_combinations/key_combinations';
export const FlyoutMenuContext = React.createContext(null);
export class FlyoutMenuStore {
    static _makeObservable(instance) {
        makeObservable(instance, {
            open: observable.ref,
            closeCurrentlyOpenMenu: observable.ref,
            currentlyOpenMenu: observable.ref,
            parentStore: observable.ref
        });
    }
    constructor(){
        this.open = (FlyoutMenuStore._makeObservable(this), false);
        this.itemRefs = new SortedSet(byDocumentPosition);
        this.currentlyOpenMenu = null;
        this.parentStore = null;
    }
}
export function useFlyoutMenuStore() {
    return React.useContext(FlyoutMenuContext);
}
export function useFlyoutMenuContext(store) {
    return {
        store: React.useMemo(()=>store !== null && store !== void 0 ? store : new FlyoutMenuStore(), [
            store
        ]),
        Provider: FlyoutMenuContext.Provider
    };
}
export function useNavigableRef({ disabled } = {}) {
    const flyoutMenuStore = useFlyoutMenuStore();
    const ref = React.useRef(null);
    const setRef = React.useCallback((el)=>{
        if ((flyoutMenuStore === null || flyoutMenuStore === void 0 ? void 0 : flyoutMenuStore.itemRefs) == null) return;
        const { itemRefs } = flyoutMenuStore;
        if (ref.current && ref.current !== el) itemRefs.delete(ref.current);
        if (disabled) return;
        if (el && ref.current !== el) itemRefs.add(el);
        ref.current = el;
    }, [
        ref,
        disabled,
        flyoutMenuStore
    ]);
    return setRef;
}
export function useFlyoutMenuKeyboardNavigation({ store, onExit }) {
    return useKeyboardNavigation(store.itemRefs.size, {
        mode: 'cycle',
        handleInputs: true,
        onChange: React.useCallback((index)=>{
            var _store_closeCurrentlyOpenMenu;
            const it = store === null || store === void 0 ? void 0 : store.itemRefs.values();
            let ref;
            for(let i = 0; i <= index; i++)ref = it === null || it === void 0 ? void 0 : it.next().value;
            ref === null || ref === void 0 ? void 0 : ref.focus();
            (_store_closeCurrentlyOpenMenu = store.closeCurrentlyOpenMenu) === null || _store_closeCurrentlyOpenMenu === void 0 ? void 0 : _store_closeCurrentlyOpenMenu.call(store);
        }, [
            store
        ]),
        onExit
    });
}
export function useFlyoutMenuAutoFocus(open) {
    const ref = React.useRef(null);
    const prevOpen = React.useRef(open);
    React.useEffect(()=>{
        if (open) {
            prevOpen.current = open;
            return;
        }
        if (prevOpen.current && !open) {
            prevOpen.current = open;
            setTimeout(()=>{
                var _ref_current;
                return (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();
            }, 0);
        }
    }, [
        open
    ]);
    return {
        ref
    };
}
export function useFlyoutMenuKeyCombinations({ isNested, isControlled, open, close, moveToFirst, moveToLast }) {
    const [isFocusingItem, setIsFocusingItem] = React.useState(null);
    const triggerKeyCombinationMap = React.useMemo(()=>{
        const common = [
            [
                'Enter',
                (e)=>{
                    if (!isControlled) {
                        e.preventDefault();
                        open();
                    }
                    setIsFocusingItem('first');
                }
            ],
            [
                ' ',
                (e)=>{
                    if (!isControlled) {
                        e.preventDefault();
                        open();
                    }
                    setIsFocusingItem('first');
                }
            ]
        ];
        if (isNested) return [
            ...common,
            [
                'next',
                (e)=>{
                    e.preventDefault();
                    if (!isControlled) open();
                    setIsFocusingItem('first');
                }
            ]
        ];
        return [
            ...common,
            [
                'ArrowUp',
                (e)=>{
                    e.preventDefault();
                    if (!isControlled) open();
                    setIsFocusingItem('last');
                }
            ],
            [
                'ArrowDown',
                (e)=>{
                    e.preventDefault();
                    if (!isControlled) open();
                    setIsFocusingItem('first');
                }
            ],
            [
                'Escape',
                ()=>{
                    if (!isControlled) close();
                }
            ],
            [
                'Tab',
                ()=>{
                    if (!isControlled) close();
                }
            ],
            [
                shift('Tab'),
                ()=>{
                    if (!isControlled) close();
                }
            ]
        ];
    }, [
        setIsFocusingItem,
        isNested,
        isControlled,
        open,
        close
    ]);
    const { ref: triggerRef } = useKeyCombinationHandler(triggerKeyCombinationMap, {
        handleInputs: false
    });
    const menuKeyCombinationMap = React.useMemo(()=>{
        if (!isNested) return [];
        return [
            [
                'previous',
                (e)=>{
                    e.preventDefault();
                    e.stopPropagation();
                    close();
                }
            ]
        ];
    }, [
        isNested,
        close
    ]);
    const { ref: menuRef, element: menuContainerElement } = useKeyCombinationHandler(menuKeyCombinationMap, {
        handleInputs: false
    });
    React.useEffect(()=>{
        if (menuContainerElement) {
            if (isFocusingItem === 'first') moveToFirst();
            else if (isFocusingItem === 'last') moveToLast();
            setIsFocusingItem(null);
        }
    }, [
        isFocusingItem,
        setIsFocusingItem,
        menuContainerElement,
        moveToFirst,
        moveToLast
    ]);
    return {
        triggerRef,
        menuRef
    };
}
export function useFlyoutMenuHover({ store, isOpen, close }) {
    const origin = React.useRef(null);
    const ref = React.useCallback((el)=>{
        if (store.parentStore) {
            store.parentStore.closeCurrentlyOpenMenu = el ? close : undefined;
            store.parentStore.currentlyOpenMenu = el;
        }
        el === null || el === void 0 ? void 0 : el.addEventListener('mousemove', (e)=>{
            var _store_currentlyOpenMenu;
            const menuBounds = (_store_currentlyOpenMenu = store.currentlyOpenMenu) === null || _store_currentlyOpenMenu === void 0 ? void 0 : _store_currentlyOpenMenu.getBoundingClientRect();
            const position = {
                x: e.clientX,
                y: e.clientY
            };
            if (menuBounds && origin.current && !isMovingTowards(menuBounds, origin.current, position)) {
                var _store_closeCurrentlyOpenMenu;
                (_store_closeCurrentlyOpenMenu = store.closeCurrentlyOpenMenu) === null || _store_closeCurrentlyOpenMenu === void 0 ? void 0 : _store_closeCurrentlyOpenMenu.call(store);
                origin.current = null;
            } else
                origin.current = position;
        });
    }, [
        store,
        close
    ]);
    return {
        ref
    };
}
export function useNestedTriggerHover({ isOpen }) {
    const isOpenRef = React.useRef(undefined);
    isOpenRef.current = isOpen;
    const ref = React.useCallback((handle)=>{
        var _dangerouslyGetHTMLElement;
        (_dangerouslyGetHTMLElement = dangerouslyGetHTMLElement(handle)) === null || _dangerouslyGetHTMLElement === void 0 ? void 0 : _dangerouslyGetHTMLElement.addEventListener('mousemove', (e)=>{
            isOpenRef.current && e.stopPropagation();
        });
    }, []);
    return {
        ref
    };
}
class SortedSet extends Set {
    add(value) {
        super.add(value);
        this.sort();
        return this;
    }
    delete(value) {
        const success = super.delete(value);
        this.sort();
        return success;
    }
    sort() {
        const elements = [
            ...this
        ];
        this.clear();
        elements.sort(this.comparator).forEach(super.add, this);
    }
    constructor(comparator){
        super(), this.comparator = comparator;
    }
}
function byDocumentPosition(a, b) {
    var _aElement_compareDocumentPosition;
    const aElement = dangerouslyGetHTMLElement(a);
    const bElement = dangerouslyGetHTMLElement(b);
    if (!(aElement === null || aElement === void 0 ? void 0 : aElement.isConnected) || !(bElement === null || bElement === void 0 ? void 0 : bElement.isConnected)) return 0;
    return bElement && ((_aElement_compareDocumentPosition = aElement.compareDocumentPosition) === null || _aElement_compareDocumentPosition === void 0 ? void 0 : _aElement_compareDocumentPosition.call(aElement, bElement)) & Node.DOCUMENT_POSITION_PRECEDING ? 1 : -1;
}
function isMovingTowards(bounds, origin, current) {
    const vA = {
        x: bounds.left - origin.x,
        y: bounds.top - origin.y
    };
    const vC = {
        x: bounds.left - origin.x,
        y: bounds.bottom - origin.y
    };
    const vB = {
        x: current.x - origin.x,
        y: current.y - origin.y
    };
    return isBetween(vB, vA, vC);
}
function isBetween(b, a, c) {
    return crossProduct(a, b) * crossProduct(a, c) >= 0 && crossProduct(c, b) * crossProduct(c, a) >= 0;
}
function crossProduct(a, b) {
    return a.y * b.x - a.x * b.y;
}
