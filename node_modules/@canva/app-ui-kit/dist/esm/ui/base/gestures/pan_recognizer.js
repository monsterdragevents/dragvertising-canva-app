import { getCommonEventProperties } from './recognizer';
export class PanRecognizer {
    getBrowserHandledTouchActions() {
        if (!this.activePointers.includes('touch')) return [
            'auto'
        ];
        const allowedTouchActions = [
            'pinch-zoom'
        ];
        if (this.opts.direction) {
            if ([
                'up',
                'down',
                'vertical'
            ].includes(this.opts.direction))
            allowedTouchActions.push('pan-x');
            else if ([
                'left',
                'right',
                'horizontal'
            ].includes(this.opts.direction)) allowedTouchActions.push('pan-y');
        }
        return allowedTouchActions;
    }
    onPointerDown(pointer, allPointers) {
        if (pointer.start.button == null && this.activePointers.includes('touch') || pointer.start.button === 0 && this.activePointers.includes('mouse_main') || pointer.start.button === 1 && this.activePointers.includes('mouse_middle'))
            this.checkState(allPointers);
    }
    onPointerUp(pointer, allPointers) {
        this.checkState(allPointers);
    }
    onPointerMove(pointers, allPointers) {
        if (!this.state)
        return;
        const { start, pointer: { current } } = this.state;
        const event = getPanEventProperties(current, start, current);
        if (this.state.recognized) {
            this.opts.onMove && this.opts.onMove(event);
            return;
        }
        if (this.shouldStart(event)) {
            this.state.recognized = true;
            this.opts.onStart && this.opts.onStart(event);
            return;
        }
    }
    onUnmount() {
        var _this_state;
        if (this.opts.onEnd && ((_this_state = this.state) === null || _this_state === void 0 ? void 0 : _this_state.recognized)) {
            const { start, pointer: { current } } = this.state;
            this.opts.onEnd(getPanEventProperties(current, start, current));
        }
    }
    checkState(allPointers) {
        if (allPointers.size !== 1 && this.state) {
            const { recognized, start, pointer: { current } } = this.state;
            this.state = undefined;
            if (recognized && this.opts.onEnd) this.opts.onEnd(getPanEventProperties(current, start, current));
        }
        if (allPointers.size === 1 && !this.state) {
            const pointer = allPointers.values().next().value;
            this.state = {
                recognized: false,
                pointer,
                start: pointer.current
            };
        }
    }
    shouldStart(event) {
        var _this_opts_minDistance;
        if (event.distance < ((_this_opts_minDistance = this.opts.minDistance) !== null && _this_opts_minDistance !== void 0 ? _this_opts_minDistance : 10)) return false;
        return this.checkDirection(event);
    }
    checkDirection(event) {
        if (!this.opts.direction) return true;
        else if (this.opts.direction === 'vertical') return event.direction === 'up' || event.direction === 'down';
        else if (this.opts.direction === 'horizontal') return event.direction === 'left' || event.direction === 'right';
        else return event.direction === this.opts.direction;
    }
    constructor(opts){
        this.opts = opts;
        this.shouldDisableTextSelect = true;
        var _opts_activePointers;
        this.activePointers = (_opts_activePointers = opts.activePointers) !== null && _opts_activePointers !== void 0 ? _opts_activePointers : [
            'touch',
            'mouse_main'
        ];
    }
}
export function getPanEventProperties(pointer, start, current) {
    const distanceX = current.x - start.x;
    const distanceY = current.y - start.y;
    const distance = Math.sqrt(distanceX ** 2 + distanceY ** 2);
    const deltaX = current.x - start.x;
    const deltaY = current.y - start.y;
    const delta = Math.sqrt(deltaX ** 2 + deltaY ** 2);
    const deltaTime = current.timestamp - start.timestamp;
    return {
        ...getCommonEventProperties(pointer, current),
        velocityX: deltaX / deltaTime,
        velocityY: deltaY / deltaTime,
        velocity: delta / deltaTime,
        distanceX,
        distanceY,
        distance,
        direction: getDirection(deltaX, deltaY),
        button: start.button
    };
}
export function getDirection(distanceX, distanceY) {
    if (distanceX === distanceY) return 'none';
    if (Math.abs(distanceX) >= Math.abs(distanceY)) return distanceX < 0 ? 'left' : 'right';
    return distanceY < 0 ? 'up' : 'down';
}
