import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { Preconditions } from '../../../../base/preconditions';
import classNames from 'classnames';
import * as React from 'react';
import Measure from 'react-measure';
import { useEnableAnimations } from '../../provider/provider';
import styles, { customProperties } from './progress_bar.css';
export const TRANSITION_END_TIMEOUT_MS = parseInt(styles.widthTransitionDurationMs, 10) + 100 || 2000;
const bubbleStyles = [
    styles.bubble0,
    styles.bubble1,
    styles.bubble2,
    styles.bubble3
];
const bubbleTTLs = [
    2000,
    3000,
    4000,
    2000
];
const bubbleUpdateInterval = 1000;
const bubblePerPixelRatio = 0.13;
export const ProgressBar = (props)=>{
    const { value, ariaLabel, size = 'medium', tone = 'info', disableAnimations, onProgressAnimationEnd, disableBubbles, stretch = false } = props;
    const [bubbles, setBubbles] = React.useState([]);
    const enableAnimations = useEnableAnimations();
    const privateFields = React.useRef({
        bubbleUpdateTimer: 0,
        currentProgressValueTransitionEndHandled: false,
        onProgressAnimationEndTimeout: 0,
        width: 0
    });
    const updateBubbles = React.useCallback(()=>{
        const now = Date.now();
        const valueWidth = privateFields.current.width / 100 * value;
        const requiredBubblesAmount = Math.ceil(valueWidth * bubblePerPixelRatio);
        const requiredBubblesAmountDelta = requiredBubblesAmount - bubbles.length;
        const newBubblesAmount = requiredBubblesAmountDelta < 0 ? requiredBubblesAmount : Math.ceil(bubbles.length + requiredBubblesAmountDelta / 2);
        let bubblesChanged = false;
        const newBubbles = Array.from({
            length: newBubblesAmount
        }, (_, i)=>{
            const bubble = bubbles[i];
            if (bubble === undefined || now > bubbleTTLs[bubble.type] + bubble.start) {
                bubblesChanged = true;
                return {
                    swap: bubble ? !bubble.swap : false,
                    type: Math.floor(Math.random() * bubbleStyles.length),
                    position: Math.floor(Math.random() * valueWidth),
                    start: now
                };
            }
            return bubble;
        });
        if (bubblesChanged) setBubbles(newBubbles);
        window.clearTimeout(privateFields.current.bubbleUpdateTimer);
        privateFields.current.bubbleUpdateTimer = window.setTimeout(updateBubbles, bubbleUpdateInterval);
    }, [
        bubbles,
        value
    ]);
    const onProgressTransitionEnd = React.useCallback(()=>{
        window.clearTimeout(privateFields.current.onProgressAnimationEndTimeout);
        if (!privateFields.current.currentProgressValueTransitionEndHandled) {
            privateFields.current.currentProgressValueTransitionEndHandled = true;
            onProgressAnimationEnd && onProgressAnimationEnd(value);
        }
    }, [
        onProgressAnimationEnd,
        value
    ]);
    React.useEffect(()=>{
        const bubbleUpdateTimer = privateFields.current.bubbleUpdateTimer;
        return ()=>{
            window.clearTimeout(bubbleUpdateTimer);
        };
    }, []);
    React.useEffect(()=>{
        if (enableAnimations && !disableBubbles) updateBubbles();
        validateProgressValue(value);
        privateFields.current.currentProgressValueTransitionEndHandled = false;
        window.clearTimeout(privateFields.current.onProgressAnimationEndTimeout);
        privateFields.current.onProgressAnimationEndTimeout = window.setTimeout(onProgressTransitionEnd, TRANSITION_END_TIMEOUT_MS);
    }, [
        value,
        disableBubbles,
        onProgressTransitionEnd,
        updateBubbles,
        enableAnimations
    ]);
    const onResize = (contentRect)=>{
        if (contentRect.entry) privateFields.current.width = contentRect.entry.width;
    };
    const valueBackgroundStyle = {
        transform: `scaleX(${value / 100})`
    };
    return _jsx(Measure, {
        onResize: onResize,
        children: ({ measureRef })=>_jsx("div", {
                ref: measureRef,
                className: classNames(styles.progressBar, {
                    [styles.stretch]: stretch,
                    [styles.small]: size === 'small',
                    [styles.critical]: tone === 'critical',
                    [styles.animate]: !disableAnimations && enableAnimations
                }),
                role: "progressbar",
                "aria-label": ariaLabel,
                "aria-valuemin": 0,
                "aria-valuenow": value,
                "aria-valuemax": 100,
                children: _jsx("div", {
                    className: styles.valueContainer,
                    style: {
                        [customProperties.valueContainerOffset]: `${value - 100}%`
                    },
                    children: _jsxs("div", {
                        className: styles.valueContainer,
                        style: {
                            [customProperties.valueContainerOffset]: `${100 - value}%`
                        },
                        children: [
                            _jsx("div", {
                                className: styles.valueBackground,
                                style: valueBackgroundStyle,
                                onTransitionEnd: onProgressTransitionEnd
                            }),
                            bubbles.map(({ position, type, swap }, i)=>_jsx("div", {
                                    className: classNames(bubbleStyles[type], {
                                        [styles.bubbleSwap]: swap
                                    }),
                                    style: {
                                        [customProperties.bubbleSide]: `${position}px`
                                    }
                                }, i))
                        ]
                    })
                })
            })
    });
};
function validateProgressValue(value) {
    Preconditions.checkState(value >= 0 && value <= 100, `value must be in [0, 100]; got ${value}`);
}
