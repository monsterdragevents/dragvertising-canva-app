import { jsx as _jsx } from "react/jsx-runtime";
import { UnreachableError } from '../../../base/preconditions';
import { action, reaction, runInAction } from 'mobx';
import { observer } from 'mobx-react-lite';
import * as React from 'react';
import { useEnableHighColorContrast, useTheme } from '../provider/provider';
import { useAdaptiveColorScheme } from './adaptive';
import { getAllPreloadClasses, getThemeClasses, rootThemeStore, ThemeContext, ThemeData, ThemeStore } from './internal';
const ADAPTIVE_APPEARANCES = ['classicAdaptive', 'adaptive'];
export function cleanThemePreload() {
  const preloadClasses = getAllPreloadClasses();
  document.documentElement.classList.remove(...preloadClasses);
  document.body.classList.remove(...preloadClasses);
}
export function ApplyThemeRoot(
  {
    appearance: givenAppearance,
    ...ccTheme
  }
) {
  const appearance = useAppearance({
    theme: useTheme(),
    enableHighColorContrast: useEnableHighColorContrast()
  }, givenAppearance);
  const theme = useThemeMapping(ccTheme);
  const adaptiveColorScheme = useAdaptiveColorScheme({
    enabled: ADAPTIVE_APPEARANCES.includes(appearance)
  });
  const resolvedAppearance = resolveAdaptiveAppearance({
    colorScheme: adaptiveColorScheme,
    appearance
  });
  const mountedRef = React.useRef(false);
  if (!mountedRef.current) {
    mountedRef.current = true;
    runInAction(() => {
      rootThemeStore.setAppearance(resolvedAppearance);
      rootThemeStore.setThemeMapping(theme);
    });
  }
  useIsomorphicLayoutEffect(action(() => {
    rootThemeStore.setAppearance(resolvedAppearance);
    rootThemeStore.setThemeMapping(theme);
  }), [resolvedAppearance, theme]);
  useIsomorphicLayoutEffect(() => action(() => {
    rootThemeStore.setAppearance(undefined);
    rootThemeStore.setThemeMapping({});
  }), []);
  useIsomorphicLayoutEffect(cleanThemePreload, []);
  useIsomorphicLayoutEffect(() => reaction(() => rootThemeStore.currentTheme, (newTheme, prevTheme) => {
    const {
      classList
    } = document.documentElement;
    if (prevTheme != null) classList.remove(...getThemeClasses(prevTheme));
    if (newTheme != null) classList.add(...getThemeClasses(newTheme));
  }, {
    fireImmediately: true
  }), []);
  return null;
}
function resolveAdaptiveAppearance(
  {
    colorScheme,
    appearance
  }
) {
  switch (appearance) {
    case 'classicAdaptive':
      return colorScheme === 'dark' ? 'classicDark' : 'classicLight';
    case 'adaptive':
      return colorScheme !== null && colorScheme !== void 0 ? colorScheme : 'light';
    default:
      return appearance;
  }
}
const canUseDOM = () => typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';
const useIsomorphicLayoutEffect = canUseDOM() ? React.useLayoutEffect : React.useEffect;
export const ThemeBoundary = observer(function ThemeBoundary({
  children,
  ...ccTheme
}) {
  const theme = useThemeMapping(ccTheme);
  const [themeContext] = React.useState(() => {
    const store = new ThemeStore();
    return {
      store,
      data: new ThemeData(store)
    };
  });
  const {
    store: parentStore
  } = React.useContext(ThemeContext);
  themeContext.store.setParent(parentStore);
  themeContext.store.setThemeMapping(theme);
  return _jsx(ThemeContext.Provider, {
    value: themeContext,
    children: children(themeContext.data)
  });
});
function useThemeMapping(theme) {
  return React.useMemo(() => ({
    ['classicLight']: theme.classicLight,
    ['classicDark']: theme.classicDark,
    ['light']: theme.light,
    ['dark']: theme.dark
  }), [theme.classicLight, theme.classicDark, theme.light, theme.dark]);
}
export const useThemeData = () => React.useContext(ThemeContext).data;
export const WithThemeData = observer(function WithThemeData({
  children
}) {
  const data = useThemeData();
  return children(data);
});
function useAppearance(
  {
    theme,
    enableHighColorContrast
  },
  givenAppearance
) {
  switch (theme) {
    case undefined:
      return givenAppearance;
    case 'ADAPTIVE':
      return enableHighColorContrast ? 'adaptive' : 'classicAdaptive';
    case 'LIGHT':
      return enableHighColorContrast ? 'light' : 'classicLight';
    case 'DARK':
      return enableHighColorContrast ? 'dark' : 'classicDark';
    default:
      throw new UnreachableError(theme);
  }
}