import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import { exists } from '../../../../base/exists';
import { observer } from 'mobx-react-lite';
import * as React from 'react';
import { useKeyCombinationHandler } from '../../key_combinations/key_combinations';
import { findAutoFocusElement, FOCUS_GUARD_ATTR, FOCUS_LOCK_EXCEPTED_ATTR, focusWithConditionalDelayHack, getFocusablesInside } from './dom_utils';
import { FocusLockManagerContextProvider, useFocusLockManager } from './focus_lock_manager';
const FOCUS_GUARD_PROP = {
    [FOCUS_GUARD_ATTR]: true
};
export const FocusLock = observer(React.forwardRef(
    function FocusLock({ autoFocus = true, children, className, disabled: propsDisabled = false, lockProps, returnFocus = true, preventScroll = 'never', makeContainerFocusable = false, onRequestEscape, keyCombinationMap = [], handleKeysOnInputs = true }, ref) {
        const [browserWindow, setBrowserWindow] = React.useState();
        const previouslyFocusedElement = React.useRef(null);
        const rootRef = React.useRef(null);
        const focusables = React.useRef([]);
        const isFocusablesOutdated = React.useRef(true);
        const preventAutoFocusScroll = preventScroll === 'always' || preventScroll === 'on-autofocus';
        const preventWrappingScroll = preventScroll === 'always';
        React.useEffect(()=>{
            setBrowserWindow(window);
            previouslyFocusedElement.current = window.document.activeElement;
        }, []);
        React.useLayoutEffect(()=>{
            var _rootRef_current;
            const currentWindow = (_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.ownerDocument.defaultView;
            if (currentWindow && currentWindow !== browserWindow) {
                setBrowserWindow(currentWindow);
                previouslyFocusedElement.current = currentWindow.document.activeElement;
            }
        }, [
            browserWindow
        ]);
        React.useLayoutEffect(()=>{
            if (!propsDisabled && browserWindow) {
                previouslyFocusedElement.current = browserWindow.document.activeElement;
                isFocusablesOutdated.current = true;
            }
        }, [
            propsDisabled,
            browserWindow
        ]);
        const { manager } = useFocusLockManager({
            browserWindow,
            disabled: propsDisabled
        });
        const disabled = propsDisabled || manager.surrenderLock;
        React.useLayoutEffect(()=>{
            if (!rootRef.current || disabled) return;
            const observer = new MutationObserver(()=>{
                isFocusablesOutdated.current = true;
            });
            observer.observe(rootRef.current, {
                childList: true,
                subtree: true
            });
            return ()=>{
                observer.disconnect();
            };
        }, [
            disabled
        ]);
        const regenerateFocusables = React.useCallback(()=>{
            if (isFocusablesOutdated.current && rootRef.current) {
                isFocusablesOutdated.current = false;
                focusables.current = getFocusablesInside(rootRef.current);
            }
        }, []);
        const findFirstFocusable = React.useCallback(()=>{
            regenerateFocusables();
            if (focusables.current.length > 0) return focusables.current[0];
        }, [
            regenerateFocusables
        ]);
        const focusFirst = React.useCallback(()=>{
            const firstFocusable = findFirstFocusable();
            if (firstFocusable) firstFocusable.focus({
                preventScroll: preventWrappingScroll
            });
        }, [
            preventWrappingScroll,
            findFirstFocusable
        ]);
        const focusLast = React.useCallback(()=>{
            regenerateFocusables();
            if (focusables.current.length > 0) focusables.current[focusables.current.length - 1].focus({
                preventScroll: preventWrappingScroll
            });
        }, [
            preventWrappingScroll,
            regenerateFocusables
        ]);
        const onFocusIn = React.useCallback((e)=>{
            if (!rootRef.current || e.target == null) return;
            if (isTargetExceptedFromFocusLock(e.target)) return;
            if (e.relatedTarget == null && !rootRef.current.contains(e.target)) {
                focusFirst();
                return;
            }
        }, [
            focusFirst
        ]);
        const onFocusOut = React.useCallback((e)=>{
            if (!rootRef.current || manager.surrenderLock) return;
            if (!e.relatedTarget || rootRef.current.contains(e.relatedTarget) || isTargetExceptedFromFocusLock(e.relatedTarget))
                return;
            if (e.target && rootRef.current.contains(e.target)) {
                e.target.focus({
                    preventScroll: preventWrappingScroll
                });
                return;
            }
            focusFirst();
        }, [
            focusFirst,
            manager,
            preventWrappingScroll
        ]);
        React.useLayoutEffect(()=>{
            if (!disabled && browserWindow) {
                browserWindow.document.addEventListener('focusout', onFocusOut, true);
                browserWindow.document.addEventListener('focusin', onFocusIn, true);
                return ()=>{
                    browserWindow.document.removeEventListener('focusout', onFocusOut, true);
                    browserWindow.document.removeEventListener('focusin', onFocusIn, true);
                };
            }
        }, [
            browserWindow,
            disabled,
            onFocusIn,
            onFocusOut
        ]);
        React.useLayoutEffect(()=>{
            if (!manager.isReady || browserWindow == null) return;
            if (propsDisabled || manager.surrenderLock || !rootRef.current) return;
            const { activeElement } = browserWindow.document;
            if (rootRef.current.contains(activeElement))
            return;
            if (!autoFocus) {
                activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur();
                return;
            }
            const autoFocusElement = (rootRef.current ? findAutoFocusElement(rootRef.current) : null) || findFirstFocusable();
            if (autoFocusElement && !isTargetExceptedFromFocusLock(autoFocusElement)) focusWithConditionalDelayHack(autoFocusElement, {
                preventScroll: preventAutoFocusScroll
            });
        }, [
            autoFocus,
            browserWindow,
            findFirstFocusable,
            manager.isReady,
            manager,
            preventAutoFocusScroll,
            propsDisabled
        ]);
        const returnFocusRef = React.useRef(returnFocus && !disabled);
        returnFocusRef.current = returnFocus && !disabled;
        React.useEffect(()=>{
            if (!propsDisabled) {
                const el = previouslyFocusedElement.current;
                return ()=>{
                    if (returnFocusRef.current && !manager.surrenderLock && el) el.focus({
                        preventScroll: preventWrappingScroll
                    });
                };
            }
        }, [
            propsDisabled
        ]);
        const finalKeyCombinationMap = React.useMemo(()=>{
            const escapeKeyHandler = onRequestEscape && !disabled ? [
                'Escape',
                (e)=>{
                    e.stopPropagation();
                    onRequestEscape();
                }
            ] : undefined;
            return [
                escapeKeyHandler,
                ...keyCombinationMap
            ].filter(exists);
        }, [
            disabled,
            keyCombinationMap,
            onRequestEscape
        ]);
        const { ref: keyHandlerRef } = useKeyCombinationHandler(finalKeyCombinationMap, {
            handleInputs: handleKeysOnInputs
        });
        return _jsx(FocusLockManagerContextProvider, {
            value: manager,
            children: _jsxs("div", {
                ...lockProps,
                className: className,
                ref: composeRefs(rootRef, ref, keyHandlerRef),
                tabIndex: makeContainerFocusable ? -1 : undefined,
                children: [
                    _jsx("div", {
                        onFocus: disabled ? undefined : focusLast,
                        tabIndex: disabled ? undefined : 0,
                        ...FOCUS_GUARD_PROP
                    }),
                    children,
                    _jsx("div", {
                        onFocus: disabled ? undefined : focusFirst,
                        tabIndex: disabled ? undefined : 0,
                        ...FOCUS_GUARD_PROP
                    })
                ]
            })
        });
    }
));
function isTargetExceptedFromFocusLock(target) {
    if ('hasAttribute' in target) return target.hasAttribute(FOCUS_LOCK_EXCEPTED_ATTR);
    return false;
}
