import { makeObservable } from '../../../../base/make_observable/make_observable';
import * as mobx from 'mobx';
import { useLocalObservable } from 'mobx-react-lite';
import * as React from 'react';
function isRealFocusLockManager(manager) {
    return manager.kind === 'real';
}
class FakeFocusLockManager {
    constructor(){
        this.kind = 'fake';
        this.surrenderLock = true;
        this.isReady = false;
    }
}
class RealFocusLockManager {
    static _makeObservable(instance) {
        makeObservable(instance, {
            windowToChildrenManagers: mobx.observable.shallow,
            browserWindow: mobx.observable.ref,
            _isReady: mobx.observable.ref,
            _isEnabled: mobx.observable.ref,
            hasEnabledDescendant: mobx.computed,
            isActiveBranch: mobx.computed,
            surrenderLock: mobx.computed,
            isReady: mobx.computed,
            setReady: mobx.action.bound,
            isEnabled: mobx.computed,
            setEnabled: mobx.action.bound,
            setWindow: mobx.action.bound,
            addChildManager: mobx.action.bound,
            removeChildManager: mobx.action.bound
        });
    }
    get hasEnabledDescendant() {
        const childManagers = this.windowToChildrenManagers.get(this.browserWindow);
        if (childManagers == null || childManagers.length === 0) return false;
        return childManagers.some((manager)=>manager.isEnabled || manager.hasEnabledDescendant);
    }
    get isActiveBranch() {
        if (!this.parentManager) return true;
        var _this_parentManager_windowToChildrenManagers_get;
        const childrenManagers = (_this_parentManager_windowToChildrenManagers_get = this.parentManager.windowToChildrenManagers.get(this.browserWindow)) !== null && _this_parentManager_windowToChildrenManagers_get !== void 0 ? _this_parentManager_windowToChildrenManagers_get : [];
        const siblingManagers = childrenManagers.filter((manager)=>manager !== this);
        const isSelfOrDescendantsEnabled = this.isEnabled || this.hasEnabledDescendant;
        if (siblingManagers == null || siblingManagers.length === 0 || childrenManagers[childrenManagers.length - 1] === this)
        return this.parentManager.isActiveBranch && isSelfOrDescendantsEnabled;
        else {
            const selfIndex = childrenManagers.indexOf(this);
            if (selfIndex === -1)
            return false;
            const hasActiveNewerSiblings = childrenManagers.slice(selfIndex + 1).some((manager)=>manager.isActiveBranch);
            return !hasActiveNewerSiblings && this.parentManager.isActiveBranch && isSelfOrDescendantsEnabled;
        }
    }
    get surrenderLock() {
        if (!this.isReady) return true;
        if (!this.isActiveBranch) return true;
        return this.hasEnabledDescendant;
    }
    get isReady() {
        return this._isReady;
    }
    setReady() {
        this._isReady = true;
    }
    get isEnabled() {
        return this._isEnabled;
    }
    setEnabled(enabled) {
        this._isEnabled = enabled;
    }
    setWindow(browserWindow) {
        this.browserWindow = browserWindow;
    }
    addChildManager(newManager, browserWindow) {
        var _this_windowToChildrenManagers_get;
        const childrenManagers = (_this_windowToChildrenManagers_get = this.windowToChildrenManagers.get(browserWindow)) !== null && _this_windowToChildrenManagers_get !== void 0 ? _this_windowToChildrenManagers_get : [];
        this.windowToChildrenManagers.set(browserWindow, [
            ...childrenManagers,
            newManager
        ]);
    }
    removeChildManager(manager, browserWindow) {
        const childrenManagers = this.windowToChildrenManagers.get(browserWindow);
        if (!childrenManagers) return;
        const resultManagers = childrenManagers.filter((childManager)=>childManager !== manager);
        if (resultManagers.length === 0) this.windowToChildrenManagers.delete(browserWindow);
        else this.windowToChildrenManagers.set(browserWindow, resultManagers);
    }
    constructor(parentManager){
        this.parentManager = parentManager;
        this.kind = (RealFocusLockManager._makeObservable(this), 'real');
        this.windowToChildrenManagers = new Map();
        this.browserWindow = window;
        this._isReady = false;
        this._isEnabled = false;
    }
}
function createFocusLockManager(parentManager) {
    if (typeof window !== 'undefined') return new RealFocusLockManager(parentManager);
    else return new FakeFocusLockManager();
}
const FocusLockManagerContext = React.createContext(createFocusLockManager());
export const FocusLockManagerContextProvider = FocusLockManagerContext.Provider;
export function useFocusLockManager({ browserWindow, disabled }) {
    const parentManager = React.useContext(FocusLockManagerContext);
    const manager = useLocalObservable(()=>{
        if (isRealFocusLockManager(parentManager)) return new RealFocusLockManager(parentManager);
        else return new FakeFocusLockManager();
    });
    React.useLayoutEffect(()=>{
        if (!isRealFocusLockManager(manager) || !isRealFocusLockManager(parentManager) || browserWindow == null) return;
        manager.setWindow(browserWindow);
        parentManager.addChildManager(manager, browserWindow);
        manager.setReady();
        return ()=>{
            parentManager.removeChildManager(manager, browserWindow);
        };
    }, [
        browserWindow,
        manager,
        parentManager
    ]);
    React.useLayoutEffect(()=>{
        if (!isRealFocusLockManager(manager) || !isRealFocusLockManager(parentManager) || browserWindow == null) return;
        manager.setEnabled(!disabled);
    }, [
        browserWindow,
        disabled,
        manager,
        parentManager
    ]);
    return {
        manager
    };
}
