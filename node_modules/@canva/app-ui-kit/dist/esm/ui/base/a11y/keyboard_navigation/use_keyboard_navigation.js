import * as React from 'react';
import { accessModeState } from '../access_mode_state/access_mode_state';
import { command, option, shift, useKeyCombinationHandler } from '../../key_combinations/key_combinations';
export function useKeyboardNavigation(size, options = {}) {
    const { direction = 'vertical', mode = 'default', handleInputs = false, extraNavigation = true, onChange, onPrev, onNext, onFirst, onLast, onSelect, onExit } = options;
    const [index, setIndex] = React.useState(()=>-1);
    const sizeRef = React.useRef(size);
    const indexRef = React.useRef(index);
    const onChangeRef = React.useRef(onChange);
    sizeRef.current = size;
    indexRef.current = index;
    onChangeRef.current = onChange;
    const moveTo = React.useCallback((index = -1)=>{
        if (indexRef.current !== index) {
            var _onChangeRef_current;
            setIndex(indexRef.current = index);
            (_onChangeRef_current = onChangeRef.current) === null || _onChangeRef_current === void 0 ? void 0 : _onChangeRef_current.call(onChangeRef, indexRef.current);
        }
    }, []);
    const moveToFirst = React.useCallback(()=>moveTo(0), [
        moveTo
    ]);
    const moveToLast = React.useCallback(()=>moveTo(sizeRef.current - 1), [
        moveTo
    ]);
    React.useEffect(()=>{
        moveTo(size != null ? Math.min(indexRef.current, size - 1) : -1);
    }, [
        size,
        moveTo
    ]);
    const _onPrev = React.useCallback((e)=>{
        e.preventDefault();
        if (e.isComposing)
            return;
        const index = indexRef.current;
        let newIndex = Math.max(0, index - 1);
        onPrev === null || onPrev === void 0 ? void 0 : onPrev(e, index);
        if (mode === 'cycle' && newIndex === index) newIndex = sizeRef.current - 1;
        else if (newIndex === 0) onFirst === null || onFirst === void 0 ? void 0 : onFirst(e, index);
        moveTo(newIndex);
        accessModeState.setAccessMode('keyboard');
    }, [
        onPrev,
        onFirst,
        moveTo,
        mode
    ]);
    const _onNext = React.useCallback((e)=>{
        e.preventDefault();
        if (e.isComposing)
            return;
        const index = indexRef.current;
        const size = sizeRef.current;
        let newIndex = Math.min(size - 1, index + 1);
        onNext === null || onNext === void 0 ? void 0 : onNext(e, index);
        if (mode === 'cycle' && newIndex === index) newIndex = 0;
        else if (newIndex === size - 1) onLast === null || onLast === void 0 ? void 0 : onLast(e, index);
        moveTo(newIndex);
        accessModeState.setAccessMode('keyboard');
    }, [
        onNext,
        mode,
        moveTo,
        onLast
    ]);
    const _onFirst = React.useCallback((e)=>{
        e.preventDefault();
        onFirst === null || onFirst === void 0 ? void 0 : onFirst(e, indexRef.current);
        moveToFirst();
        accessModeState.setAccessMode('keyboard');
    }, [
        onFirst,
        moveToFirst
    ]);
    const _onLast = React.useCallback((e)=>{
        e.preventDefault();
        onLast === null || onLast === void 0 ? void 0 : onLast(e, indexRef.current);
        moveToLast();
        accessModeState.setAccessMode('keyboard');
    }, [
        onLast,
        moveToLast
    ]);
    const _onSelectWithSpace = React.useCallback((e)=>{
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(e, indexRef.current);
    }, [
        onSelect
    ]);
    const _onSelectWithEnter = React.useCallback((e)=>{
        if (e.keyCode === 229)
        return;
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(e, indexRef.current);
    }, [
        onSelect
    ]);
    const _onExit = React.useCallback((e)=>{
        if (e.isComposing)
        return;
        onExit === null || onExit === void 0 ? void 0 : onExit(e, indexRef.current);
    }, [
        onExit
    ]);
    const keyCombinationMap = React.useMemo(()=>{
        const prevKey = direction === 'vertical' ? 'ArrowUp' : 'previous';
        const nextKey = direction === 'vertical' ? 'ArrowDown' : 'next';
        const map = [
            [
                prevKey,
                _onPrev
            ],
            [
                nextKey,
                _onNext
            ],
            [
                ' ',
                _onSelectWithSpace
            ],
            [
                'Enter',
                _onSelectWithEnter
            ],
            [
                'Escape',
                _onExit
            ],
            [
                'Tab',
                _onExit
            ],
            [
                shift('Tab'),
                _onExit
            ]
        ];
        if (extraNavigation) map.push([
            'Home',
            _onFirst
        ], [
            option(prevKey),
            _onFirst
        ], [
            command(prevKey),
            _onFirst
        ], [
            'End',
            _onLast
        ], [
            option(nextKey),
            _onLast
        ], [
            command(nextKey),
            _onLast
        ]);
        return map;
    }, [
        direction,
        extraNavigation,
        _onPrev,
        _onNext,
        _onFirst,
        _onLast,
        _onSelectWithEnter,
        _onSelectWithSpace,
        _onExit
    ]);
    const { ref } = useKeyCombinationHandler(keyCombinationMap, {
        handleInputs
    });
    return {
        ref,
        index,
        moveTo,
        moveToFirst,
        moveToLast
    };
}
