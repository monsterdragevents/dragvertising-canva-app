import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import * as React from 'react';
import styles from './base_select.css';
import { BaseSelectMessages } from './base_select.messages';
export function useTruncatedList(
    { items, joiner = ', ', renderOverflowText = (overflow)=>BaseSelectMessages.hiddenOptions(overflow) }
) {
    const containerRef = React.useRef(null);
    const itemsTextRef = React.useRef(null);
    const overflowTextRef = React.useRef(null);
    const [itemsText, setItemsText] = React.useState('');
    const [overflowText, setOverflowText] = React.useState('');
    React.useLayoutEffect(()=>{
        const containerEl = containerRef.current;
        const itemsTextEl = itemsTextRef.current;
        const overflowTextEl = overflowTextRef.current;
        if (containerEl == null || itemsTextEl == null || overflowTextEl == null) return;
        const overflow = items.length - 1;
        let overflowText = overflow ? renderOverflowText(overflow) : '';
        let itemsText = `${items[0]}${overflow > 0 ? joiner : ''}`;
        const maxWidth = containerEl.offsetWidth;
        for (let i = 1; i < items.length; i++) {
            const testRenderedCount = i + 1;
            const testOverflow = items.length - testRenderedCount;
            const testOverflowText = testOverflow ? renderOverflowText(testOverflow) : '';
            const testItemsText = `${items.slice(0, testRenderedCount).join(joiner)}${testOverflow > 0 ? joiner : ''}`;
            const currentOverflowText = overflowTextEl.textContent;
            const currentItemsText = itemsTextEl.textContent;
            overflowTextEl.textContent = testOverflowText;
            itemsTextEl.textContent = testItemsText;
            const textWidth = itemsTextEl.offsetWidth + overflowTextEl.offsetWidth;
            if (textWidth > maxWidth) {
                overflowTextEl.textContent = currentOverflowText;
                itemsTextEl.textContent = currentItemsText;
                break;
            }
            itemsText = testItemsText;
            overflowText = testOverflowText;
        }
        setItemsText(itemsText);
        setOverflowText(overflowText);
    }, [
        items,
        joiner,
        renderOverflowText
    ]);
    return {
        containerRef,
        itemsTextRef,
        overflowTextRef,
        itemsText,
        overflowText
    };
}
export const TruncatedList = React.memo(({ items, joiner, renderOverflowText, tagName: TagName = 'span' })=>{
    const { containerRef, itemsTextRef, overflowTextRef, itemsText, overflowText } = useTruncatedList({
        items,
        joiner,
        renderOverflowText
    });
    return _jsxs(TagName, {
        ref: containerRef,
        className: styles.truncatedList,
        children: [
            _jsx("span", {
                className: styles.renderedText,
                children: _jsx("span", {
                    ref: itemsTextRef,
                    children: itemsText
                })
            }),
            _jsx("span", {
                className: styles.remainingText,
                children: _jsx("span", {
                    ref: overflowTextRef,
                    children: overflowText
                })
            })
        ]
    });
}, (prevProps, nextProps)=>{
    return prevProps.items.length === nextProps.items.length && prevProps.items.every((item, index)=>item === nextProps.items[index]);
});
