import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import { exists } from '../../../../../base/exists';
import { UnreachableError } from '../../../../../base/preconditions';
import classNames from 'classnames';
import { action } from 'mobx';
import { observer, useLocalObservable } from 'mobx-react-lite';
import * as React from 'react';
import { accessModeState } from '../../../a11y/access_mode_state/access_mode_state';
import { useIsHoveringInput } from '../../../a11y/pointer_input_state/pointer_input_state';
import { useControllableValue } from '../../../controllable_value/controllable_value';
import { isVirtualKeyboard } from '../../../device_capabilities/device_capabilities';
import { BaseInputContextProvider, useCreateInputControls, usePropOverrides } from '../../internal/input';
import { CalendarIcon } from '../../../icons/calendar/icon';
import { CreditCardBackIcon } from '../../../icons/credit_card_back/icon';
import { CreditCardFrontIcon } from '../../../icons/credit_card_front/icon';
import { EnvelopeIcon } from '../../../icons/envelope/icon';
import { LinkIcon } from '../../../icons/link/icon';
import { LocationIcon } from '../../../icons/location/icon';
import { SearchIcon } from '../../../icons/search/icon';
import { UserIcon } from '../../../icons/user/icon';
import { Spacer } from '../../../layout/layout';
import styles from './base_input.css';
function getLegacyIcon({ icon, iconClassName }, position) {
    return (icon === null || icon === void 0 ? void 0 : icon.align) === position && _jsx(Icon, {
        ...icon,
        className: iconClassName
    });
}
function getDecoration(decoration) {
    const content = typeof decoration === 'function' ? decoration() : decoration;
    return content ? _jsx("div", {
        className: styles.decoration,
        children: React.isValidElement(content) && content.type === React.Fragment ? React.Children.toArray(content.props.children).filter(exists).map(addLeadingSpace) : content
    }) : undefined;
}
function addLeadingSpace(child, index) {
    return index === 0 ? child : [
        _jsx(Spacer, {
            size: "0.5u"
        }, index),
        child
    ];
}
export function useFocusState() {
    const store = useLocalObservable(()=>({
            isFocused: false,
            setFocused: action((value)=>store.isFocused = value)
        }));
    return {
        isFocused: store.isFocused,
        isKeyboardMode: accessModeState.isKeyboardMode,
        setFocused: store.setFocused
    };
}
export function useOnWrapperMouseDown() {
    const ref = React.useRef(null);
    const onMouseDown = React.useCallback((e)=>{
        var _ref_current;
        let el = e.target;
        while(el && el !== e.currentTarget){
            if (isInteractive(el)) return;
            el = el.parentElement;
        }
        e.stopPropagation();
        e.preventDefault();
        (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();
    }, []);
    return {
        ref,
        onMouseDown
    };
}
function isInteractive(el) {
    return el.tagName === 'A' || el.tagName === 'BUTTON' || el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.getAttribute('tabIndex') != null;
}
export const BaseInput = observer(React.forwardRef(function BaseInput(props_, forwardedRef) {
    const { props, setPropOverrides } = usePropOverrides(props_);
    const { blurOnEnterKeyDown, onChange: onChangeProp, onFocus: onFocusProp, onBlur: onBlurProp, onKeyDown: onKeyDownProp, onChangeComplete: onChangeCompleteProp } = props;
    const wrapperRef = React.useRef(null);
    const { ref: inputRef, onMouseDown: onWrapperMouseDown } = useOnWrapperMouseDown();
    const { isFocused, isKeyboardMode, setFocused } = useFocusState();
    var _props_defaultValue;
    const [value, setValue] = useControllableValue({
        value: props.value,
        defaultValue: (_props_defaultValue = props.defaultValue) !== null && _props_defaultValue !== void 0 ? _props_defaultValue : ''
    });
    var _props_start;
    const startDecoration = getDecoration((_props_start = props.start) !== null && _props_start !== void 0 ? _props_start : getLegacyIcon(props, 'start'));
    var _props_end;
    const endDecoration = getDecoration((_props_end = props.end) !== null && _props_end !== void 0 ? _props_end : getLegacyIcon(props, 'end'));
    const controls = useCreateInputControls({
        focus: ()=>{
            var _inputRef_current;
            return (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();
        },
        setType: (type)=>setPropOverrides(type ? {
                type
            } : undefined),
        setDisabled: (disabled)=>setPropOverrides({
                disabled
            }),
        setValue: (value)=>{
            setValue(value);
            onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(value);
        }
    });
    const onChange = React.useCallback((e)=>{
        setValue(e.target.value);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(e.target.value, e);
    }, [
        onChangeProp,
        setValue
    ]);
    const onFocus = React.useCallback((e)=>{
        onFocusProp === null || onFocusProp === void 0 ? void 0 : onFocusProp(e);
        setFocused(true);
    }, [
        onFocusProp,
        setFocused
    ]);
    const onBlur = React.useCallback((e)=>{
        onBlurProp === null || onBlurProp === void 0 ? void 0 : onBlurProp(e);
        onChangeCompleteProp === null || onChangeCompleteProp === void 0 ? void 0 : onChangeCompleteProp(e.target.value);
        setFocused(false);
    }, [
        onBlurProp,
        onChangeCompleteProp,
        setFocused
    ]);
    const onKeyDown = React.useCallback((e)=>{
        var _wrapperRef_current;
        if (e.keyCode === 229) {
            e.stopPropagation();
            return;
        }
        if (e.key === 'Enter' && blurOnEnterKeyDown) (_wrapperRef_current = wrapperRef.current) === null || _wrapperRef_current === void 0 ? void 0 : _wrapperRef_current.focus();
        onKeyDownProp === null || onKeyDownProp === void 0 ? void 0 : onKeyDownProp(e);
        if (!blurOnEnterKeyDown && e.key === 'Enter')
            onChangeCompleteProp === null || onChangeCompleteProp === void 0 ? void 0 : onChangeCompleteProp(e.currentTarget.value);
    }, [
        onKeyDownProp,
        onChangeCompleteProp,
        blurOnEnterKeyDown,
        wrapperRef
    ]);
    const hoverSupported = useIsHoveringInput();
    const wrapperClassName = classNames(styles.wrapper, styles.singleLineWrapper, {
        [styles.hoverSupported]: hoverSupported,
        [styles.focusOutline]: isFocused && isKeyboardMode,
        [styles.borderless]: props.borderless,
        [styles.withStartDecoration]: startDecoration != null,
        [styles.withEndDecoration]: endDecoration != null
    }, props.disabled && styles.disabled || isFocused && styles.active || props.error && styles.error, props.className);
    const inputClassName = classNames(styles.textField, styles.singleLineTextField, {
        [styles.textAlignCenter]: props.textAlignCenter,
        [styles.noAutocomplete]: props.autoComplete === 'off'
    }, props.inputClassName);
    return (_jsx("div", {
            ref: wrapperRef,
            tabIndex: blurOnEnterKeyDown ? -1 : undefined,
            className: wrapperClassName,
            onMouseDown: onWrapperMouseDown,
            children: _jsxs(BaseInputContextProvider, {
                controls: controls,
                value: value,
                children: [
                    startDecoration,
                    _jsx("input", {
                        id: props.id,
                        className: inputClassName,
                        value: value,
                        onChange: onChange,
                        onFocus: onFocus,
                        onBlur: onBlur,
                        onKeyDown: onKeyDown,
                        onClick: props.onClick,
                        onMouseDown: props.onMouseDown,
                        onMouseUp: props.onMouseUp,
                        onContextMenu: props.onContextMenu,
                        onPaste: props.onPaste,
                        onKeyUp: props.onKeyUp,
                        ref: composeRefs(inputRef, forwardedRef),
                        dir: "auto",
                        spellCheck: props.disableSpellcheck ? false : undefined,
                        type: props.type,
                        inputMode: props.inputMode,
                        autoCapitalize: props.autoCapitalize,
                        autoCorrect: props.autoCorrect,
                        pattern: props.pattern,
                        autoFocus: props.autoFocus === 'always' || props.autoFocus === 'on-desktop' && !isVirtualKeyboard(),
                        autoComplete: props.autoComplete,
                        disabled: props.disabled,
                        readOnly: props.readOnly,
                        maxLength: props.maxLength,
                        max: props.max,
                        min: props.min,
                        placeholder: props.placeholder,
                        step: props.step,
                        name: props.name,
                        role: props.role,
                        enterKeyHint: props.enterKeyHint,
                        "aria-roledescription": props.ariaRoleDescription,
                        "aria-required": props.required || undefined,
                        "aria-invalid": props.error || undefined,
                        "aria-label": props.ariaLabel,
                        "aria-labelledby": props.ariaLabelledBy,
                        "aria-describedby": props.ariaDescribedBy,
                        "aria-autocomplete": props.ariaAutoComplete,
                        "aria-activedescendant": props.ariaActiveDescendant,
                        "aria-controls": props.ariaControls,
                        "aria-expanded": props.ariaExpanded,
                        "aria-haspopup": props.ariaHasPopup,
                        "aria-valuenow": props.ariaValueNow,
                        "aria-valuetext": props.ariaValueText,
                        "aria-valuemin": props.ariaValueMin,
                        "aria-valuemax": props.ariaValueMax
                    }),
                    endDecoration
                ]
            })
        }));
}));
function Icon({ type, className }) {
    const props = {
        size: 'medium',
        tone: 'primary',
        className
    };
    switch(type){
        case 'credit-card':
            return _jsx(CreditCardFrontIcon, {
                ...props
            });
        case 'credit-card-expiry':
            return _jsx(CalendarIcon, {
                ...props
            });
        case 'credit-card-verification':
            return _jsx(CreditCardBackIcon, {
                ...props
            });
        case 'email':
            return _jsx(EnvelopeIcon, {
                ...props
            });
        case 'link':
            return _jsx(LinkIcon, {
                ...props
            });
        case 'location':
            return _jsx(LocationIcon, {
                ...props
            });
        case 'person':
            return _jsx(UserIcon, {
                ...props
            });
        case 'search':
            return _jsx(SearchIcon, {
                ...props
            });
        default:
            throw new UnreachableError(type);
    }
}
