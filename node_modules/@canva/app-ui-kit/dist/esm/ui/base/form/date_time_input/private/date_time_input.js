import { jsx as _jsx } from "react/jsx-runtime";
import classNames from 'classnames';
import * as React from 'react';
import { dateObjToDateString, getTimezoneOffset, toLocalDateTimeObject, toUTCDateTimeObject } from '../../../date_time/utils/utils';
import { isVirtualKeyboard } from '../../../device_capabilities/device_capabilities';
import { BaseInput } from '../../base_input/base_input';
import styles from './date_time_input.css';
import { toDateObj, toDateString, toTimezoneDateTimeString, toUTCDateTimeObj } from './utils';
const globalNavigator = typeof navigator !== 'undefined' ? navigator : undefined;
export const DateTimeInput = React.memo(React.forwardRef(
    function DateTimeInput({ value: valueProp, onClick: onClickProp, onChange: onChangeProp, onChangeComplete: onChangeCompleteProp, min: minProp, max: maxProp, className, end, timezone: timezoneProp, mode, ...passThroughProps }, ref) {
        const disableNativeControls = !isVirtualKeyboard();
        const isFirefox = useIsFirefox();
        const onClick = React.useCallback((e)=>{
            if (disableNativeControls) e.preventDefault();
            onClickProp === null || onClickProp === void 0 ? void 0 : onClickProp(e);
        }, [
            disableNativeControls,
            onClickProp
        ]);
        const onChange = React.useCallback((text)=>{
            const dateInTimezone = text === '' ? undefined : text;
            if (dateInTimezone == null) return onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(dateInTimezone);
            if (mode === 'date') return onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(toDateObj(dateInTimezone));
            var _timezoneProp_offset;
            const timezoneOffset = (_timezoneProp_offset = timezoneProp === null || timezoneProp === void 0 ? void 0 : timezoneProp.offset) !== null && _timezoneProp_offset !== void 0 ? _timezoneProp_offset : getTimezoneOffset(dateInTimezone);
            const utcValue = toUTCDateTimeObj(dateInTimezone, timezoneOffset);
            onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(utcValue);
        }, [
            mode,
            onChangeProp,
            timezoneProp === null || timezoneProp === void 0 ? void 0 : timezoneProp.offset
        ]);
        const onChangeComplete = React.useCallback((text)=>{
            const dateInTimezone = text === '' ? undefined : text;
            if (dateInTimezone == null) return onChangeCompleteProp === null || onChangeCompleteProp === void 0 ? void 0 : onChangeCompleteProp(dateInTimezone);
            if (mode === 'date') return onChangeCompleteProp === null || onChangeCompleteProp === void 0 ? void 0 : onChangeCompleteProp(toDateObj(dateInTimezone));
            var _timezoneProp_offset;
            const timezoneOffset = (_timezoneProp_offset = timezoneProp === null || timezoneProp === void 0 ? void 0 : timezoneProp.offset) !== null && _timezoneProp_offset !== void 0 ? _timezoneProp_offset : getTimezoneOffset(dateInTimezone);
            const utcValue = toUTCDateTimeObj(dateInTimezone, timezoneOffset);
            onChangeCompleteProp === null || onChangeCompleteProp === void 0 ? void 0 : onChangeCompleteProp(utcValue);
        }, [
            mode,
            onChangeCompleteProp,
            timezoneProp === null || timezoneProp === void 0 ? void 0 : timezoneProp.offset
        ]);
        const pickerOnChange = React.useCallback((utcDateTime)=>{
            if (utcDateTime == null) return onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(utcDateTime);
            const dateTimeObj = toUTCDateTimeObject(utcDateTime);
            if (mode === 'date') {
                const { year, month, day } = dateTimeObj;
                onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp({
                    year,
                    month,
                    day
                });
            } else onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(dateTimeObj);
        }, [
            mode,
            onChangeProp
        ]);
        const pickerOnChangeComplete = React.useCallback((utcDateTime)=>{
            if (utcDateTime == null) return onChangeCompleteProp === null || onChangeCompleteProp === void 0 ? void 0 : onChangeCompleteProp(utcDateTime);
            const dateTimeObj = toUTCDateTimeObject(utcDateTime);
            if (mode === 'date') {
                const { year, month, day } = dateTimeObj;
                onChangeCompleteProp === null || onChangeCompleteProp === void 0 ? void 0 : onChangeCompleteProp({
                    year,
                    month,
                    day
                });
            } else onChangeCompleteProp === null || onChangeCompleteProp === void 0 ? void 0 : onChangeCompleteProp(dateTimeObj);
        }, [
            mode,
            onChangeCompleteProp
        ]);
        const now = new Date();
        const timezone = mode === 'date' ? {
            offset: 0,
            label: 'GMT'
        } : timezoneProp;
        var _timezone_offset;
        const timezoneOffset = (_timezone_offset = timezone === null || timezone === void 0 ? void 0 : timezone.offset) !== null && _timezone_offset !== void 0 ? _timezone_offset : getTimezoneOffset(valueProp !== null && valueProp !== void 0 ? valueProp : now);
        let value, min, max, utcValue, utcMin, utcMax;
        if (mode === 'date') {
            const minDate = minProp === 'today' ? toLocalDateTimeObject(now) : minProp;
            value = utcValue = toDateString(valueProp);
            min = toDateString(minDate);
            utcMin = minProp === 'today' ? minProp : min;
            max = utcMax = toDateString(maxProp);
        } else {
            const minDate = minProp === 'today' ? {
                ...toLocalDateTimeObject(now),
                hours: 0,
                minutes: 0
            } : minProp;
            value = toTimezoneDateTimeString(valueProp, timezoneOffset);
            min = toTimezoneDateTimeString(minDate, timezoneOffset);
            max = toTimezoneDateTimeString(maxProp, timezoneOffset);
            utcValue = toTimezoneDateTimeString(valueProp, 0);
            utcMin = minProp === 'today' ? minProp : toTimezoneDateTimeString(minDate, 0);
            utcMax = toTimezoneDateTimeString(maxProp, 0);
        }
        const { year, month, day } = toLocalDateTimeObject(now);
        const todayLocalDate = dateObjToDateString({
            year,
            month,
            day
        });
        const dateTimePickerDecoratorProps = {
            mode,
            timezone,
            animate: true,
            date: utcValue,
            today: mode === 'date' ? todayLocalDate : undefined,
            minSelectableDate: utcMin,
            maxSelectableDate: utcMax,
            onChange: pickerOnChange,
            onChangeComplete: pickerOnChangeComplete,
            disabled: passThroughProps.disabled || passThroughProps.readOnly
        };
        const renderEnd = ()=>{
            return typeof end === 'function' ? end(dateTimePickerDecoratorProps) : end;
        };
        return _jsx(BaseInput, {
            ...passThroughProps,
            type: mode === 'date' ? 'date' : 'datetime-local',
            ref: ref,
            value: value !== null && value !== void 0 ? value : '',
            onChange: onChange,
            onChangeComplete: onChangeComplete,
            min: min,
            max: max,
            onClick: onClick,
            end: disableNativeControls ? renderEnd() : undefined,
            className: classNames(styles.dateTimeInput, className),
            inputClassName: classNames(isFirefox && styles.clipNativeControls),
            placeholder: mode === 'date' ? 'YYYY-MM-DD' : 'YYYY-MM-DDTHH:mm'
        });
    }
));
DateTimeInput.displayName = 'DateTimeInput';
function useIsFirefox() {
    const [isFirefox, setIsFirefox] = React.useState(false);
    React.useLayoutEffect(()=>{
        setIsFirefox(globalNavigator != null && /Firefox/i.test(globalNavigator.userAgent));
    }, []);
    return isFirefox;
}
