function applyDecs2203RFactory() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = applyDecs2203RFactory())(targetClass, memberDecs, classDecs, parentClass);
}
function _identity(x) {
    return x;
}
var _class;
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
var _initClass, _React_Component;
import { makeObservable } from '../../../../../base/make_observable/make_observable';
import { observerForClass } from '../../../../../base/mobx_react/observer_for_class';
import classNames from 'classnames';
import { action, observable, toJS } from 'mobx';
import { Observer } from 'mobx-react-lite';
import * as React from 'react';
import { accessModeState } from '../../../a11y/access_mode_state/access_mode_state';
import { ScreenReaderContent } from '../../../a11y/screen_reader_content/screen_reader_content';
import { Button } from '../../../button/button';
import { isVirtualKeyboard } from '../../../device_capabilities/device_capabilities';
import { AnimatedSpinnerIcon } from '../../../icons/animated_spinner/icon';
import { ClearIcon } from '../../../icons/clear/icon';
import { shift, WithKeyCombinationHandler } from '../../../key_combinations/key_combinations';
import { Scrollable } from '../../../scrollable/scrollable';
import { InputPill } from './input_pill';
import styles, { customProperties } from './pills_input.css';
import { PillInputMessages } from './pills_input.messages';
const DEFAULT_ADD_PILL_KEYS = [
    'Enter'
];
class DynamicSizeInput extends React.Component {
    render() {
        const onChange = this.props.disabled ? undefined : this.onChange;
        const onPaste = this.props.disabled ? undefined : this.props.onPaste;
        const inputClassName = classNames(styles.input, {
            [styles.disabled]: this.props.disabled
        });
        const addPillKeyCombinations = this.props.addPillKeyCombinations || DEFAULT_ADD_PILL_KEYS;
        const addPillKeyMap = addPillKeyCombinations.map((key)=>[
                key,
                this.onPillAdd,
                {
                    ignoreKeyboardLayout: false
                }
            ]);
        const keyMap = [
            [
                'Backspace',
                this.onBackspace,
                {
                    ignoreKeyboardLayout: false
                }
            ],
            [shift('Backspace'), this.onBackspace, {
                ignoreKeyboardLayout: false
            }],
            ...addPillKeyMap
        ];
        return _jsx(WithKeyCombinationHandler, {
            map: keyMap,
            handleInputs: true,
            children: ({ ref })=>_jsx(Observer, {
                    children: ()=>_jsxs("div", {
                            ref: ref,
                            className: classNames(styles.dynamicSizeInput, {
                                [styles.fitContentWidth]: !this.props.value
                            }),
                            children: [
                                _jsx("input", {
                                    className: inputClassName,
                                    type: "text",
                                    ref: this.props.inputRef,
                                    autoFocus: this.props.autoFocus === 'always' || this.props.autoFocus === 'on-desktop' && !isVirtualKeyboard(),
                                    autoCorrect: "off",
                                    value: this.props.value,
                                    disabled: this.props.disabled,
                                    placeholder: this.props.placeholder,
                                    maxLength: this.props.maxLength,
                                    onChange: onChange,
                                    onPaste: onPaste,
                                    onBlur: this.props.onBlur,
                                    onFocus: this.props.onFocus,
                                    id: this.props.id,
                                    inputMode: this.props.inputMode,
                                    "aria-label": this.props.ariaLabel,
                                    "aria-autocomplete": this.props.ariaAutocomplete,
                                    "aria-controls": this.props.ariaControls,
                                    "aria-labelledby": this.props.ariaLabelledBy,
                                    "aria-describedby": this.props.ariaDescribedBy,
                                    "aria-expanded": this.props.ariaExpanded,
                                    "aria-haspopup": this.props.ariaHasPopup,
                                    "aria-owns": this.props.ariaOwns,
                                    "aria-activedescendant": this.props.ariaActiveDescendant,
                                    role: this.props.role
                                }),
                                _jsx("div", {
                                    className: styles.hiddenInput,
                                    "aria-hidden": "true",
                                    children: this.props.value || this.props.placeholder
                                })
                            ]
                        })
                })
        });
    }
    constructor(...args){
        super(...args), this.onBackspace = ()=>{
            if (!this.props.value && this.props.onLastPillRemove) this.props.onLastPillRemove();
        }, this.onPillAdd = (event)=>{
            var _this_props_onPillAdd, _this_props;
            if (event.keyCode === 229)
                return;
            event.preventDefault();
            const value = this.props.value.trim();
            if (value) (_this_props_onPillAdd = (_this_props = this.props).onPillAdd) === null || _this_props_onPillAdd === void 0 ? void 0 : _this_props_onPillAdd.call(_this_props, value);
        }, this.focus = ()=>{
            const { inputRef } = this.props;
            if (inputRef.current) inputRef.current.focus();
        }, this.setCursorAtTheEnd = ()=>{
            const { inputRef, value } = this.props;
            if (inputRef.current) inputRef.current.setSelectionRange(value.length, value.length);
        }, this.onChange = (event)=>{
            if (this.props.onInputChange) this.props.onInputChange(event.currentTarget.value);
        };
    }
}
let _PillsInput;
new (_class = class extends _identity {
    constructor(){
        super(_PillsInput), _initClass();
    }
}, (()=>{
    class PillsInput extends (_React_Component = React.Component) {
        static _makeObservable(instance) {
            makeObservable(instance, {
                srStatusStrings: observable.ref,
                isFocused: observable.ref,
                componentDidUpdate: action
            });
        }
        componentDidUpdate(prevProps) {
            const prevValue = toJS(prevProps.value).map((item)=>item.value);
            const currentValue = toJS(this.props.value).map((item)=>item.value);
            const itemsAdded = currentValue.filter((item)=>!prevValue.includes(item));
            const itemsRemoved = prevValue.filter((item)=>!currentValue.includes(item));
            if (!itemsAdded.length && !itemsRemoved.length)
            return;
            if (prevProps.inputValue === this.props.inputValue && !this.state.isPastingText)
            this.srStatusStrings = [];
            this.state.isPastingText = false;
            if (itemsAdded.length > 0) {
                const prevValues = prevProps.value.map((i)=>i.value);
                const newValues = itemsAdded.filter((value)=>!this.valueExists(value, prevValues));
                this.srStatusStrings = [
                    PillInputMessages.itemsAdded(newValues.join(PillInputMessages.itemsSeparator())),
                    ...this.srStatusStrings
                ];
            }
            if (itemsRemoved.length > 0) {
                if (currentValue.length === 0 && prevValue.length > 1)
                this.srStatusStrings = [
                    PillInputMessages.itemsCleared()
                ];
                else
                this.srStatusStrings = [
                    PillInputMessages.itemsRemoved(itemsRemoved.join(PillInputMessages.itemsSeparator())),
                    ...this.srStatusStrings
                ];
            }
        }
        render() {
            const { value: items, inputValue, disabled, borderless = false, error = false, placeholder, additionalPlaceholder, autoFocus, maxLength, minRows, maxRows, maxPillWidth, addPillKeyCombinations, onLastPillRemove, onInputChange, onClick, onFocus, ariaLabel, id, role, inputMode, ariaControls, ariaLabelledBy, ariaDescribedBy, ariaExpanded, ariaHasPopup, ariaOwns, ariaAutocomplete, ariaActiveDescendant } = this.props;
            const inputProps = {
                value: inputValue,
                onLastPillRemove,
                onInputChange,
                addPillKeyCombinations,
                autoFocus,
                maxLength,
                ariaLabel,
                disabled,
                onFocus,
                id,
                role,
                inputMode,
                ariaControls,
                ariaLabelledBy,
                ariaDescribedBy,
                ariaExpanded,
                ariaHasPopup,
                ariaOwns,
                ariaAutocomplete,
                ariaActiveDescendant
            };
            const containerClassName = classNames(styles.multiSearchInput, {
                [styles.disabled]: disabled,
                [styles.borders]: !borderless,
                [styles.focused]: this.isFocused && !disabled,
                [styles.keyboardMode]: accessModeState.isKeyboardMode,
                [styles.error]: error
            });
            const content = _jsxs("div", {
                className: classNames(styles.inputContainer, this.props.searchIcon && styles.withSearchIcon, this.shouldRenderClearButton() && styles.withClearButton),
                onClick: onClick,
                style: {
                    [customProperties.minRows]: minRows,
                    [customProperties.maxRows]: maxRows
                },
                children: [
                    items.map((item, i)=>{
                        const ItemIcon = item.icon;
                        return _jsx("div", {
                            className: styles.pill,
                            children: _jsx(InputPill, {
                                tone: this.getPillTone(item.state),
                                disabled: disabled,
                                text: item.value,
                                start: item.isLoading ? _jsx(AnimatedSpinnerIcon, {
                                    size: "small"
                                }) : ItemIcon && _jsx(ItemIcon, {
                                    size: "small"
                                }),
                                maxWidth: maxPillWidth,
                                onRemoveClick: item.onRemoveClick
                            })
                        }, i);
                    }),
                    _jsx(DynamicSizeInput, {
                        ...inputProps,
                        onPillAdd: this.onPillAdd,
                        onFocus: this.onFocus,
                        onBlur: this.onBlur,
                        onPaste: this.onPaste,
                        placeholder: !items.length ? placeholder : additionalPlaceholder,
                        ref: this.dynamicSizeInputRef,
                        inputRef: this.inputRef
                    })
                ]
            });
            return (_jsxs("div", {
                    className: containerClassName,
                    onMouseDown: this.onMouseDown,
                    children: [
                        this.props.searchIcon && _jsx("div", {
                            className: styles.searchIcon,
                            children: _jsx(this.props.searchIcon, {
                                size: "medium"
                            })
                        }),
                        maxRows ? _jsx(Scrollable, {
                            children: content
                        }) : content,
                        this.props.loading || this.shouldRenderClearButton() ? _jsxs("div", {
                            className: styles.end,
                            children: [
                                this.props.loading && _jsx(AnimatedSpinnerIcon, {
                                    size: "medium",
                                    tone: "tertiary",
                                    className: styles.loadingIcon
                                }),
                                this.maybeRenderClearIcon()
                            ]
                        }) : null,
                        _jsx(ScreenReaderContent, {
                            role: "status",
                            ariaLive: "polite",
                            children: this.srStatusStrings.join(' ')
                        })
                    ]
                }));
        }
        renderClearIcon() {
            return _jsx(ClearIcon, {
                size: "medium",
                tone: "tertiary"
            });
        }
        shouldRenderClearButton() {
            const { disabled, value, onClearClick, inputValue } = this.props;
            return Boolean(!disabled && (value.length > 0 || inputValue) && onClearClick);
        }
        maybeRenderClearIcon() {
            if (!this.shouldRenderClearButton()) return null;
            return _jsx(Button, {
                variant: "tertiary",
                onClick: this.props.onClearClick,
                icon: this.renderClearIcon,
                size: "small",
                ariaLabel: PillInputMessages.removeAll()
            });
        }
        constructor(...args){
            super(...args), this.dynamicSizeInputRef = (_PillsInput._makeObservable(this), React.createRef()), this.inputRef = React.createRef(), this.srStatusStrings = [], this.isFocused = false, this.onMouseDown = action((event)=>{
                var _this_inputRef_current;
                if (!this.dynamicSizeInputRef.current) return;
                if (!this.isFocused) {
                    event.preventDefault();
                    this.focus();
                }
                const clickedInside =
                event.target instanceof HTMLElement && ((_this_inputRef_current = this.inputRef.current) === null || _this_inputRef_current === void 0 ? void 0 : _this_inputRef_current.contains(event.target));
                if (!clickedInside) {
                    event.preventDefault();
                    this.dynamicSizeInputRef.current.setCursorAtTheEnd();
                }
            }), this.onPillAdd = action((value)=>{
                var _this_props_delimiters;
                this.srStatusStrings = [];
                const splitValues = ((_this_props_delimiters = this.props.delimiters) === null || _this_props_delimiters === void 0 ? void 0 : _this_props_delimiters.length) ? value.split(new RegExp(`${this.props.delimiters.join('|')}`)).map((v)=>v.trim()).filter((v)=>v).reduce((acc, current)=>{
                    if (!this.valueExists(current, acc))
                        acc.push(current);
                    return acc;
                }, []) : [
                    value
                ];
                const duplicateValues = [];
                splitValues.forEach((v)=>{
                    var _this_props_onPillAdd, _this_props;
                    if (this.valueExists(v)) {
                        duplicateValues.push(v);
                        return;
                    }
                    (_this_props_onPillAdd = (_this_props = this.props).onPillAdd) === null || _this_props_onPillAdd === void 0 ? void 0 : _this_props_onPillAdd.call(_this_props, v);
                });
                if (duplicateValues.length) this.srStatusStrings = [
                    ...this.srStatusStrings,
                    PillInputMessages.itemsExists(duplicateValues.join(PillInputMessages.itemsSeparator()), duplicateValues.length)
                ];
            }), this.onFocus = action(()=>{
                var _this_props_onFocus, _this_props;
                this.isFocused = true;
                (_this_props_onFocus = (_this_props = this.props).onFocus) === null || _this_props_onFocus === void 0 ? void 0 : _this_props_onFocus.call(_this_props);
            }), this.onBlur = action(()=>{
                var _this_props_onBlur, _this_props;
                this.isFocused = false;
                (_this_props_onBlur = (_this_props = this.props).onBlur) === null || _this_props_onBlur === void 0 ? void 0 : _this_props_onBlur.call(_this_props);
            }), this.state = {
                isPastingText: false
            }, this.onPaste = action((e)=>{
                var _this_props_onPaste, _this_props, _e_clipboardData;
                (_this_props_onPaste = (_this_props = this.props).onPaste) === null || _this_props_onPaste === void 0 ? void 0 : _this_props_onPaste.call(_this_props, e);
                this.state.isPastingText = true;
                const text = (_e_clipboardData = e.clipboardData) === null || _e_clipboardData === void 0 ? void 0 : _e_clipboardData.getData('Text');
                if (this.props.delimiters && text) {
                    const regex = new RegExp(`${this.props.delimiters.join('|')}`);
                    if (text.split(regex).length > 1) {
                        this.onPillAdd(text);
                        e.preventDefault();
                    }
                }
            }), this.focus = ()=>{
                var _this_dynamicSizeInputRef_current;
                (_this_dynamicSizeInputRef_current = this.dynamicSizeInputRef.current) === null || _this_dynamicSizeInputRef_current === void 0 ? void 0 : _this_dynamicSizeInputRef_current.focus();
            }, this.getPillTone = (state)=>{
                switch(state){
                    case 'error':
                        return 'critical';
                    case 'warning':
                        return 'warn';
                    default:
                        return 'secondary';
                }
            }, this.valueExists = (value, items = this.props.value.map((i)=>i.value))=>{
                if (this.props.allowDuplicates === 'always') return false;
                else if (this.props.allowDuplicates === 'case-sensitive') return items.some((item)=>item === value);
                return items.some((item)=>item.toLowerCase() === value.toLowerCase());
            };
        }
    }
    ({ c: [_PillsInput, _initClass] } = _apply_decs_2203_r(PillsInput, [], [
        observerForClass
    ], _React_Component));
    PillsInput.defaultProps = {
        delimiters: [
            ',',
            ';',
            '\t'
        ],
        allowDuplicates: 'case-sensitive'
    };
})(), _class)();
export { _PillsInput as PillsInput };
