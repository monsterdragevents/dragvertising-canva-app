import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { observer } from 'mobx-react-lite';
import * as React from 'react';
import { Box } from '../../../box/box';
import { useControllableValue } from '../../../controllable_value/controllable_value';
import { Label } from '../../label/label';
import { NumberInput } from '../../number_input/number_input';
import { Column, Columns, Rows } from '../../../layout/layout';
import { Snap } from './bar_snap_behavior';
import { BaseSlider } from './base_slider';
import styles from './slider.css';
export const Slider = observer(function Slider({ id: idProp, min, max, snap, step, origin, value: valueProp, defaultValue, onDragStart, onDragEnd: onDragEndProp, trackColor, fillColor, label, labelSize = 'medium', ariaLabelledBy, disabled, autoFocusNumericInput, NumericInput, blurOnDragEnd, ariaLabel, ariaDescribedBy, ariaValueText, onChange: onChangeProp, onChangeComplete }) {
    const [value, setValue] = useControllableValue({
        value: valueProp,
        defaultValue
    });
    const [initialValue, setInitialValue] = React.useState(value);
    const snapBehaviour = React.useMemo(()=>snap != null ? new Snap(snap) : undefined, [
        snap
    ]);
    const onChange = React.useCallback((newValue)=>{
        setValue(newValue);
        setInitialValue(newValue);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(newValue);
    }, [
        setValue,
        onChangeProp
    ]);
    const onInputChangeComplete = React.useCallback((newValue)=>{
        try {
            onChange(newValue);
            onChangeComplete === null || onChangeComplete === void 0 ? void 0 : onChangeComplete(initialValue, newValue);
        } finally{
            setInitialValue(newValue);
        }
    }, [
        initialValue,
        setInitialValue,
        onChange,
        onChangeComplete
    ]);
    const generatedId = React.useId();
    const id = idProp || generatedId;
    const labelId = React.useId();
    const internalAriaLabelledBy = ariaLabelledBy !== null && ariaLabelledBy !== void 0 ? ariaLabelledBy : label == null ? undefined : labelId;
    const slider = _jsx(Box, {
        width: "full",
        className: styles.slider,
        children: _jsx(BaseSlider, {
            id: id,
            value: value,
            min: min,
            max: max,
            step: step,
            snap: snap,
            origin: origin,
            onChange: onChange,
            onDragStart: onDragStart,
            onDragEnd: onDragEndProp,
            snapBehavior: snapBehaviour,
            disabled: disabled,
            blurOnDragEnd: blurOnDragEnd,
            ariaLabel: ariaLabel,
            ariaLabelledBy: internalAriaLabelledBy,
            ariaDescribedBy: ariaDescribedBy,
            ariaValueText: ariaValueText,
            onChangeComplete: onChangeComplete,
            trackColor: trackColor,
            fillColor: fillColor
        })
    });
    const numberInput = _jsx(_Fragment, {
        children: NumericInput !== 'none' && _jsx(SliderNumberInput, {
            className: styles.numberInputContainer,
            inputClassName: styles.numberInput,
            value: value,
            NumericInput: NumericInput,
            min: min,
            max: max,
            step: step,
            disabled: disabled,
            autoFocus: autoFocusNumericInput,
            onChangeComplete: onInputChangeComplete,
            ariaLabel: ariaLabel,
            ariaLabelledBy: internalAriaLabelledBy,
            ariaDescribedBy: ariaDescribedBy
        })
    });
    const maybeWithNumberInput = NumericInput !== 'none' ? _jsxs(Columns, {
        spacing: "2u",
        alignY: "center",
        children: [
            _jsx(Column, {
                children: slider
            }),
            _jsx(Column, {
                width: "content",
                children: numberInput
            })
        ]
    }) : slider;
    const maybeWithLabel = label ? _jsxs(Rows, {
        align: "stretch",
        spacing: "0",
        children: [
            _jsx(Label, {
                id: labelId,
                htmlFor: id,
                size: labelSize,
                variant: "regular",
                children: label
            }),
            maybeWithNumberInput
        ]
    }) : maybeWithNumberInput;
    return _jsx(Box, {
        className: styles.container,
        children: maybeWithLabel
    });
});
class SliderNumberInput extends React.Component {
    static getDerivedStateFromProps(props, state) {
        if (props.value !== state.previousValueProp) return {
            inputStringValue: props.value == null ? '' : props.value.toString(),
            previousValueProp: props.value
        };
        return state;
    }
    render() {
        const { className, inputClassName, min, max, step, disabled, NumericInput = NumberInput, ariaLabel, ariaLabelledBy, autoFocus, ariaDescribedBy } = this.props;
        return _jsx(NumericInput, {
            className: className,
            inputClassName: inputClassName,
            value: this.state.inputStringValue,
            disabled: disabled,
            placeholder: "--",
            ariaLabel: ariaLabel,
            ariaLabelledBy: ariaLabelledBy,
            ariaDescribedBy: ariaDescribedBy,
            onChange: this.onChange,
            onChangeComplete: this.onChangeComplete,
            onBlur: this.onBlur,
            onFocus: this.onFocus,
            blurOnEnterKeyDown: true,
            min: min,
            max: max,
            step: step,
            ref: this.inlineInputRef,
            autoFocus: autoFocus
        });
    }
    constructor(props){
        super(props), this.inlineInputRef = React.createRef(), this.onChange = (_numberValue, stringValue)=>{
            if (!this.props.disabled) this.setState({
                inputStringValue: stringValue
            });
        }, this.onChangeComplete = (value)=>{
            var _this_props_onChangeComplete, _this_props;
            if (value == null || isNaN(value)) {
                this.setState({
                    inputStringValue: this.props.value == null ? '' : this.props.value.toString()
                });
                return;
            }
            this.setState({
                inputStringValue: value == null ? '' : value.toString()
            });
            (_this_props_onChangeComplete = (_this_props = this.props).onChangeComplete) === null || _this_props_onChangeComplete === void 0 ? void 0 : _this_props_onChangeComplete.call(_this_props, value);
        }, this.onFocus = ()=>{
            window.setTimeout(()=>{
                this.inlineInputRef.current && this.inlineInputRef.current.select();
            }, 0);
        }, this.onBlur = ()=>{
            const selection = window.getSelection();
            selection && selection.removeAllRanges();
        };
        this.state = {
            inputStringValue: props.value == null ? '' : props.value.toString(),
            previousValueProp: props.value
        };
    }
}
