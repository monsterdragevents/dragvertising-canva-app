import { jsx as _jsx } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import { action } from 'mobx';
import { Observer, observer } from 'mobx-react-lite';
import * as React from 'react';
import { useKeyboardNavigation } from '../../../a11y/keyboard_navigation/use_keyboard_navigation';
import { BaseInput } from '../../base_input/base_input';
import { ClearDecorator } from '../../input_decorators/input_decorators';
import { BaseSelectPresenter, BaseSelectStore } from './base_select_presenter';
import { defaultFilterFn, defaultIsSelected, deriveIdentifier, flattenOptions, normalizeOptionGroups } from './base_select_util';
import { BaseSelectMenu, StatelessBaseSelect } from './stateless_base_select';
export const BaseSelect = observer(function BaseSelect(props) {
    const { Menu = BaseSelectMenu, menu = (props)=> _jsx(Menu, {
            ...props
        }), triggerContainerRef, menuContainerRef, searchable, isSelected = defaultIsSelected, disabled, onChange, onOpen, onClose, closeOnSelection } = props;
    const [store] = React.useState(()=>{
        var _props_store;
        return (_props_store = props.store) !== null && _props_store !== void 0 ? _props_store : new BaseSelectStore();
    });
    const [presenter] = React.useState(()=>{
        var _props_presenter;
        return (_props_presenter = props.presenter) !== null && _props_presenter !== void 0 ? _props_presenter : new BaseSelectPresenter();
    });
    var _props_open;
    const open = (_props_open = props.open) !== null && _props_open !== void 0 ? _props_open : store.open;
    var _props_value;
    const value = (_props_value = props.value) !== null && _props_value !== void 0 ? _props_value : store.value;
    const { query } = store;
    const isSearchable = !!searchable;
    const { filterFn = defaultFilterFn, onInputChange, inputPlaceholder, allowClear: searchableAllowClear = 'never' } = typeof searchable === 'object' ? searchable : {};
    const optionGroups = React.useMemo(()=>{
        return normalizeOptionGroups(props.options);
    }, [
        props.options
    ]);
    const options = React.useMemo(()=>{
        if (!isSearchable || !query) return props.options;
        return optionGroups.map((optionGroup)=>{
            const filteredOptions = filterFn(query, optionGroup.options, value, isSelected);
            return {
                label: optionGroup.label,
                options: filteredOptions
            };
        }).filter((optionGroup)=>optionGroup.options.length > 0);
    }, [
        query,
        isSearchable,
        filterFn,
        optionGroups,
        props.options,
        value,
        isSelected
    ]);
    const flatOptions = React.useMemo(()=>{
        return flattenOptions(options);
    }, [
        options
    ]);
    const defaultOnSelection = React.useCallback((option, e)=>{
        if (!isSelected(option, value)) {
            presenter.setValue(store, option.value);
            onChange === null || onChange === void 0 ? void 0 : onChange(option.value, option);
        }
    }, [
        isSelected,
        value,
        presenter,
        store,
        onChange
    ]);
    var _props_onSelection;
    const onSelection = (_props_onSelection = props.onSelection) !== null && _props_onSelection !== void 0 ? _props_onSelection : defaultOnSelection;
    const openMenu = React.useCallback(()=>{
        if (!open) {
            presenter.toggle(store, true);
            onOpen === null || onOpen === void 0 ? void 0 : onOpen();
        }
    }, [
        open,
        store,
        presenter,
        onOpen
    ]);
    const closeMenu = React.useCallback(()=>{
        if (open) {
            presenter.toggle(store, false);
            onClose === null || onClose === void 0 ? void 0 : onClose();
        }
    }, [
        open,
        store,
        presenter,
        onClose
    ]);
    const initialActiveIndex = React.useRef(-1);
    const keyboardNavigation = useKeyboardNavigation(flatOptions.length, {
        handleInputs: true,
        onNext (e, index) {
            if (!open && !disabled) {
                initialActiveIndex.current = 0;
                openMenu();
            }
        },
        onPrev (e, index) {
            if (!open && !disabled) {
                initialActiveIndex.current = flatOptions.length - 1;
                openMenu();
            }
        },
        onSelect (e, index) {
            if (e.code === 'Space' && e.target instanceof HTMLInputElement && e.target.value.length > 0)
                return;
            e.preventDefault();
            if (!open) return openMenu();
            if (index === -1) return closeMenu();
            const activeOption = flatOptions[index];
            if (activeOption == null) return;
            if (activeOption.disabled) return;
            onSelection === null || onSelection === void 0 ? void 0 : onSelection(activeOption, e);
            if (closeOnSelection === true)
                return closeMenu();
            if (closeOnSelection === false) return;
            if (e.code === 'Enter') closeMenu();
        },
        onExit (e, index) {
            if (!open) return;
            if (e.code === 'Escape' && e.target instanceof HTMLInputElement)
                return;
            closeMenu();
        }
    });
    const wasOpen = React.useRef(open);
    const { moveTo } = keyboardNavigation;
    React.useLayoutEffect(()=>{
        if (open && open !== wasOpen.current) {
            if (initialActiveIndex.current === -1) {
                const firstSelectedOptionIndex = flatOptions.findIndex((option)=>isSelected(option, value));
                if (firstSelectedOptionIndex > -1) initialActiveIndex.current = firstSelectedOptionIndex;
            }
            moveTo(initialActiveIndex.current);
        }
        wasOpen.current = open;
        initialActiveIndex.current = -1;
    });
    const onItemHover = React.useCallback((option)=>{
        moveTo(flatOptions.indexOf(option));
    }, [
        flatOptions,
        moveTo
    ]);
    const onItemClick = React.useCallback((option, e)=>{
        if (option.disabled) return;
        if (closeOnSelection !== false) closeMenu();
        onSelection(option, e);
    }, [
        onSelection,
        closeMenu,
        closeOnSelection
    ]);
    const onSearchInputChange = React.useCallback((value)=>{
        onInputChange === null || onInputChange === void 0 ? void 0 : onInputChange(value);
        store.query = value.trimStart();
        moveTo(0);
    }, [
        onInputChange,
        moveTo,
        store
    ]);
    const menuWithSearchInput = (props)=>menu({
            ...props,
            header: _jsx(BaseInput, {
                type: "search",
                value: store.query,
                onChange: action(onSearchInputChange),
                placeholder: inputPlaceholder,
                icon: {
                    type: 'search',
                    align: 'start'
                },
                ariaActiveDescendant: deriveIdentifier(props.id, props.activeIndex),
                onKeyDown: (e)=>e.key === 'Tab' && e.preventDefault(),
                end: searchableAllowClear !== 'never' && _jsx(ClearDecorator, {
                    when: searchableAllowClear === 'always' ? 'always' : 'not-empty'
                })
            })
        });
    return _jsx(Observer, {
        children: ()=>_jsx(StatelessBaseSelect, {
                ...props,
                value: value,
                open: open,
                activeIndex: keyboardNavigation.index > -1 ? keyboardNavigation.index : undefined,
                onRequestClose: closeMenu,
                onRequestOpen: openMenu,
                onItemClick: onItemClick,
                onItemHover: onItemHover,
                focusOnMenu: isSearchable,
                triggerContainerRef: composeRefs(open && searchable ? null : keyboardNavigation.ref, triggerContainerRef),
                menuContainerRef: composeRefs(open && searchable ? keyboardNavigation.ref : null, menuContainerRef),
                menu: searchable ? menuWithSearchInput : menu,
                options: options,
                tooltipLabel: props.tooltipLabel,
                tooltipPlacement: props.tooltipPlacement,
                tooltipDisabled: props.tooltipDisabled
            })
    });
});
