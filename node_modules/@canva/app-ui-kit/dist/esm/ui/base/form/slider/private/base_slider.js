import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import classNames from 'classnames';
import * as React from 'react';
import Measure from 'react-measure';
import { useSheetScrollIsolation } from '../../../surface/sheet/behavior/behavior';
import { NeverSnap } from './bar_snap_behavior';
import styles, { customProperties } from './base_slider.css';
import sliderStyles, { customProperties as sliderCustomProperties } from './slider.css';
export class BaseSlider extends React.PureComponent {
    componentWillUnmount() {
        this.isDragging && this.onDragEnd();
    }
    render() {
        const { id, min, max, step, snap, value, disabled, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaValueText, trackColor, track = defaultTrack, fill = defaultFill, handle = defaultHandle } = this.props;
        return _jsx(SheetScrollIsolation, {
            children: (isolationRef)=>_jsxs("div", {
                    className: styles.root,
                    ref: isolationRef,
                    children: [
                        _jsx(Measure, {
                            offset: true,
                            onResize: this.onBarResize,
                            children: ({ measureRef })=>_jsxs("div", {
                                    className: styles.styledBarRoot,
                                    ref: measureRef,
                                    children: [
                                        track({
                                            color: trackColor,
                                            min,
                                            max,
                                            snap
                                        }),
                                        fill({
                                            disabled,
                                            trackWidth: this.state.width,
                                            startFill: this.fillCalculations.startFill,
                                            endFill: this.fillCalculations.endFill,
                                            color: this.fillCalculations.color
                                        }),
                                        _jsx("div", {
                                            className: styles.handlePositionerContainer,
                                            children: _jsx("div", {
                                                className: styles.handlePositioner,
                                                style: this.handlePositionerStyle,
                                                children: handle({
                                                    ...this.state,
                                                    disabled
                                                })
                                            })
                                        })
                                    ]
                                })
                        }),
                        _jsx(Measure, {
                            bounds: true,
                            onResize: this.onResize,
                            children: ({ measureRef })=>_jsx("input", {
                                    id: id,
                                    className: classNames(styles.hiddenSlider, {
                                        [styles.disabled]: disabled
                                    }),
                                    ref: composeRefs(measureRef, this.inputRef),
                                    type: "range",
                                    onChange: this.onChange,
                                    onKeyDown: this.onKeyDown,
                                    onKeyUp: this.onKeyUp,
                                    onFocus: this.onFocus,
                                    onBlur: this.onBlur,
                                    onMouseEnter: this.onMouseEnter,
                                    onMouseMove: this.onMouseMove,
                                    onMouseLeave: this.onMouseLeave,
                                    onTouchStart: this.onTouchStart,
                                    onTouchEnd: this.onTouchEnd,
                                    onMouseDown: this.onMouseDown,
                                    min: min,
                                    max: max,
                                    step: step,
                                    value: value,
                                    disabled: disabled,
                                    "aria-label": ariaLabel,
                                    "aria-labelledby": ariaLabelledBy,
                                    "aria-describedby": ariaDescribedBy,
                                    "aria-valuetext": ariaValueText
                                })
                        })
                    ]
                })
        });
    }
    valueAsPercent(value) {
        const range = this.props.max - this.props.min;
        const valueFromMin = this.clamp(value) - this.props.min;
        const percent = valueFromMin / range * 100;
        return percent > 99.5 ? 100 : percent;
    }
    normalizeOrigin(origin) {
        const { min, max } = this.props;
        if (origin < min) return min;
        if (origin > max) return max;
        return origin;
    }
    get fillCalculations() {
        const { min, max, origin, snap, value, trackColor, fillColor } = this.props;
        const trackWidth = this.state.width;
        const startingPoint = origin != null ? this.normalizeOrigin(origin) : snap;
        const handleWidth = parseInt(sliderStyles.handleDiameter, 10);
        const leftValue = startingPoint === undefined || startingPoint === min ? min : Math.min(startingPoint, value);
        const leftAsPercent = (leftValue - min) / (max - min) * 100;
        const startFill = leftAsPercent === 0 ? 0 : handleWidth / 2 + (trackWidth - handleWidth) * leftAsPercent / 100;
        const rightValue = startingPoint === max ? max : startingPoint === undefined ? value : Math.max(startingPoint, value);
        const rightAsPercent = (rightValue - min) / (max - min) * 100;
        const endFill = rightAsPercent === 100 ? trackWidth : handleWidth / 2 + (trackWidth - handleWidth) * rightAsPercent / 100;
        const color = fillColor !== undefined ? fillColor : trackColor !== undefined || value == null ? 'transparent' : undefined;
        return {
            startFill,
            endFill,
            color
        };
    }
    get handlePositionerPercent() {
        const { min, max, value } = this.props;
        const finalValue = value == null ? min + (max - min) / 2 : value;
        return this.valueAsPercent(finalValue);
    }
    get handlePositionerStyle() {
        const { min, max, origin, snap } = this.props;
        const startingPoint = origin != null ? this.normalizeOrigin(origin) : snap;
        const snapAsPercent = startingPoint != null ? (startingPoint - min) / (max - min) * 100 : undefined;
        if (snapAsPercent == null) return {
            width: `${this.handlePositionerPercent}%`
        };
        if (this.handlePositionerPercent >= snapAsPercent) return {
            width: `${this.handlePositionerPercent - snapAsPercent}%`,
            [customProperties.handlePositionerMargin]: `${snapAsPercent}%`
        };
        return {
            width: `${snapAsPercent - this.handlePositionerPercent}%`,
            [customProperties.handlePositionerMargin]: `${this.handlePositionerPercent}%`,
            transform: `scaleX(-1)`
        };
    }
    clamp(value) {
        return Math.min(Math.max(this.props.min, value), this.props.max);
    }
    constructor(props){
        super(props), this.inputRef = React.createRef(), this.snapBehavior = this.props.snapBehavior || new NeverSnap(), this.isDragging = false, this.keyPressed = false, this.onDragStart = (value)=>{
            var _this_props_onDragStart, _this_props;
            this.dragStartValue = this.clamp(value);
            this.isDragging = true;
            this.setState({
                active: true
            });
            (_this_props_onDragStart = (_this_props = this.props).onDragStart) === null || _this_props_onDragStart === void 0 ? void 0 : _this_props_onDragStart.call(_this_props);
        }, this.onDragEnd = (newValue)=>{
            var _this_inputRef_current, _this_props_onChangeComplete, _this_props, _this_props_onDragEnd, _this_props1;
            if (!this.isDragging) return;
            this.isDragging = false;
            this.setState({
                active: false
            });
            this.props.blurOnDragEnd && ((_this_inputRef_current = this.inputRef.current) === null || _this_inputRef_current === void 0 ? void 0 : _this_inputRef_current.blur());
            newValue != null && ((_this_props_onChangeComplete = (_this_props = this.props).onChangeComplete) === null || _this_props_onChangeComplete === void 0 ? void 0 : _this_props_onChangeComplete.call(_this_props, this.dragStartValue, newValue));
            (_this_props_onDragEnd = (_this_props1 = this.props).onDragEnd) === null || _this_props_onDragEnd === void 0 ? void 0 : _this_props_onDragEnd.call(_this_props1);
        }, this.onMouseUp = (event)=>{
            const target = event.target;
            target.removeEventListener('mouseup', this.onMouseUp);
            const value = this.clamp(parseFloat(target.value));
            this.onDragEnd(value);
        }, this.onMouseDown = (event)=>{
            const target = event.target;
            target.addEventListener('mouseup', this.onMouseUp, {
                once: true
            });
            const value = this.clamp(parseFloat(target.value));
            this.onDragStart(value);
        }, this.onTouchStart = (event)=>{
            if (event.touches.length > 1) return;
            const target = event.target;
            const value = this.clamp(parseFloat(target.value));
            this.onDragStart(value);
        }, this.onTouchEnd = (event)=>{
            if (event.touches.length > 0) return;
            const target = event.target;
            const value = this.clamp(parseFloat(target.value));
            this.onDragEnd(value);
        }, this.onResize = (contentRect)=>{
            if (contentRect.entry && contentRect.bounds) this.setState({
                leftBound: contentRect.bounds.left,
                width: contentRect.entry.width
            });
        }, this.onBarResize = (contentRect)=>{
            var _this_props_onBarResize, _this_props;
            if (contentRect.offset) (_this_props_onBarResize = (_this_props = this.props).onBarResize) === null || _this_props_onBarResize === void 0 ? void 0 : _this_props_onBarResize.call(_this_props, {
                width: contentRect.offset.width,
                start: contentRect.offset.left
            });
        }, this.onKeyDown = ()=>{
            this.keyPressed = true;
            this.snapBehavior.onKeyDown();
        }, this.onKeyUp = ()=>{
            this.keyPressed = false;
            this.snapBehavior.onKeyUp();
        }, this.onFocus = ()=>this.setState({
                focused: true
            }), this.onBlur = ()=>this.setState({
                focused: false
            }), this.onMouseEnter = ()=>this.setState({
                trackHovering: true
            }), this.onMouseMove = (e)=>{
            const handleWidth = parseInt(sliderStyles.handleDiameter, 10);
            const trackWidth = this.state.width;
            const handleOverlayDiameter = parseInt(sliderStyles.handleOverlayDiameter, 10);
            const mouseX = e.clientX - this.state.leftBound;
            const handleX = handleWidth / 2 + (trackWidth - handleWidth) * this.handlePositionerPercent / 100;
            if (mouseX >= handleX - handleOverlayDiameter / 2 && mouseX <= handleX + handleOverlayDiameter / 2) this.setState({
                handleHovering: true
            });
            else this.setState({
                handleHovering: false
            });
        }, this.onMouseLeave = ()=>this.setState({
                trackHovering: false,
                handleHovering: false
            }), this.onChange = (event)=>{
            var _this_props_onChangeComplete, _this_props;
            const newValue = this.clamp(parseFloat(event.target.value));
            const range = this.props.max - this.props.min;
            const pxPerUnit = this.state.width / range;
            this.snapBehavior.onChange(this.props, newValue, pxPerUnit);
            if (this.keyPressed) (_this_props_onChangeComplete = (_this_props = this.props).onChangeComplete) === null || _this_props_onChangeComplete === void 0 ? void 0 : _this_props_onChangeComplete.call(_this_props, this.props.value, newValue);
        };
        this.state = {
            active: false,
            focused: false,
            handleHovering: false,
            trackHovering: false,
            leftBound: 0,
            width: 0
        };
        this.dragStartValue = this.clamp(props.value);
    }
}
const defaultTrack = ({ min, max, snap, color })=>{
    const snapIndicatorBufferWidth = snap != null && `calc(${(snap - min) / (max - min) * 100}% - 0.5 * ${sliderStyles.snapIndicatorSize})`;
    return _jsxs("div", {
        className: sliderStyles.track,
        children: [
            _jsx("div", {
                className: sliderStyles.trackFill,
                style: {
                    [sliderCustomProperties.trackColor]: color
                }
            }),
            _jsx("div", {
                className: sliderStyles.startStopIndicator
            }),
            _jsx("div", {
                className: sliderStyles.endStopIndicator
            }),
            snapIndicatorBufferWidth && _jsxs("div", {
                className: sliderStyles.snapIndicatorContainer,
                children: [
                    _jsx("div", {
                        className: sliderStyles.snapIndicatorBuffer,
                        style: {
                            width: snapIndicatorBufferWidth
                        }
                    }),
                    _jsx("div", {
                        className: sliderStyles.snapIndicator
                    })
                ]
            })
        ]
    });
};
const defaultFill = ({ disabled, trackWidth, startFill, endFill, color })=>{
    return _jsx("div", {
        className: classNames(sliderStyles.fill, {
            [sliderStyles.disabled]: disabled
        }),
        style: {
            [sliderCustomProperties.fillColor]: color,
            [sliderCustomProperties.fillStart]: `${startFill}px`,
            [sliderCustomProperties.fillEnd]: `${trackWidth - endFill}px`
        }
    });
};
const defaultHandle = ({ handleHovering, trackHovering, focused, disabled })=>{
    return _jsx("div", {
        className: classNames(sliderStyles.handle, {
            [sliderStyles.focused]: !disabled && focused,
            [sliderStyles.handleHovering]: !disabled && handleHovering,
            [sliderStyles.trackHovering]: !disabled && trackHovering,
            [sliderStyles.disabled]: disabled
        })
    });
};
function SheetScrollIsolation(props) {
    const ref = useSheetScrollIsolation();
    return props.children(ref);
}
