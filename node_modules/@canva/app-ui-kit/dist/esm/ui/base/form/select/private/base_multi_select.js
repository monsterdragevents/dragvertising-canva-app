import { jsx as _jsx } from "react/jsx-runtime";
import { makeObservable } from '../../../../../base/make_observable/make_observable';
import { exists } from '../../../../../base/exists';
import * as mobx from 'mobx';
import * as React from 'react';
import { SurfaceHeaderTextButton } from '../../../surface/header/header';
import { BaseSelect } from './base_select';
import { BaseSelectMessages } from './base_select.messages';
import { BaseSelectPresenter, BaseSelectStore } from './base_select_presenter';
import { defaultAreEqual, defaultIsSelected, flattenOptions } from './base_select_util';
import { BaseSelectItem, BaseSelectTrigger } from './stateless_base_select';
const selectAllValue = Symbol();
const selectAllOption = {
    value: selectAllValue,
    label: BaseSelectMessages.selectAll()
};
export class BaseMultiSelectStore extends BaseSelectStore {
    static _makeObservable(instance) {
        makeObservable(instance, {
            value: mobx.observable.ref
        });
    }
    constructor(...args){
        super(...args), this.value = (BaseMultiSelectStore._makeObservable(this), undefined);
    }
}
export class BaseMultiSelect extends React.Component {
    get value() {
        var _this_props_value;
        return (_this_props_value = this.props.value) !== null && _this_props_value !== void 0 ? _this_props_value : this.store.value;
    }
    isAllSelected() {
        if (!this.value)
            return false;
        if (this.props.maxSelectedOptions && this.value.length >= this.props.maxSelectedOptions)
            return true;
        if (this.value.length === flattenOptions(this.props.options).length)
            return true;
        let valueWithoutDisabledOptions = this.value;
        this.getDisabledOptions().forEach((option)=>{
            valueWithoutDisabledOptions = valueWithoutDisabledOptions.filter((value)=>value !== option.value);
        });
        return Array.isArray(valueWithoutDisabledOptions) && valueWithoutDisabledOptions.length === this.getAvailableOptions().length;
    }
    getAvailableOptions() {
        return flattenOptions(this.props.options).filter((option)=>!option.disabled);
    }
    getDisabledOptions() {
        return flattenOptions(this.props.options).filter((option)=>option.disabled);
    }
    render() {
        const { showSelectAll, options, maxSelectedOptions } = this.props;
        const finalShowSelectAll = showSelectAll && (!maxSelectedOptions || maxSelectedOptions >= options.length);
        return _jsx(BaseSelect, {
            store: this.store,
            presenter: this.presenter,
            Trigger: this.Trigger,
            Item: this.Item,
            onSelection: this.onSelection,
            closeOnSelection: false,
            headerEnd: ({ mode })=>mode === 'sheet' && _jsx(SurfaceHeaderTextButton, {
                    onClick: this.closeMenu,
                    children: BaseSelectMessages.done()
                }),
            ...this.props,
            isSelected: this.isSelected,
            options: finalShowSelectAll ? [
                selectAllOption,
                ...options
            ] : options
        });
    }
    constructor(...args){
        var _this_props_store, _this_props_presenter;
        super(...args), this.store = (_this_props_store = this.props.store) !== null && _this_props_store !== void 0 ? _this_props_store : new BaseMultiSelectStore(), this.presenter = (_this_props_presenter = this.props.presenter) !== null && _this_props_presenter !== void 0 ? _this_props_presenter : new BaseSelectPresenter(), this.isSelected = (option, value)=>{
            if (option.value === selectAllValue) return this.isAllSelected();
            const { isSelected = defaultIsSelected } = this.props;
            return isSelected(option, value);
        }, this.onSelection = (option)=>{
            var _this_value, _this_props_onChange, _this_props;
            if (option.value === selectAllValue) return this.onSelectAll();
            if (option.value == null) return;
            const { isSelected = defaultIsSelected, areEqual = defaultAreEqual } = this.props;
            var _this_value_slice;
            const value = (_this_value_slice = (_this_value = this.value) === null || _this_value === void 0 ? void 0 : _this_value.slice()) !== null && _this_value_slice !== void 0 ? _this_value_slice : [];
            const newValue = isSelected(option, value) ? value.filter((v)=>!areEqual(v, option.value)) : value.concat(option.value);
            if (this.props.maxSelectedOptions && this.isAllSelected() && newValue.length > value.length)
                return;
            this.presenter.setValue(this.store, newValue);
            (_this_props_onChange = (_this_props = this.props).onChange) === null || _this_props_onChange === void 0 ? void 0 : _this_props_onChange.call(_this_props, newValue);
        }, this.onSelectAll = ()=>{
            var _this_props_onChange, _this_props;
            let newValue = this.isAllSelected() ? [] : this.getAvailableOptions().map((option)=>option.value).filter(exists);
            const disabledSelectedOptions = this.getDisabledOptions().map((option)=>this.isSelected(option, this.value) ? option.value : undefined).filter(exists);
            if (this.props.maxSelectedOptions)
                newValue = newValue.slice(0, this.props.maxSelectedOptions - disabledSelectedOptions.length);
            newValue = newValue.concat(disabledSelectedOptions);
            this.presenter.setValue(this.store, newValue);
            (_this_props_onChange = (_this_props = this.props).onChange) === null || _this_props_onChange === void 0 ? void 0 : _this_props_onChange.call(_this_props, newValue);
        }, this.closeMenu = ()=>{
            var _this_props_onClose, _this_props;
            this.presenter.toggle(this.store, false);
            (_this_props_onClose = (_this_props = this.props).onClose) === null || _this_props_onClose === void 0 ? void 0 : _this_props_onClose.call(_this_props);
        }, this.Trigger = React.memo((props)=>{
            var _props_selectedOptions;
            const { Trigger = BaseSelectTrigger } = this.props;
            const selectedOptions = (_props_selectedOptions = props.selectedOptions) === null || _props_selectedOptions === void 0 ? void 0 : _props_selectedOptions.filter((option)=>option.value !== selectAllValue);
            return _jsx(Trigger, {
                ...props,
                selectedOptions: selectedOptions
            });
        }), this.Item = React.memo((props)=>{
            return _jsx(BaseSelectItem, {
                ...props,
                multiSelectable: true
            });
        });
    }
}
