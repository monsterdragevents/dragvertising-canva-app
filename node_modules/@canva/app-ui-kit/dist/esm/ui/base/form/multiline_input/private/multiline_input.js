import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import classNames from 'classnames';
import { observer } from 'mobx-react-lite';
import * as React from 'react';
import ResizeObserver from 'resize-observer-polyfill';
import { useIsHoveringInput } from '../../../a11y/pointer_input_state/pointer_input_state';
import { useControllableValue } from '../../../controllable_value/controllable_value';
import { useFocusState, useOnWrapperMouseDown } from '../../base_input/base_input';
import inputStyles from '../../base_input/temporary_exports.css';
import { BaseInputContextProvider, useCreateInputControls, usePropOverrides } from '../../internal/input';
import { useSheetScrollIsolation } from '../../../surface/sheet/behavior/behavior';
import styles from './multiline_input.css';
const DEFAULT_BUFFER_ROWS = 1;
const DEFAULT_MAX_ROWS = Number.POSITIVE_INFINITY;
function useAutoGrow(
    { bufferRows = DEFAULT_BUFFER_ROWS, maxRows = DEFAULT_MAX_ROWS, minRows = 1, value }
) {
    const innerRef = React.useRef(null);
    const [rows, setRows] = React.useState();
    const remeasure = React.useCallback(()=>{
        const refElement = innerRef.current;
        if (!refElement) return;
        const rowHeight = refElement.clientHeight;
        const contentRows = rowHeight === 0 ? 0 : Math.round(refElement.scrollHeight / rowHeight);
        const rows = Math.min(maxRows, Math.max(minRows + bufferRows, contentRows + bufferRows));
        setRows(rows);
    }, [
        bufferRows,
        maxRows,
        minRows
    ]);
    React.useLayoutEffect(remeasure, [
        remeasure,
        value
    ]);
    const stableRemeasure = React.useRef(remeasure);
    const observerRef = React.useRef(null);
    const setRef = React.useCallback((element)=>{
        if (observerRef.current == null)
            observerRef.current = new ResizeObserver(()=>stableRemeasure.current());
        if (innerRef.current != null)
            observerRef.current.unobserve(innerRef.current);
        innerRef.current = element;
        if (innerRef.current != null) observerRef.current.observe(innerRef.current);
    }, []);
    React.useEffect(()=>{
        return ()=>{
            var _observerRef_current;
            return (_observerRef_current = observerRef.current) === null || _observerRef_current === void 0 ? void 0 : _observerRef_current.disconnect();
        };
    }, []);
    return {
        ref: setRef,
        rows
    };
}
export const MultilineInput = observer(React.forwardRef(function MultilineInput(props_, forwardedRef) {
    const { props, setPropOverrides } = usePropOverrides(props_);
    const { onChange: onChangeProp, onFocus: onFocusProp, onBlur: onBlurProp, onChangeComplete: onChangeCompleteProp, onKeyDown: onKeyDownProp, dir = 'auto' } = props;
    const { ref: inputRef, onMouseDown: onWrapperMouseDown } = useOnWrapperMouseDown();
    const { isFocused, isKeyboardMode, setFocused } = useFocusState();
    const [value, setValue] = useControllableValue({
        value: props.value
    });
    const { ref: autoGrowRef, rows } = useAutoGrow({
        ...props,
        value
    });
    const controls = useCreateInputControls({
        focus: ()=>{
            var _inputRef_current;
            return (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();
        },
        setDisabled: (disabled)=>setPropOverrides({
                disabled
            }),
        setValue: (value)=>{
            setValue(value);
            onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(value);
        }
    });
    const onChange = React.useCallback((e)=>{
        setValue(e.target.value);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(e.target.value, e);
    }, [
        onChangeProp,
        setValue
    ]);
    const onFocus = React.useCallback((e)=>{
        onFocusProp === null || onFocusProp === void 0 ? void 0 : onFocusProp(e);
        setFocused(true);
    }, [
        onFocusProp,
        setFocused
    ]);
    const onBlur = React.useCallback((e)=>{
        onBlurProp === null || onBlurProp === void 0 ? void 0 : onBlurProp(e);
        onChangeCompleteProp === null || onChangeCompleteProp === void 0 ? void 0 : onChangeCompleteProp(e.target.value);
        setFocused(false);
    }, [
        onBlurProp,
        onChangeCompleteProp,
        setFocused
    ]);
    const onKeyDown = React.useCallback((e)=>{
        if (e.keyCode === 229) {
            e.stopPropagation();
            return;
        }
        onKeyDownProp === null || onKeyDownProp === void 0 ? void 0 : onKeyDownProp(e);
    }, [
        onKeyDownProp
    ]);
    const hoverSupported = useIsHoveringInput();
    const wrapperClassName = classNames(inputStyles.wrapper, styles.multilineWrapper, {
        [inputStyles.hoverSupported]: hoverSupported,
        [inputStyles.focusOutline]: isFocused && isKeyboardMode,
        [inputStyles.borderless]: props.borderless
    }, props.disabled && inputStyles.disabled || isFocused && inputStyles.active || props.error && inputStyles.error, props.className);
    const inputClassName = classNames(inputStyles.textField, styles.multilineTextField, !props.autoGrow && props.resize && styles.resize, props.inputClassName);
    const sheetIsolationRef = useSheetScrollIsolation();
    return (_jsx("div", {
            ref: sheetIsolationRef,
            className: wrapperClassName,
            onMouseDown: onWrapperMouseDown,
            children: _jsxs(BaseInputContextProvider, {
                controls: controls,
                value: value !== null && value !== void 0 ? value : '',
                children: [
                    _jsx("textarea", {
                        className: inputClassName,
                        value: value,
                        onChange: onChange,
                        onFocus: onFocus,
                        onBlur: onBlur,
                        onKeyPress: props.onKeyPress,
                        onKeyDown: onKeyDown,
                        onKeyUp: props.onKeyUp,
                        onPaste: props.onPaste,
                        onClick: props.onClick,
                        ref: composeRefs(inputRef, forwardedRef),
                        dir: dir,
                        autoComplete: props.autoComplete,
                        disabled: props.disabled,
                        placeholder: props.placeholder,
                        maxLength: props.maxLength,
                        lang: props.lang,
                        rows: rows !== null && rows !== void 0 ? rows : props.minRows,
                        id: props.id,
                        "aria-label": props.ariaLabel,
                        "aria-labelledby": props.ariaLabelledBy,
                        "aria-describedby": props.ariaDescribedBy,
                        required: props.required,
                        readOnly: props.readOnly
                    }),
                    props.autoGrow && _jsx("textarea", {
                        "aria-hidden": "true",
                        className: classNames(inputClassName, styles.hiddenInput),
                        dir: dir,
                        ref: autoGrowRef,
                        readOnly: true,
                        rows: 1,
                        value: value
                    }),
                    props.footer
                ]
            })
        }));
}));
MultilineInput.displayName = 'MultilineInput';
