import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import composeRefs from '@seznam/compose-react-refs';
import classNames from 'classnames';
import { Observer } from 'mobx-react-lite';
import 'react';
import { memo, useCallback, useEffect, useLayoutEffect, useRef, useState } from 'react';
import ResizeObserver from 'resize-observer-polyfill';
import { BasicButton } from '../../button/button';
import { ChevronLeftIcon } from '../../icons/chevron_left/icon';
import { ChevronRightIcon } from '../../icons/chevron_right/icon';
import { getSpaceValue } from '../../metrics/metrics';
import { useDirection, useEnableAnimations } from '../../provider/provider';
import { ScrollControls } from '../../scroll_controls/scroll_controls';
import { TabsElementsProvider, useTabList, useTabsElements } from './behavior';
import styles, { customProperties } from './tab_list.css';
function scrollIntoViewHorizontally(container, child) {
    const childOffsetRight = child.offsetLeft + child.offsetWidth;
    const containerScrollRight = container.scrollLeft + container.offsetWidth;
    container.scrollLeft += childOffsetRight - containerScrollRight + (container.offsetWidth - child.offsetWidth) / 2;
}
const useTabListUnderline = ({ activeElementRef, align, spacing, children })=>{
    const ref = useRef(null);
    const layoutDirection = useDirection();
    const [underlineRect, setUnderlineRect] = useState();
    const [containerWidthHasChanged, setContainerWidthHasChanged] = useState(false);
    const prevContainerWidth = useRef(0);
    const remeasure = useCallback(()=>{
        if (activeElementRef && ref.current) {
            setUnderlineRect({
                x: (layoutDirection === 'RTL' ? activeElementRef.offsetLeft + activeElementRef.offsetWidth - ref.current.offsetWidth : activeElementRef.offsetLeft) + 'px',
                width: activeElementRef.offsetWidth + 'px'
            });
            setContainerWidthHasChanged(prevContainerWidth.current !== ref.current.offsetWidth);
            prevContainerWidth.current = ref.current.offsetWidth;
        }
    }, [activeElementRef, layoutDirection, children]);
    useLayoutEffect(()=>{
        remeasure();
    }, [
        remeasure,
        spacing,
        align
    ]);
    useEffect(()=>{
        if (ref.current) {
            const observer = new ResizeObserver(remeasure);
            observer.observe(ref.current);
            return ()=>observer.disconnect();
        }
    }, [
        ref,
        remeasure
    ]);
    useEffect(()=>{
        if (activeElementRef && ref.current) {
            scrollIntoViewHorizontally(ref.current, activeElementRef);
            const observer = new ResizeObserver(remeasure);
            observer.observe(activeElementRef);
            return ()=>observer.disconnect();
        }
    }, [
        activeElementRef,
        remeasure,
        containerWidthHasChanged
    ]);
    return {
        ref,
        underlineRect,
        containerWidthHasChanged
    };
};
const ANIMATION_DURATION = parseInt(styles.animationDuration, 10) || 0;
const TabListWithUnderline = ({ align, spacing, bleedX, animate, children, underline })=>{
    const { activeElementRef, setIsAnimating } = useTabsElements();
    const { ref, role } = useTabList();
    const { ref: underlineRef, underlineRect, containerWidthHasChanged } = useTabListUnderline({
        align,
        spacing,
        activeElementRef,
        children
    });
    const prevUnderlineRect = useRef(underlineRect);
    const animationTimeoutRef = useRef(0);
    useEffect(()=>{
        if (!setIsAnimating || !underlineRect || !animate) return;
        const prevRect = prevUnderlineRect.current;
        const rectChanged = prevRect && (prevRect.x !== underlineRect.x || prevRect.width !== underlineRect.width);
        if (rectChanged) {
            setIsAnimating(true);
            clearTimeout(animationTimeoutRef.current);
            animationTimeoutRef.current = setTimeout(()=>{
                if (setIsAnimating) setIsAnimating(false);
            }, ANIMATION_DURATION);
        }
        prevUnderlineRect.current = underlineRect;
    }, [
        setIsAnimating,
        animate,
        underlineRect
    ]);
    return _jsx(ScrollableOverflowContainer, {
        displayArrows: !!activeElementRef,
        spacing: spacing,
        bleedX: bleedX,
        children: (scrollableRef)=>_jsx("div", {
                ref: composeRefs(ref, underlineRef, scrollableRef),
                role: role,
                className: classNames(styles.tablist, {
                    [styles.animate]: animate && !containerWidthHasChanged,
                    [styles.underline]: underline === 'visible' && underlineRect !== undefined,
                    [styles.alignCenter]: align === 'center',
                    [styles.alignEnd]: align === 'end',
                    [styles.stretch]: align === 'stretch'
                }),
                style: {
                    [customProperties.underlineX]: underlineRect === null || underlineRect === void 0 ? void 0 : underlineRect.x,
                    [customProperties.underlineWidth]: underlineRect === null || underlineRect === void 0 ? void 0 : underlineRect.width,
                    [customProperties.spacing]: spacing ? getSpaceValue(spacing) : undefined
                },
                children: children
            })
    });
};
const ScrollableOverflowContainer = memo(({ displayArrows, spacing, bleedX, children })=>{
    let bleedXAmount = '0px';
    if (spacing === '0') bleedXAmount = '0px';
    else if (spacing === '1u') bleedXAmount = getSpaceValue('0.5u');
    else bleedXAmount = getSpaceValue('1u');
    return _jsx(ScrollControls, {
        children: ({ scrollableRef, scrollState, moveNext, movePrev })=>_jsx(Observer, {
                children: ()=>_jsxs("div", {
                        className: classNames(styles.scrollContainer, scrollState.atStart === false && styles.prevScrollable, scrollState.atEnd === false && styles.nextScrollable, bleedX && styles.bleed),
                        style: {
                            [customProperties.bleedX]: bleedXAmount
                        },
                        children: [
                            children(scrollableRef),
                            displayArrows && _jsxs(_Fragment, {
                                children: [
                                    _jsx(BasicButton, {
                                        expandClickableArea: true,
                                        alignment: "start",
                                        ariaHidden: true,
                                        tabIndex: -1,
                                        size: "tiny",
                                        icon: ChevronLeftIcon,
                                        iconSize: "medium",
                                        onClick: movePrev,
                                        className: classNames(styles.scrollPrevButton, !scrollState.atStart && styles.visible)
                                    }),
                                    _jsx(BasicButton, {
                                        expandClickableArea: true,
                                        alignment: "end",
                                        ariaHidden: true,
                                        tabIndex: -1,
                                        size: "tiny",
                                        icon: ChevronRightIcon,
                                        iconSize: "medium",
                                        onClick: moveNext,
                                        className: classNames(styles.scrollNextButton, !scrollState.atEnd && styles.visible)
                                    })
                                ]
                            })
                        ]
                    })
            })
    });
});
export const TabList = ({ align = 'start', spacing = '2u', animate: animateProp = true, bleedX = true, underline = 'visible', children })=>{
    const animate = useEnableAnimations() && animateProp;
    return _jsx(TabsElementsProvider, {
        children: _jsx(TabListWithUnderline, {
            align: align,
            spacing: align === 'stretch' ? '0' : spacing,
            animate: animate,
            bleedX: bleedX,
            underline: underline,
            children: children
        })
    });
};
