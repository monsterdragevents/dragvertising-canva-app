import composeRefs from '@seznam/compose-react-refs';
import { useCallback, useEffect, useLayoutEffect, useMemo, useRef, useState } from 'react';
import { accessModeState } from '../../a11y/access_mode_state/access_mode_state';
import { useKeyCombinationHandler } from '../../key_combinations/key_combinations';
import { useTabsElements } from './behavior';
const focusableElements = [
    'input:not([disabled]):not([type=hidden])',
    'select:not([disabled])',
    'textarea:not([disabled])',
    'button:not([disabled])',
    'a[href]',
    'area[href]',
    'summary',
    'iframe',
    'object',
    'embed',
    'audio[controls]',
    'video[controls]',
    '[contenteditable]'
];
const FOCUSABLE_ELEMENTS_SELECTOR = focusableElements.join(',');
function getFocusableChildren(element, onlyTabbables) {
    return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR)).filter((el)=>el instanceof HTMLElement && !el.hidden && !el.ariaHidden && (onlyTabbables === true ? el.tabIndex >= 0 : true));
}
export function useFocusableChildren(options) {
    const ref = useRef(null);
    const [focusableChildren, setFocusableChildren] = useState([]);
    const update = useCallback(()=>{
        if (!ref.current) return;
        const focusables = getFocusableChildren(ref.current, options === null || options === void 0 ? void 0 : options.onlyTabbables);
        setFocusableChildren(focusables);
    }, [
        ref,
        options === null || options === void 0 ? void 0 : options.onlyTabbables
    ]);
    useLayoutEffect(()=>{
        if (!(ref === null || ref === void 0 ? void 0 : ref.current)) return;
        update();
        const observer = new MutationObserver(update);
        observer.observe(ref.current, {
            subtree: true,
            childList: true,
            attributes: true,
            attributeFilter: [
                'tabIndex',
                'disabled'
            ]
        });
        return ()=>{
            observer.disconnect();
        };
    }, [
        update,
        ref
    ]);
    return {
        ref,
        focusableChildren
    };
}
export function useKeyboardFocusNavigation() {
    const { ref: focusableChildrenRef, focusableChildren } = useFocusableChildren();
    const { activeElementRef } = useTabsElements();
    useEffect(()=>{
        const currentFocusedIndex = document.activeElement ? focusableChildren.findIndex((x)=>x === document.activeElement) : -1;
        if (currentFocusedIndex === -1 || !activeElementRef)
        return;
        const activeIndex = focusableChildren.findIndex((x)=>x === activeElementRef);
        if (currentFocusedIndex !== activeIndex)
        activeElementRef.focus();
    }, [
        activeElementRef,
        focusableChildren
    ]);
    const moveFocusTo = useCallback((index)=>{
        accessModeState.setAccessMode('keyboard');
        const nextFocus = index < 0 ? focusableChildren[focusableChildren.length - 1] : focusableChildren[index];
        if (nextFocus) nextFocus.focus();
    }, [
        focusableChildren
    ]);
    const moveFocusBy = useCallback((increment)=>{
        const focusedIndex = focusableChildren.findIndex((x)=>x === null || x === void 0 ? void 0 : x.matches(':focus'));
        const nextIndex = (focusedIndex + increment) % focusableChildren.length;
        moveFocusTo(nextIndex);
    }, [
        focusableChildren,
        moveFocusTo
    ]);
    const keyMap = useMemo(()=>{
        return [
            [
                'next',
                (event)=>{
                    moveFocusBy(1);
                    event.preventDefault();
                }
            ],
            [
                'previous',
                (event)=>{
                    moveFocusBy(-1);
                    event.preventDefault();
                }
            ],
            [
                'Home',
                (event)=>{
                    moveFocusTo(0);
                    event.preventDefault();
                }
            ],
            [
                'End',
                (event)=>{
                    moveFocusTo(-1);
                    event.preventDefault();
                }
            ]
        ];
    }, [
        moveFocusTo,
        moveFocusBy
    ]);
    const { ref: keyCombinationHandlerRef } = useKeyCombinationHandler(keyMap, {
        handleInputs: false
    });
    return {
        ref: composeRefs(keyCombinationHandlerRef, focusableChildrenRef)
    };
}
