import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { UnreachableError } from '../../../../base/preconditions';
import classNames from 'classnames';
import * as React from 'react';
import { WithIdentifiers } from '../../a11y/identifier/identifier';
import { SkipLink, SkipTarget } from '../../a11y/skip_link/skip_link';
import { baseUnit } from '../../metrics/metrics';
import { ScrollControls } from '../../scroll_controls/scroll_controls';
import { ScrollWindow, WindowedList } from '../../scroll_controls/scroll_window';
import styles from './carousel.css';
import { CarouselMessages } from './carousel.messages';
import { ChevronScrollButton, CircularScrollButton } from './scroll_button';
export const Carousel = React.memo(
    ({ name, children, scrollControlsRef, onScroll, expand = 'none', gutter = 'medium', snap = 'none', snapAlign = 'start', virtualization, scrollableRef: carouselScrollableRef, smoothScroll, skipLinksScrollMarginTop, disableSkipLinks = false, ...buttonProps })=>{
        const prevButtonRef = React.useRef(null);
        const nextButtonRef = React.useRef(null);
        const startLinkRef = React.useRef(null);
        const endLinkRef = React.useRef(null);
        const gutterSize = getGutterSize(gutter);
        const carouselClassName = classNames(styles.carousel, {
            [styles.mandatory]: snap === 'mandatory',
            [styles.proximity]: snap === 'proximity'
        });
        const itemClassName = classNames(getGutterClassName(gutter), styles.item, {
            [styles.snapItemInitial]: snapAlign === 'initial'
        });
        const itemWidthsWithGutter = React.useMemo(()=>{
            if (!virtualization) return;
            const value = Array.isArray(virtualization.itemWidths) ? virtualization.itemWidths.map((width)=>width + gutterSize) : new Array(children.length).fill(virtualization.itemWidths + gutterSize);
            if (value.length > 0) value[value.length - 1] -= gutterSize;
            return value;
        }, [
            children.length,
            gutterSize,
            virtualization
        ]);
        return _jsx(ScrollControls, {
            innerRef: carouselScrollableRef,
            ref: scrollControlsRef,
            itemWidths: itemWidthsWithGutter,
            smoothScroll: smoothScroll,
            onScroll: onScroll,
            children: ({ scrollableRef, movePrev, moveNext, scrollState })=>_jsx("div", {
                    className: classNames(styles.carouselContainer, {
                        [styles.expandSmall]: expand === 'small',
                        [styles.expandMedium]: expand === 'medium',
                        [styles.expandLarge]: expand === 'large'
                    }),
                    children: _jsx(CarouselSkipLinks, {
                        carouselName: name,
                        disableSkipLinks: disableSkipLinks,
                        scrollMarginTop: skipLinksScrollMarginTop,
                        startLinkRef: startLinkRef,
                        endLinkRef: endLinkRef,
                        children: _jsx(WithIdentifiers, {
                            children: (id)=>_jsxs(_Fragment, {
                                    children: [
                                        _jsx(ScrollButton, {
                                            scrollableId: id,
                                            direction: "backward",
                                            onClick: movePrev,
                                            scrollState: scrollState,
                                            buttonRef: prevButtonRef,
                                            oppositeButtonRef: nextButtonRef,
                                            startLinkRef: startLinkRef,
                                            endLinkRef: endLinkRef,
                                            ...buttonProps
                                        }),
                                        virtualization ? _jsx(VirtualizedChildren, {
                                            id: id,
                                            innerRef: scrollableRef,
                                            virtualization: virtualization,
                                            itemWidthsWithGutter: itemWidthsWithGutter,
                                            children: children,
                                            carouselClassName: carouselClassName,
                                            itemClassName: itemClassName,
                                            gutterSize: gutterSize,
                                            snap: snap
                                        }) : _jsx("div", {
                                            ref: scrollableRef,
                                            id: id,
                                            className: carouselClassName,
                                            children: React.Children.map(children.filter(Boolean), (child)=>_jsx("div", {
                                                    className: itemClassName,
                                                    children: child
                                                }))
                                        }),
                                        _jsx(ScrollButton, {
                                            scrollableId: id,
                                            direction: "forward",
                                            onClick: moveNext,
                                            scrollState: scrollState,
                                            buttonRef: nextButtonRef,
                                            oppositeButtonRef: prevButtonRef,
                                            startLinkRef: startLinkRef,
                                            endLinkRef: endLinkRef,
                                            ...buttonProps
                                        })
                                    ]
                                })
                        })
                    })
                })
        });
    }
);
const Spacer = React.memo(({ width })=>_jsx("span", {
        className: styles.spacer,
        style: {
            width
        }
    }));
const ScrollButton = React.memo((props)=>{
    const { buttonVariant } = props;
    switch(buttonVariant){
        case 'none':
            return null;
        case 'chevron':
            return _jsx(ChevronScrollButton, {
                ...props,
                verticalOffsetPx: props.buttonsVerticalOffsetPx
            });
        case 'circular':
        case undefined:
            return _jsx(CircularScrollButton, {
                ...props,
                horizontalOffsetPx: props.buttonsHorizontalOffsetPx,
                verticalOffsetPx: props.buttonsVerticalOffsetPx
            });
        case 'custom':
            return _jsx(props.ScrollButton, {
                ...props
            });
        default:
            throw new UnreachableError(buttonVariant);
    }
});
export const CarouselSkipLinks = React.memo(
    function CarouselSkipLinks({ carouselName, children, scrollMarginTop, disableSkipLinks, startLinkRef, endLinkRef }) {
        const idStart = React.useId();
        const idEnd = React.useId();
        if (disableSkipLinks) return children;
        return _jsxs(_Fragment, {
            children: [
                _jsx(SkipTarget, {
                    id: idStart,
                    scrollMarginTop: scrollMarginTop,
                    label: carouselName ? CarouselMessages.namedListStart(carouselName) : CarouselMessages.listStart()
                }),
                _jsx(SkipLink, {
                    to: idEnd,
                    position: "top",
                    ref: startLinkRef,
                    children: carouselName ? CarouselMessages.skipToNamedListEnd(carouselName) : CarouselMessages.skipToEnd()
                }),
                children,
                _jsx(SkipLink, {
                    to: idStart,
                    position: "bottom",
                    ref: endLinkRef,
                    children: carouselName ? CarouselMessages.skipToNamedListStart(carouselName) : CarouselMessages.skipToStart()
                }),
                _jsx(SkipTarget, {
                    id: idEnd,
                    scrollMarginTop: scrollMarginTop,
                    label: carouselName ? CarouselMessages.namedListEnd(carouselName) : CarouselMessages.listEnd()
                })
            ]
        });
    }
);
const getGutterSize = (gutter)=>{
    switch(gutter){
        case 'none':
            return 0;
        case 'small':
            return baseUnit;
        case 'medium':
            return baseUnit * 2;
        case 'large':
            return baseUnit * 3;
        default:
            throw new UnreachableError(gutter);
    }
};
const getGutterClassName = (gutter)=>{
    switch(gutter){
        case 'none':
            return undefined;
        case 'small':
            return styles.gutterSmall;
        case 'medium':
            return styles.gutterMedium;
        case 'large':
            return styles.gutterLarge;
        default:
            throw new UnreachableError(gutter);
    }
};
const VirtualizedChildren = React.memo(
    ({ id, innerRef, virtualization, itemWidthsWithGutter, children, carouselClassName, itemClassName, gutterSize, snap })=>_jsx(ScrollWindow, {
            innerRef: innerRef,
            layout: "horizontal",
            children: ({ scrollableRef, scrollState })=>_jsx("div", {
                    ref: scrollableRef,
                    id: id,
                    className: carouselClassName,
                    children: _jsx(WindowedList, {
                        scrollState: scrollState,
                        itemSizes: itemWidthsWithGutter,
                        overscan: virtualization.overscan,
                        children: (windowedListState, itemPositions)=>{
                            var _virtualization_initialRender;
                            const { firstVisible, lastVisible } = windowedListState !== null && windowedListState !== void 0 ? windowedListState : {
                                firstVisible: 0,
                                lastVisible: Math.min((_virtualization_initialRender = virtualization.initialRender) !== null && _virtualization_initialRender !== void 0 ? _virtualization_initialRender : 1, itemPositions.length - 1)
                            };
                            if (snap !== 'none')
                            return React.Children.map(children, (child, index)=>{
                                const width = Array.isArray(virtualization.itemWidths) ? virtualization.itemWidths[index] : virtualization.itemWidths;
                                return _jsx("div", {
                                    className: itemClassName,
                                    children: firstVisible <= index && index < lastVisible ? child : _jsx(Spacer, {
                                        width: width
                                    })
                                });
                            });
                            const spaceBefore = itemPositions[firstVisible];
                            let spaceAfter = itemPositions[itemPositions.length - 1] - itemPositions[lastVisible];
                            if (spaceAfter > 0)
                            spaceAfter += gutterSize;
                            return _jsxs(_Fragment, {
                                children: [
                                    _jsx(Spacer, {
                                        width: spaceBefore
                                    }),
                                    React.Children.map(children.slice(firstVisible, lastVisible), (child)=>_jsx("div", {
                                            className: itemClassName,
                                            children: child
                                        })),
                                    _jsx(Spacer, {
                                        width: spaceAfter
                                    })
                                ]
                            });
                        }
                    })
                })
        })
);
