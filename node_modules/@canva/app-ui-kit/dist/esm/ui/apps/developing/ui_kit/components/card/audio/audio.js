import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import classNames from 'classnames';
import * as React from 'react';
import { Box } from '../../../../../../base/box/box';
import { BasicButton } from '../../../../../../base/button/button';
import { Card, CardButton, CardDecorator, CardImageThumbnail, CardThumbnail, CardThumbnailContainer } from '../../../../../../base/card/card';
import { formatDuration } from '../../../../../../base/date_time/duration/duration';
import { AlertTriangleIcon } from '../../../../../../base/icons/alert_triangle/icon';
import { AnimatedSpinnerIcon } from '../../../../../../base/icons/animated_spinner/icon';
import { MusicIcon } from '../../../../../../base/icons/music/icon';
import { PauseIcon } from '../../../../../../base/icons/pause/icon';
import { PlayFilledIcon } from '../../../../../../base/icons/play_filled/icon';
import { Draggable } from '../draggable/draggable';
import { CARD_THUMBNAIL_SIDE_LENGTH_PX } from '../internal_card';
import styles from './audio.css';
import { AudioCardMessages as Messages } from './audio.messages';
import { AudioContext } from './audio_context';
export const AudioCard = React.forwardRef((props, ref)=>_jsx(Draggable, {
        ...props,
        children: (conf)=>_jsx(InternalAudioCard, {
                ...props,
                ...conf,
                ref: ref
            })
    }));
const InternalAudioCard = React.forwardRef(
    ({ ariaLabel, audioPreviewUrl, durationInSeconds, title, description, content, thumbnailUrl, bottomEnd, bottomEndVisibility, topEnd, topEndVisibility, onDragStart, onDragEnd, onClick, loading, disabled, selectable, selected }, ref)=>{
        const descriptionWithDuration = [
            formatDuration(durationInSeconds),
            description === null || description === void 0 ? void 0 : description.trim()
        ].filter(Boolean).join(' â€¢ ');
        const audioContext = React.useContext(AudioContext);
        if (audioContext == null) throw new Error('AudioCard` must be used within an `AudioContextProvider` component');
        const audio = React.useRef(undefined);
        const [duration, setDuration] = React.useState(0);
        const [currentTime, setCurrentTime] = React.useState(0);
        const [canPlay, setCanPlay] = React.useState(true);
        const [isHoveringOnPlayButton, setIsHoveringOnAudioControl] = React.useState(false);
        const isPlaying = audio.current && audio.current === audioContext.playingAudio;
        React.useEffect(()=>{
            if (isPlaying) audioContext.stop();
            audio.current = new Audio(audioPreviewUrl);
            setCanPlay(true);
            audio.current.onerror = ()=>{
                var _audio_current;
                if (((_audio_current = audio.current) === null || _audio_current === void 0 ? void 0 : _audio_current.src) === audioPreviewUrl) {
                    setDuration(0);
                    setCanPlay(false);
                    setCurrentTime(0);
                }
            };
            audio.current.onloadedmetadata = ()=>{
                if (duration === 0 && audio.current && audio.current.src.includes(audioPreviewUrl)) setDuration(audio.current.duration);
            };
            audio.current.ontimeupdate = ()=>{
                if (audio.current && audio.current.src.includes(audioPreviewUrl)) setCurrentTime(audio.current.currentTime);
            };
            return ()=>{
                audioContext.stop();
            };
        }, [
            audioPreviewUrl
        ]);
        const playAudio = ()=>{
            if (!audio.current || !canPlay) return;
            audioContext.play(audio.current);
        };
        const toggleAudio = (event)=>{
            event.stopPropagation();
            if (!isPlaying) {
                playAudio();
                return;
            }
            if (audioContext.isPaused) audioContext.resume();
            else audioContext.pause();
        };
        React.useImperativeHandle(ref, ()=>({
                play: ()=>{
                    if (audioContext.isPaused) audioContext.resume();
                    else if (!isPlaying) playAudio();
                },
                pause: ()=>{
                    if (audioContext.isPaused) audioContext.resume();
                    audioContext.pause();
                },
                restart: ()=>{
                    playAudio();
                },
                isPlaying: ()=>Boolean(audio.current && audio.current === audioContext.playingAudio),
                isPaused: ()=>Boolean(audioContext.isPaused)
            }));
        return _jsx(Card, {
            hoverEffect: "bgColorTransition",
            buttonAriaLabel: ariaLabel,
            title: title,
            description: descriptionWithDuration,
            content: content,
            onClick: onClick,
            draggable: onDragStart !== undefined && disabled !== true,
            onDragStart: onDragStart,
            onDragEnd: onDragEnd,
            selectableMode: selectable ? 'primary' : 'none',
            selected: selected,
            disabled: disabled,
            decorators: _jsxs(_Fragment, {
                children: [
                    !loading && _jsxs(_Fragment, {
                        children: [
                            _jsx(BasicButton, {
                                className: styles.audioControl,
                                onMouseEnter: ()=>setIsHoveringOnAudioControl(true),
                                onMouseLeave: ()=>setIsHoveringOnAudioControl(false),
                                ariaLabel: Messages.playPreview(),
                                onClick: toggleAudio,
                                children: getAudioIcon({
                                    canPlay,
                                    isPlaying: Boolean(isPlaying),
                                    isHoveringOnPlayButton,
                                    isPaused: audioContext.isPaused
                                })
                            }),
                            bottomEnd && _jsx(CardDecorator, {
                                location: "bottom-end",
                                visibility: bottomEndVisibility,
                                isInteractive: true,
                                children: bottomEnd
                            }),
                            topEnd && _jsx(CardDecorator, {
                                location: "top-end",
                                visibility: topEndVisibility,
                                isInteractive: true,
                                children: _jsx(CardButton, {
                                    icon: topEnd.buttonIcon,
                                    ariaLabel: topEnd.buttonAriaLabel,
                                    onClick: topEnd.buttonOnClick
                                })
                            })
                        ]
                    }),
                    loading && _jsx(Box, {
                        className: styles.loading,
                        display: "flex",
                        justifyContent: "center",
                        alignItems: "center",
                        width: "full",
                        height: "full",
                        children: _jsx(AnimatedSpinnerIcon, {
                            size: "medium",
                            className: styles.spinner
                        })
                    })
                ]
            }),
            thumbnail: _jsxs("div", {
                className: classNames(styles.audioCover, {
                    [styles.audioCoverPlaying]: isPlaying
                }),
                children: [
                    thumbnailUrl && _jsx(CardImageThumbnail, {
                        alt: "",
                        src: thumbnailUrl,
                        className: classNames({
                            [styles.audioImagePlaying]: isPlaying,
                            [styles.audioImagePaused]: audioContext.isPaused
                        }),
                        height: CARD_THUMBNAIL_SIDE_LENGTH_PX,
                        width: CARD_THUMBNAIL_SIDE_LENGTH_PX
                    }),
                    !thumbnailUrl && _jsx(CardThumbnailContainer, {
                        background: "secondary",
                        height: CARD_THUMBNAIL_SIDE_LENGTH_PX,
                        width: CARD_THUMBNAIL_SIDE_LENGTH_PX,
                        padding: "none",
                        children: _jsx(CardThumbnail, {
                            border: "none",
                            borderRadius: "elementSmall",
                            children: _jsx(Box, {
                                width: "full",
                                height: "full",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                children: !isHoveringOnPlayButton && !isPlaying && _jsx(MusicIcon, {
                                    size: "medium"
                                })
                            })
                        })
                    }),
                    isPlaying && duration > 0 && _jsx(PlayingCircle, {
                        playedPercentage: round(currentTime / duration, 2)
                    })
                ]
            }),
            layout: "horizontal",
            hoverBoundary: "card",
            padding: "1u"
        });
    }
);
const getAudioIcon = ({ canPlay, isPlaying, isHoveringOnPlayButton, isPaused })=>{
    if (!canPlay) return _jsx(AlertTriangleIcon, {
        size: "medium"
    });
    if (isPlaying && isPaused) return _jsx(PlayFilledIcon, {
        size: "medium"
    });
    if (isPlaying) return _jsx(PauseIcon, {
        size: "medium"
    });
    if (!isHoveringOnPlayButton) return undefined;
    return _jsx(PlayFilledIcon, {
        size: "medium"
    });
};
const PlayingCircle = ({ playedPercentage })=>{
    const strokeWidth = parseInt(styles.progressStrokeWidth, 10) || 0;
    const size = 56;
    const radius = (size - strokeWidth) / 2;
    const perimeter = 2 * Math.PI * radius;
    const dashSize = perimeter * playedPercentage;
    return _jsx("svg", {
        viewBox: `0 0 ${size} ${size}`,
        className: styles.playingCircle,
        children: _jsx("circle", {
            className: styles.animatedCircle,
            cx: size / 2,
            cy: size / 2,
            r: radius,
            strokeDasharray: `${dashSize},${perimeter}`
        })
    });
};
const round = (value, precision)=>{
    const multiplier = Math.pow(10, precision || 0);
    return Math.round(value * multiplier) / multiplier;
};
