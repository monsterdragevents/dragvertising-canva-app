import { jsx as _jsx } from "react/jsx-runtime";
import { UnreachableError } from '../../../../../../base/preconditions';
import { Box as EaselBox } from '../../../../../base/box/box';
export const backgroundTones = [
    'contrast',
    'neutral',
    'neutralLow'
];
/** 
 * The border of a box.
 */ export const borders = [
    'none',
    'standard',
    'critical',
    'low'
];
/** 
 * The border radius of a box.
 */ export const borderRadiuses = [
    'none',
    'standard',
    'large'
];
/** 
 * The size of a box.
 */ export const sizes = [
    'unset',
    'full'
];
/** 
 * The display of a box.
 */ export const displays = [
    'block',
    'none',
    'flex',
    'inline-flex'
];
/** 
 * The flex-direction css property of a box.
 */ export const flexDirections = [
    'row',
    'column'
];
/** 
 * The flex-wrap css property of a box.
 */ export const flexWraps = [
    'noWrap',
    'wrap'
];
/** 
 * The justify-content css property of a box.
 */ export const justifyContents = [
    'normal',
    'center',
    'start',
    'end',
    'spaceBetween'
];
/** 
 * The align-items css property of a box.
 */ export const alignItems = [
    'stretch',
    'center',
    'start',
    'end'
];
/** 
 * An `HTMLDivElement` with a restricted set of props that adhere to Canva's design system.
 */ export function Box(props) {
    return _jsx(EaselBox, {
        display: props.display,
        flexDirection: props.flexDirection,
        flexWrap: props.flexWrap,
        alignItems: props.alignItems,
        justifyContent: props.justifyContent,
        background: props.background,
        border: props.border,
        borderRadius: mapBorderRadius(props.borderRadius),
        padding: props.padding,
        paddingX: props.paddingX,
        paddingY: props.paddingY,
        paddingTop: props.paddingTop,
        paddingBottom: props.paddingBottom,
        paddingStart: props.paddingStart,
        paddingEnd: props.paddingEnd,
        width: props.width,
        height: props.height,
        children: props.children,
        className: props.className,
        id: props.id
    });
}
function mapBorderRadius(borderRadius) {
    switch(borderRadius){
        case undefined:
            return undefined;
        case 'none':
            return 'none';
        case 'standard':
            return 'legacyStandard';
        case 'large':
            return 'legacyLarge';
        default:
            throw new UnreachableError(borderRadius);
    }
}
