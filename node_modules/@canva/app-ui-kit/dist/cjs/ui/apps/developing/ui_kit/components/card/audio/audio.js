"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "AudioCard", {
    enumerable: true,
    get: function() {
        return AudioCard;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _box = require('../../../../../../base/box/box');
const _button = require('../../../../../../base/button/button');
const _card = require('../../../../../../base/card/card');
const _duration = require('../../../../../../base/date_time/duration/duration');
const _icon = require('../../../../../../base/icons/alert_triangle/icon');
const _icon1 = require('../../../../../../base/icons/animated_spinner/icon');
const _icon2 = require('../../../../../../base/icons/music/icon');
const _icon3 = require('../../../../../../base/icons/pause/icon');
const _icon4 = require('../../../../../../base/icons/play_filled/icon');
const _draggable = require("../draggable/draggable");
const _internal_card = require("../internal_card");
const _audiocss = _interop_require_default(require("./audio.css"));
const _audiomessages = require("./audio.messages");
const _audio_context = require("./audio_context");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const AudioCard = _react.forwardRef((props, ref)=>(0, _jsxruntime.jsx)(_draggable.Draggable, {
        ...props,
        children: (conf)=>(0, _jsxruntime.jsx)(InternalAudioCard, {
                ...props,
                ...conf,
                ref: ref
            })
    }));
const InternalAudioCard = _react.forwardRef(
    ({ ariaLabel, audioPreviewUrl, durationInSeconds, title, description, content, thumbnailUrl, bottomEnd, bottomEndVisibility, topEnd, topEndVisibility, onDragStart, onDragEnd, onClick, loading, disabled, selectable, selected }, ref)=>{
        const descriptionWithDuration = [
            (0, _duration.formatDuration)(durationInSeconds),
            description === null || description === void 0 ? void 0 : description.trim()
        ].filter(Boolean).join(' â€¢ ');
        const audioContext = _react.useContext(_audio_context.AudioContext);
        if (audioContext == null) throw new Error('AudioCard` must be used within an `AudioContextProvider` component');
        const audio = _react.useRef(undefined);
        const [duration, setDuration] = _react.useState(0);
        const [currentTime, setCurrentTime] = _react.useState(0);
        const [canPlay, setCanPlay] = _react.useState(true);
        const [isHoveringOnPlayButton, setIsHoveringOnAudioControl] = _react.useState(false);
        const isPlaying = audio.current && audio.current === audioContext.playingAudio;
        _react.useEffect(()=>{
            if (isPlaying) audioContext.stop();
            audio.current = new Audio(audioPreviewUrl);
            setCanPlay(true);
            audio.current.onerror = ()=>{
                var _audio_current;
                if (((_audio_current = audio.current) === null || _audio_current === void 0 ? void 0 : _audio_current.src) === audioPreviewUrl) {
                    setDuration(0);
                    setCanPlay(false);
                    setCurrentTime(0);
                }
            };
            audio.current.onloadedmetadata = ()=>{
                if (duration === 0 && audio.current && audio.current.src.includes(audioPreviewUrl)) setDuration(audio.current.duration);
            };
            audio.current.ontimeupdate = ()=>{
                if (audio.current && audio.current.src.includes(audioPreviewUrl)) setCurrentTime(audio.current.currentTime);
            };
            return ()=>{
                audioContext.stop();
            };
        }, [
            audioPreviewUrl
        ]);
        const playAudio = ()=>{
            if (!audio.current || !canPlay) return;
            audioContext.play(audio.current);
        };
        const toggleAudio = (event)=>{
            event.stopPropagation();
            if (!isPlaying) {
                playAudio();
                return;
            }
            if (audioContext.isPaused) audioContext.resume();
            else audioContext.pause();
        };
        _react.useImperativeHandle(ref, ()=>({
                play: ()=>{
                    if (audioContext.isPaused) audioContext.resume();
                    else if (!isPlaying) playAudio();
                },
                pause: ()=>{
                    if (audioContext.isPaused) audioContext.resume();
                    audioContext.pause();
                },
                restart: ()=>{
                    playAudio();
                },
                isPlaying: ()=>Boolean(audio.current && audio.current === audioContext.playingAudio),
                isPaused: ()=>Boolean(audioContext.isPaused)
            }));
        return (0, _jsxruntime.jsx)(_card.Card, {
            hoverEffect: "bgColorTransition",
            buttonAriaLabel: ariaLabel,
            title: title,
            description: descriptionWithDuration,
            content: content,
            onClick: onClick,
            draggable: onDragStart !== undefined && disabled !== true,
            onDragStart: onDragStart,
            onDragEnd: onDragEnd,
            selectableMode: selectable ? 'primary' : 'none',
            selected: selected,
            disabled: disabled,
            decorators: (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                children: [
                    !loading && (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                        children: [
                            (0, _jsxruntime.jsx)(_button.BasicButton, {
                                className: _audiocss.default.audioControl,
                                onMouseEnter: ()=>setIsHoveringOnAudioControl(true),
                                onMouseLeave: ()=>setIsHoveringOnAudioControl(false),
                                ariaLabel: _audiomessages.AudioCardMessages.playPreview(),
                                onClick: toggleAudio,
                                children: getAudioIcon({
                                    canPlay,
                                    isPlaying: Boolean(isPlaying),
                                    isHoveringOnPlayButton,
                                    isPaused: audioContext.isPaused
                                })
                            }),
                            bottomEnd && (0, _jsxruntime.jsx)(_card.CardDecorator, {
                                location: "bottom-end",
                                visibility: bottomEndVisibility,
                                isInteractive: true,
                                children: bottomEnd
                            }),
                            topEnd && (0, _jsxruntime.jsx)(_card.CardDecorator, {
                                location: "top-end",
                                visibility: topEndVisibility,
                                isInteractive: true,
                                children: (0, _jsxruntime.jsx)(_card.CardButton, {
                                    icon: topEnd.buttonIcon,
                                    ariaLabel: topEnd.buttonAriaLabel,
                                    onClick: topEnd.buttonOnClick
                                })
                            })
                        ]
                    }),
                    loading && (0, _jsxruntime.jsx)(_box.Box, {
                        className: _audiocss.default.loading,
                        display: "flex",
                        justifyContent: "center",
                        alignItems: "center",
                        width: "full",
                        height: "full",
                        children: (0, _jsxruntime.jsx)(_icon1.AnimatedSpinnerIcon, {
                            size: "medium",
                            className: _audiocss.default.spinner
                        })
                    })
                ]
            }),
            thumbnail: (0, _jsxruntime.jsxs)("div", {
                className: (0, _classnames.default)(_audiocss.default.audioCover, {
                    [_audiocss.default.audioCoverPlaying]: isPlaying
                }),
                children: [
                    thumbnailUrl && (0, _jsxruntime.jsx)(_card.CardImageThumbnail, {
                        alt: "",
                        src: thumbnailUrl,
                        className: (0, _classnames.default)({
                            [_audiocss.default.audioImagePlaying]: isPlaying,
                            [_audiocss.default.audioImagePaused]: audioContext.isPaused
                        }),
                        height: _internal_card.CARD_THUMBNAIL_SIDE_LENGTH_PX,
                        width: _internal_card.CARD_THUMBNAIL_SIDE_LENGTH_PX
                    }),
                    !thumbnailUrl && (0, _jsxruntime.jsx)(_card.CardThumbnailContainer, {
                        background: "secondary",
                        height: _internal_card.CARD_THUMBNAIL_SIDE_LENGTH_PX,
                        width: _internal_card.CARD_THUMBNAIL_SIDE_LENGTH_PX,
                        padding: "none",
                        children: (0, _jsxruntime.jsx)(_card.CardThumbnail, {
                            border: "none",
                            borderRadius: "elementSmall",
                            children: (0, _jsxruntime.jsx)(_box.Box, {
                                width: "full",
                                height: "full",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center",
                                children: !isHoveringOnPlayButton && !isPlaying && (0, _jsxruntime.jsx)(_icon2.MusicIcon, {
                                    size: "medium"
                                })
                            })
                        })
                    }),
                    isPlaying && duration > 0 && (0, _jsxruntime.jsx)(PlayingCircle, {
                        playedPercentage: round(currentTime / duration, 2)
                    })
                ]
            }),
            layout: "horizontal",
            hoverBoundary: "card",
            padding: "1u"
        });
    }
);
const getAudioIcon = ({ canPlay, isPlaying, isHoveringOnPlayButton, isPaused })=>{
    if (!canPlay) return (0, _jsxruntime.jsx)(_icon.AlertTriangleIcon, {
        size: "medium"
    });
    if (isPlaying && isPaused) return (0, _jsxruntime.jsx)(_icon4.PlayFilledIcon, {
        size: "medium"
    });
    if (isPlaying) return (0, _jsxruntime.jsx)(_icon3.PauseIcon, {
        size: "medium"
    });
    if (!isHoveringOnPlayButton) return undefined;
    return (0, _jsxruntime.jsx)(_icon4.PlayFilledIcon, {
        size: "medium"
    });
};
const PlayingCircle = ({ playedPercentage })=>{
    const strokeWidth = parseInt(_audiocss.default.progressStrokeWidth, 10) || 0;
    const size = 56;
    const radius = (size - strokeWidth) / 2;
    const perimeter = 2 * Math.PI * radius;
    const dashSize = perimeter * playedPercentage;
    return (0, _jsxruntime.jsx)("svg", {
        viewBox: `0 0 ${size} ${size}`,
        className: _audiocss.default.playingCircle,
        children: (0, _jsxruntime.jsx)("circle", {
            className: _audiocss.default.animatedCircle,
            cx: size / 2,
            cy: size / 2,
            r: radius,
            strokeDasharray: `${dashSize},${perimeter}`
        })
    });
};
const round = (value, precision)=>{
    const multiplier = Math.pow(10, precision || 0);
    return Math.round(value * multiplier) / multiplier;
};
