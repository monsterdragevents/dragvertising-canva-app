"use strict"
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get Inline () {
        return Inline;
    },
    get alignXs () {
        return alignXs;
    },
    get alignYs () {
        return alignYs;
    },
    get breakpoints () {
        return breakpoints;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _classnames = _interop_require_default(require("classnames"));
const _mobx = require("mobx");
const _react = _interop_require_wildcard(require("react"));
const _common_props = require('../../../box/common_props/common_props');
const _metrics = require('../../../metrics/metrics');
const _responsive = require('../../../responsive/responsive');
const _inlinecss = _interop_require_wildcard(require("./inline.css"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const alignXs = [
    'start',
    'center',
    'end',
    'spaceBetween'
];
const alignYs = [
    'start',
    'center',
    'end',
    'stretch'
];
const breakpoints = [
    'small',
    'medium',
    'large',
    'xLarge'
];
const spacingPropertyMap = {
    default: _inlinecss.customProperties.spacing,
    smallUp: _inlinecss.customProperties.smallUpSpacing,
    mediumUp: _inlinecss.customProperties.mediumUpSpacing,
    largeUp: _inlinecss.customProperties.largeUpSpacing,
    xLargeUp: _inlinecss.customProperties.xLargeUpSpacing
};
const alignPropertyMap = {
    default: _inlinecss.customProperties.align,
    smallUp: _inlinecss.customProperties.smallUpAlign,
    mediumUp: _inlinecss.customProperties.mediumUpAlign,
    largeUp: _inlinecss.customProperties.largeUpAlign,
    xLargeUp: _inlinecss.customProperties.xLargeUpAlign
};
const alignYPropertyMap = {
    default: _inlinecss.customProperties.alignY,
    smallUp: _inlinecss.customProperties.smallUpAlignY,
    mediumUp: _inlinecss.customProperties.mediumUpAlignY,
    largeUp: _inlinecss.customProperties.largeUpAlignY,
    xLargeUp: _inlinecss.customProperties.xLargeUpAlignY
};
const getAlignValue = (align)=>align !== 'spaceBetween' ? align : 'space-between';
const getInlineAlignYValue = (alignY)=>alignY === 'start' || alignY === 'end' ? `flex-${alignY}` : alignY;
const Inline = _react.forwardRef(
    ({ children, spacing, align, alignY, collapseBelow, collapsed, tagName: TagName = 'div', ...rest }, ref)=>{
        const isList = TagName === 'ul' || TagName === 'ol';
        const isPhrasingContent = TagName === 'span';
        const ContainerTagName = isPhrasingContent ? 'span' : 'div';
        const childTagName = isList ? 'li' : isPhrasingContent ? 'span' : 'div';
        return ((0, _jsxruntime.jsx)(ContainerTagName, {
                className: _inlinecss.default.container,
                ref: ref,
                children: (0, _jsxruntime.jsx)(TagName, {
                    className: (0, _classnames.default)(_inlinecss.default.inline, collapseBelow && collapseBelowClassNames[collapseBelow], collapsed && _inlinecss.default.collapsed),
                    style: {
                        ...(spacing && (0, _responsive.generateStyle)(spacingPropertyMap, spacing, _metrics.getSpaceValue)),
                        ...(align && (0, _responsive.generateStyle)(alignPropertyMap, align, getAlignValue)),
                        ...(alignY && (0, _responsive.generateStyle)(alignYPropertyMap, alignY, getInlineAlignYValue))
                    },
                    ...(0, _common_props.commonPropsToDOMProps)(rest),
                    children: wrapOrCloneChildren(children, childTagName)
                })
            }));
    }
);
Inline.displayName = 'Inline';
function wrapOrCloneChildren(children, TagName) {
    return _react.Children.map(flattenChildren(children), (child)=>{
        if (!child) return null;
        if (TagName === 'li' && _react.isValidElement(child) && child.type === 'li') return _react.cloneElement(child, {
            className: (0, _classnames.default)(child.props.className, _inlinecss.default.element)
        });
        return (0, _jsxruntime.jsx)(TagName, {
            className: _inlinecss.default.element,
            children: child
        });
    });
}
function isFragment(node) {
    return _react.isValidElement(node) && node.type === _react.Fragment;
}
function flattenChildren(children, depth = 0, keys = []) {
    const childrenWithoutObservability = Array.isArray(children) ? children.map((node)=>{
        var _node_$mobx;
        return (node === null || node === void 0 ? void 0 : (_node_$mobx = node[_mobx.$mobx]) === null || _node_$mobx === void 0 ? void 0 : _node_$mobx.proxy_) != null ? (0, _mobx.toJS)(node) : node;
    }) : children;
    return _react.Children.toArray(childrenWithoutObservability).reduce((acc, node, nodeIndex)=>{
        if (isFragment(node)) acc.push(...flattenChildren(node.props.children, depth + 1, keys.concat(node.key || nodeIndex)));
        else {
            if (_react.isValidElement(node)) acc.push(_react.cloneElement(node, {
                key: keys.concat(String(node.key)).join('.')
            }));
            else if (typeof node === 'string' || typeof node === 'number') acc.push(node);
        }
        return acc;
    }, []);
}
const collapseBelowClassNames = {
    ['small']: _inlinecss.default.collapseBelowSmall,
    ['medium']: _inlinecss.default.collapseBelowMedium,
    ['large']: _inlinecss.default.collapseBelowLarge,
    ['xLarge']: _inlinecss.default.collapseBelowXLarge
};
