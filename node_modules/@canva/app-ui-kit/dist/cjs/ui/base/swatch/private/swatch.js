"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
function _export(target, all) {
  for (var name in all) Object.defineProperty(target, name, {
    enumerable: true,
    get: Object.getOwnPropertyDescriptor(all, name).get
  });
}
_export(exports, {
  get AddColorButton() {
    return AddColorButton;
  },
  get Swatch() {
    return Swatch;
  }
});
const _jsxruntime = require("react/jsx-runtime");
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _reactmeasure = _interop_require_default(require("react-measure"));
const _aspect_ratio = require('../../aspect_ratio/aspect_ratio');
const _icon = require('../../icons/plus/icon');
const _internal_swatch = require("./internal_swatch");
const _svg_color = require("./svg_color");
const _swatchcss = _interop_require_default(require("./swatch.css"));
const _swatchmessages = require("./swatch.messages");
const _swatch_util = require("./swatch_util");
function _interop_require_default(obj) {
  return obj && obj.__esModule ? obj : {
    default: obj
  };
}
function _getRequireWildcardCache(nodeInterop) {
  if (typeof WeakMap !== "function") return null;
  var cacheBabelInterop = new WeakMap();
  var cacheNodeInterop = new WeakMap();
  return (_getRequireWildcardCache = function (nodeInterop) {
    return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
  })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
  if (!nodeInterop && obj && obj.__esModule) {
    return obj;
  }
  if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
    return {
      default: obj
    };
  }
  var cache = _getRequireWildcardCache(nodeInterop);
  if (cache && cache.has(obj)) {
    return cache.get(obj);
  }
  var newObj = {
    __proto__: null
  };
  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  for (var key in obj) {
    if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
      if (desc && (desc.get || desc.set)) {
        Object.defineProperty(newObj, key, desc);
      } else {
        newObj[key] = obj[key];
      }
    }
  }
  newObj.default = obj;
  if (cache) {
    cache.set(obj, newObj);
  }
  return newObj;
}
const getClassName = ({
  size,
  shape,
  stretch,
  aspectRatio
}) => {
  const fluidStyles = {
    [_swatchcss.default.stretch]: stretch,
    [_swatchcss.default.aspectRatio]: stretch && aspectRatio
  };
  const sizeStyles = {
    [_swatchcss.default.xxsmall]: size === 'xxsmall',
    [_swatchcss.default.xsmall]: size === 'xsmall',
    [_swatchcss.default.small]: size === 'small',
    [_swatchcss.default.medium]: size === 'medium',
    [_swatchcss.default.large]: size === 'large'
  };
  const borderRadiusStyles = (0, _internal_swatch.getBorderRadiusStyles)(shape, size);
  return (0, _classnames.default)(_swatchcss.default.swatch, sizeStyles, fluidStyles, borderRadiusStyles);
};
const getBackgroundClassName = ({
  variant,
  fill,
  contrastingColors,
  isCheckeredBgPresent,
  areNoColorsApplied
}) => {
  const variantStyles = {
    [_swatchcss.default.outline]: variant === 'outline'
  };
  const fillStyles = {
    [_swatchcss.default.colorSpectrumCircular]: areNoColorsApplied || fill === 'circularSpectrum' || contrastingColors === 'circularSpectrum',
    [_swatchcss.default.colorSpectrumLinear]: fill === 'linearSpectrum',
    [_swatchcss.default.colorTransparent]: isCheckeredBgPresent
  };
  return (0, _classnames.default)(_swatchcss.default.background, variantStyles, fillStyles);
};
const getInlineStyles = (colors, width) => {
  if (!(colors === null || colors === void 0 ? void 0 : colors.length)) return undefined;
  const backgroundImage = colors.map(color => {
    if (typeof color === 'string') return (0, _swatch_util.getValidGradientString)(color);
    if (color == null)
      return (0, _swatch_util.getValidGradientString)('transparent');
    return undefined;
  }).filter(Boolean).join(', ');
  const backgroundSize = colors.length > 1 ? `${colors.map((c, i) => (0, _swatch_util.toStripeWidth)(width, colors.length)).join(', ')}` : undefined;
  const backgroundPositionX = colors.length > 1 ? `${colors.map((c, i) => (0, _swatch_util.toStripePosition)(i, colors.length - 1)).join(', ')}` : undefined;
  const backgroundRepeat = colors.length > 1 ? 'no-repeat' : undefined;
  return {
    backgroundImage,
    backgroundRepeat,
    backgroundSize,
    backgroundPositionX
  };
};
const getSwatchContent = ({
  areAllColorsTransparent,
  isCheckeredBgPresent,
  colors,
  width,
  height
}) => {
  if (colors == null || colors.every(c => c === undefined || typeof c === 'string')) {
    const inlineStyles = getInlineStyles(colors, width !== null && width !== void 0 ? width : 0);
    if (areAllColorsTransparent) return {
      node: (0, _jsxruntime.jsx)("span", {
        className: _swatchcss.default.strike
      })
    };
    if (isCheckeredBgPresent) return {
      node: (0, _jsxruntime.jsx)("span", {
        className: (0, _classnames.default)(_swatchcss.default.colors),
        style: inlineStyles
      })
    };
    return {
      backgroundStyles: inlineStyles
    };
  }
  return {
    node: (0, _jsxruntime.jsx)(_svg_color.ColorStripes, {
      className: _swatchcss.default.colors,
      fills: colors,
      width: width ? (0, _swatch_util.fixPrecisionError)(width) : 1,
      height: height ? (0, _swatch_util.fixPrecisionError)(height) : 1
    })
  };
};
const Swatch = _react.forwardRef(({
  fill,
  size = 'medium',
  variant = 'solid',
  shape = 'circle',
  Icon,
  onClick,
  active,
  selected,
  pressed,
  disabled,
  disclosure,
  role,
  tabIndex,
  tooltipLabel,
  disableTooltip,
  stretch,
  colorNames,
  rgbToCmyk,
  id,
  ariaLabel,
  tooltipDescription,
  ariaDescribedBy,
  ariaLabelledBy,
  onDelete,
  deleteButtonVisibility = 'on-hover',
  aspectRatio,
  ariaHasPopup,
  ariaControls
}, ref) => {
  const [spanBounds, setSpanBounds] = _react.useState({});
  const contrastingColors = (0, _swatch_util.useContrastingColors)(fill, variant === 'contrast');
  const colors = contrastingColors instanceof Array ? contrastingColors : undefined;
  const areNoColorsApplied = (colors === null || colors === void 0 ? void 0 : colors.length) === 0;
  const isAtleastOneColorTransparent = !areNoColorsApplied && (colors === null || colors === void 0 ? void 0 : colors.some(c => !c)) || false;
  const areAllColorsTransparent = !areNoColorsApplied && (colors === null || colors === void 0 ? void 0 : colors.every(c => !c)) || false;
  const isCheckeredBgPresent = fill !== 'linearSpectrum' && fill !== 'circularSpectrum' && contrastingColors !== 'circularSpectrum' && !areNoColorsApplied;
  const className = getClassName({
    size,
    shape,
    stretch,
    aspectRatio
  });
  const backgroundClassName = getBackgroundClassName({
    variant,
    fill,
    contrastingColors,
    isCheckeredBgPresent,
    areNoColorsApplied
  });
  const content = getSwatchContent({
    areAllColorsTransparent,
    isCheckeredBgPresent,
    colors,
    width: spanBounds.width,
    height: spanBounds.height
  });
  const defaultLabel = _react.useMemo(() => (0, _swatch_util.generateSwatchLabel)({
    colors,
    rgbToCmyk,
    areNoColorsApplied,
    areAllColorsTransparent,
    isAtleastOneColorTransparent,
    fill
  }), [colors, rgbToCmyk, areNoColorsApplied, areAllColorsTransparent, isAtleastOneColorTransparent, fill]);
  const nameLabel = _react.useMemo(() => (0, _swatch_util.getSwatchName)(colors, colorNames), [colors, colorNames]);
  var _ref;
  const tooltipLabelText = !disableTooltip ? (_ref = tooltipLabel !== null && tooltipLabel !== void 0 ? tooltipLabel : nameLabel) !== null && _ref !== void 0 ? _ref : defaultLabel : '';
  const tooltipDescriptionText = tooltipDescription !== null && tooltipDescription !== void 0 ? tooltipDescription : nameLabel ? defaultLabel : undefined;
  const ariaLabelText = ariaLabel !== null && ariaLabel !== void 0 ? ariaLabel : defaultLabel;
  const isClickable = !!onClick;
  const isDeletable = !!onDelete;
  const staticRef = _react.useRef(null);
  const clickableRef = _react.useRef(null);
  const deletableRef = _react.useRef(null);
  _react.useImperativeHandle(ref, () => ({
    focus: () => {
      var _this;
      var _clickableRef_current, _ref;
      (_this = (_ref = (_clickableRef_current = clickableRef.current) !== null && _clickableRef_current !== void 0 ? _clickableRef_current : deletableRef.current) !== null && _ref !== void 0 ? _ref : staticRef.current) === null || _this === void 0 ? void 0 : _this.focus();
    },
    blur: () => {
      var _this;
      var _clickableRef_current, _ref;
      (_this = (_ref = (_clickableRef_current = clickableRef.current) !== null && _clickableRef_current !== void 0 ? _clickableRef_current : deletableRef.current) !== null && _ref !== void 0 ? _ref : staticRef.current) === null || _this === void 0 ? void 0 : _this.blur();
    }
  }));
  const swatch = (0, _jsxruntime.jsxs)(_internal_swatch.StaticSwatch, {
    ref: staticRef,
    className: className,
    ariaLabel: ariaLabelText,
    ariaLabelledBy: ariaLabelledBy,
    ariaDescribedBy: ariaDescribedBy,
    id: id,
    isRoot: !isDeletable && !isClickable,
    children: [(0, _jsxruntime.jsx)(_reactmeasure.default, {
      bounds: true,
      onResize: ({
        bounds
      }) => setSpanBounds(bounds !== null && bounds !== void 0 ? bounds : {}),
      children: ({
        measureRef
      }) => (0, _jsxruntime.jsx)("span", {
        ref: measureRef,
        className: backgroundClassName,
        style: content.backgroundStyles,
        children: content.node
      })
    }), Icon && (0, _jsxruntime.jsx)("span", {
      className: _swatchcss.default.icon,
      children: Icon()
    })]
  });
  const interactiveSwatch = isClickable ? (0, _jsxruntime.jsx)(_internal_swatch.ClickableSwatch, {
    ref: clickableRef,
    size: size,
    shape: shape,
    onClick: onClick,
    active: active,
    selected: selected,
    pressed: pressed,
    disabled: disabled,
    disclosure: disclosure,
    ariaLabel: ariaLabelText,
    role: role,
    tabIndex: tabIndex,
    stretch: stretch,
    aspectRatio: aspectRatio,
    ariaHasPopup: ariaHasPopup,
    ariaControls: ariaControls,
    tooltipLabel: tooltipLabelText,
    tooltipDescription: tooltipDescriptionText,
    disableTooltip: disableTooltip,
    isRoot: !isDeletable,
    children: swatch
  }) : swatch;
  const fluidSwatch = stretch && aspectRatio ? (0, _jsxruntime.jsx)(_aspect_ratio.AspectRatio, {
    ratio: aspectRatio,
    children: interactiveSwatch
  }) : interactiveSwatch;
  const swatchWithDeleteButton = isDeletable ? (0, _jsxruntime.jsx)(_internal_swatch.DeletableSwatch, {
    ref: deletableRef,
    onDelete: onDelete,
    stretch: stretch,
    aspectRatio: aspectRatio,
    deleteButtonVisibility: deleteButtonVisibility,
    disableTooltip: disableTooltip,
    isRoot: true,
    children: fluidSwatch
  }) : fluidSwatch;
  return swatchWithDeleteButton;
});
const iconSizeMap = {
  ['xxsmall']: 'tiny',
  ['xsmall']: 'small',
  ['small']: 'small',
  ['medium']: 'small',
  ['large']: 'medium'
};
const AddColorButton = props => {
  const {
    ariaLabel,
    tooltipLabel,
    size = 'medium'
  } = props;
  const Icon = () => (0, _jsxruntime.jsx)("span", {
    className: _swatchcss.default.iconOverlay,
    children: (0, _jsxruntime.jsx)(_icon.PlusIcon, {
      size: iconSizeMap[size],
      tone: "primary"
    })
  });
  return (0, _jsxruntime.jsx)(Swatch, {
    ...props,
    fill: "circularSpectrum",
    tooltipLabel: tooltipLabel !== null && tooltipLabel !== void 0 ? tooltipLabel : _swatchmessages.SwatchMessages.addColor(),
    ariaLabel: ariaLabel !== null && ariaLabel !== void 0 ? ariaLabel : _swatchmessages.SwatchMessages.addColor(),
    Icon: Icon
  });
};