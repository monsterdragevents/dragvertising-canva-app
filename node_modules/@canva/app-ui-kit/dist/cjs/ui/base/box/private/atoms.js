"use strict"
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get alignItems () {
        return alignItems;
    },
    get alignItemsAtom () {
        return alignItemsAtom;
    },
    get alignSelfAtom () {
        return alignSelfAtom;
    },
    get alignSelves () {
        return alignSelves;
    },
    get backgroundAtom () {
        return backgroundAtom;
    },
    get backgroundTones () {
        return backgroundTones;
    },
    get borderAtom () {
        return borderAtom;
    },
    get borderPositionAtom () {
        return borderPositionAtom;
    },
    get borderRadiusAtom () {
        return borderRadiusAtom;
    },
    get borderRadiuses () {
        return borderRadiuses;
    },
    get borders () {
        return borders;
    },
    get displays () {
        return displays;
    },
    get flexDirections () {
        return flexDirections;
    },
    get flexItemBehaviors () {
        return flexItemBehaviors;
    },
    get flexWrapAtom () {
        return flexWrapAtom;
    },
    get flexWraps () {
        return flexWraps;
    },
    get getDisplayClassNames () {
        return getDisplayClassNames;
    },
    get getDisplayStyles () {
        return getDisplayStyles;
    },
    get getFlexDirectionClassNames () {
        return getFlexDirectionClassNames;
    },
    get getFlexDirectionStyles () {
        return getFlexDirectionStyles;
    },
    get getFlexItemBehaviorClassNames () {
        return getFlexItemBehaviorClassNames;
    },
    get getPaddingClassNames () {
        return getPaddingClassNames;
    },
    get getPaddingStyles () {
        return getPaddingStyles;
    },
    get heightAtom () {
        return heightAtom;
    },
    get justifyContentAtom () {
        return justifyContentAtom;
    },
    get justifyContents () {
        return justifyContents;
    },
    get minHeightAtom () {
        return minHeightAtom;
    },
    get minSizes () {
        return minSizes;
    },
    get minWidthAtom () {
        return minWidthAtom;
    },
    get positionAtom () {
        return positionAtom;
    },
    get positionBottomAtom () {
        return positionBottomAtom;
    },
    get positionEndAtom () {
        return positionEndAtom;
    },
    get positionInsetAtom () {
        return positionInsetAtom;
    },
    get positionInsets () {
        return positionInsets;
    },
    get positionStartAtom () {
        return positionStartAtom;
    },
    get positionTopAtom () {
        return positionTopAtom;
    },
    get positions () {
        return positions;
    },
    get resetAtom () {
        return resetAtom;
    },
    get shadowAtom () {
        return shadowAtom;
    },
    get shadows () {
        return shadows;
    },
    get sizes () {
        return sizes;
    },
    get widthAtom () {
        return widthAtom;
    }
});
const _preconditions = require('../../../../base/preconditions');
const _metrics = require('../../metrics/metrics');
const _responsive = require('../../responsive/responsive');
const _resetcss = _interop_require_default(require("./_reset.css"));
const _alignmentcss = require("./alignment.css");
const _backgroundcss = require("./background.css");
const _bordercss = require("./border.css");
const _displaycss = _interop_require_wildcard(require("./display.css"));
const _flexcss = _interop_require_wildcard(require("./flex.css"));
const _paddingcss = _interop_require_wildcard(require("./padding.css"));
const _positioncss = require("./position.css");
const _shadowcss = require("./shadow.css");
const _sizecss = require("./size.css");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function resetAtom(reset) {
    if (reset) return _resetcss.default.reset;
    return null;
}
const displays = [
    'block',
    'none',
    'flex',
    'inline-flex'
];
const getDisplayClassNames = (display)=>[
        display && _displaycss.default.hasDisplay
    ];
const displayPropertyMap = {
    default: _displaycss.customProperties.defaultDisplay,
    smallUp: _displaycss.customProperties.smallUpDisplay,
    mediumUp: _displaycss.customProperties.mediumUpDisplay,
    largeUp: _displaycss.customProperties.largeUpDisplay,
    xLargeUp: _displaycss.customProperties.xLargeUpDisplay
};
const getDisplayStyles = (display)=>({
        ...(display && (0, _responsive.generateStyle)(displayPropertyMap, display))
    });
const backgroundTones = [
    'contrast',
    'assist',
    'positive',
    'info',
    'warn',
    'critical',
    'neutralLow',
    'assistLow',
    'positiveLow',
    'infoLow',
    'warnLow',
    'criticalLow',
    'checkered',
    'neutral',
    'neutralSubtle',
    'elevationSurfaceSunken',
    'elevationSurface',
    'elevationSurfaceRaised',
    'elevationSurfaceFloating',
    'feedbackOverlay',
    'feedbackHint',
    'feedbackHintSubtle',
    'feedbackPositive',
    'feedbackPositiveSubtle',
    'feedbackInfo',
    'feedbackInfoSubtle',
    'feedbackWarn',
    'feedbackWarnSubtle',
    'feedbackCritical',
    'feedbackCriticalSubtle'
];
function backgroundAtom(background) {
    if (!background) return null;
    return (0, _backgroundcss.getStyle)(`${background}Background`);
}
const borders = [
    'none',
    'standard',
    'critical',
    'low'
];
const borderRadiuses = [
    'none',
    'legacyStandard',
    'legacyLarge',
    'elementSmall',
    'element',
    'elementRelaxed',
    'container',
    'containerLarge',
    'tag',
    'baseUnit',
    'elementSharp',
    'elementStandard',
    'elementRound',
    'elementSoft',
    'elementSoftest',
    'containerStandard',
    'containerSoft',
    'containerSoftest'
];
function borderAtom(border) {
    if (!border || border === 'none') return null;
    return (0, _bordercss.getStyle)(`${border}Border`);
}
function borderPositionAtom({ top, bottom, start, end }) {
    return [
        top && (0, _bordercss.getStyle)(`${top}BorderTop`),
        bottom && (0, _bordercss.getStyle)(`${bottom}BorderBottom`),
        start && (0, _bordercss.getStyle)(`${start}BorderStart`),
        end && (0, _bordercss.getStyle)(`${end}BorderEnd`)
    ];
}
function borderRadiusAtom(borderRadius) {
    if (!borderRadius || borderRadius === 'none') return null;
    return (0, _bordercss.getStyle)(`${borderRadius}BorderRadius`);
}
const shadows = [
    'none',
    'surface',
    'surfaceHigh',
    'handle',
    'elevationSurfaceFloating',
    'elevationHandleRaised',
    'elevationSurfaceRaised'
];
function shadowAtom(shadow) {
    if (!shadow || shadow === 'none') return null;
    return (0, _shadowcss.getStyle)(`${shadow}Shadow`);
}
const sizes = [
    'unset',
    'full'
];
function widthAtom(width) {
    if (!width || width === 'unset') return null;
    return (0, _sizecss.getStyle)(`${width}Width`);
}
function heightAtom(height) {
    if (!height || height === 'unset') return null;
    return (0, _sizecss.getStyle)(`${height}Height`);
}
const minSizes = [
    '0',
    'minTouchableArea'
];
function minWidthAtom(minWidth) {
    switch(minWidth){
        case '0':
            return (0, _sizecss.getStyle)(`minWidth0`);
        case 'minTouchableArea':
            return (0, _sizecss.getStyle)(`minWidthMinTouchableArea`);
        default:
            return null;
    }
}
function minHeightAtom(minHeight) {
    switch(minHeight){
        case '0':
            return (0, _sizecss.getStyle)(`minHeight0`);
        case 'minTouchableArea':
            return (0, _sizecss.getStyle)(`minHeightMinTouchableArea`);
        default:
            return null;
    }
}
const getPaddingClassNames = (padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd)=>[
        (padding || paddingX || paddingY || paddingTop || paddingBottom || paddingStart || paddingEnd) && _paddingcss.default.hasPadding
    ];
const paddingPropertyMap = {
    default: _paddingcss.customProperties.padding,
    smallUp: _paddingcss.customProperties.smallUpPadding,
    mediumUp: _paddingcss.customProperties.mediumUpPadding,
    largeUp: _paddingcss.customProperties.largeUpPadding,
    xLargeUp: _paddingcss.customProperties.xLargeUpPadding
};
const paddingXPropertyMap = {
    default: _paddingcss.customProperties.paddingX,
    smallUp: _paddingcss.customProperties.smallUpPaddingX,
    mediumUp: _paddingcss.customProperties.mediumUpPaddingX,
    largeUp: _paddingcss.customProperties.largeUpPaddingX,
    xLargeUp: _paddingcss.customProperties.xLargeUpPaddingX
};
const paddingYPropertyMap = {
    default: _paddingcss.customProperties.paddingY,
    smallUp: _paddingcss.customProperties.smallUpPaddingY,
    mediumUp: _paddingcss.customProperties.mediumUpPaddingY,
    largeUp: _paddingcss.customProperties.largeUpPaddingY,
    xLargeUp: _paddingcss.customProperties.xLargeUpPaddingY
};
const paddingTopPropertyMap = {
    default: _paddingcss.customProperties.paddingTop,
    smallUp: _paddingcss.customProperties.smallUpPaddingTop,
    mediumUp: _paddingcss.customProperties.mediumUpPaddingTop,
    largeUp: _paddingcss.customProperties.largeUpPaddingTop,
    xLargeUp: _paddingcss.customProperties.xLargeUpPaddingTop
};
const paddingBottomPropertyMap = {
    default: _paddingcss.customProperties.paddingBottom,
    smallUp: _paddingcss.customProperties.smallUpPaddingBottom,
    mediumUp: _paddingcss.customProperties.mediumUpPaddingBottom,
    largeUp: _paddingcss.customProperties.largeUpPaddingBottom,
    xLargeUp: _paddingcss.customProperties.xLargeUpPaddingBottom
};
const paddingStartPropertyMap = {
    default: _paddingcss.customProperties.paddingStart,
    smallUp: _paddingcss.customProperties.smallUpPaddingStart,
    mediumUp: _paddingcss.customProperties.mediumUpPaddingStart,
    largeUp: _paddingcss.customProperties.largeUpPaddingStart,
    xLargeUp: _paddingcss.customProperties.xLargeUpPaddingStart
};
const paddingEndPropertyMap = {
    default: _paddingcss.customProperties.paddingEnd,
    smallUp: _paddingcss.customProperties.smallUpPaddingEnd,
    mediumUp: _paddingcss.customProperties.mediumUpPaddingEnd,
    largeUp: _paddingcss.customProperties.largeUpPaddingEnd,
    xLargeUp: _paddingcss.customProperties.xLargeUpPaddingEnd
};
const getPaddingStyles = (padding, paddingX, paddingY, paddingTop, paddingBottom, paddingStart, paddingEnd)=>({
        ...(padding && (0, _responsive.generateStyle)(paddingPropertyMap, padding, _metrics.getSpaceValue)),
        ...(paddingX && (0, _responsive.generateStyle)(paddingXPropertyMap, paddingX, _metrics.getSpaceValue)),
        ...(paddingY && (0, _responsive.generateStyle)(paddingYPropertyMap, paddingY, _metrics.getSpaceValue)),
        ...(paddingTop && (0, _responsive.generateStyle)(paddingTopPropertyMap, paddingTop, _metrics.getSpaceValue)),
        ...(paddingBottom && (0, _responsive.generateStyle)(paddingBottomPropertyMap, paddingBottom, _metrics.getSpaceValue)),
        ...(paddingStart && (0, _responsive.generateStyle)(paddingStartPropertyMap, paddingStart, _metrics.getSpaceValue)),
        ...(paddingEnd && (0, _responsive.generateStyle)(paddingEndPropertyMap, paddingEnd, _metrics.getSpaceValue))
    });
const getFlexDirectionClassNames = (direction)=>[
        direction && _flexcss.default.hasFlexDirection
    ];
const flexDirections = [
    'row',
    'column',
    'row-reverse'
];
const flexDirectionPropertyMap = {
    default: _flexcss.customProperties.flexDirection,
    smallUp: _flexcss.customProperties.smallUpFlexDirection,
    mediumUp: _flexcss.customProperties.mediumUpFlexDirection,
    largeUp: _flexcss.customProperties.largeUpFlexDirection,
    xLargeUp: _flexcss.customProperties.xLargeUpFlexDirection
};
const getFlexDirectionStyles = (flexDirection)=>({
        ...(flexDirection && (0, _responsive.generateStyle)(flexDirectionPropertyMap, flexDirection))
    });
const flexWraps = [
    'noWrap',
    'wrap'
];
function flexWrapAtom(flexWrap) {
    switch(flexWrap){
        case undefined:
            return;
        case 'noWrap':
            return _flexcss.default.noWrap;
        case 'wrap':
            return _flexcss.default.wrap;
        default:
            throw new _preconditions.UnreachableError(flexWrap);
    }
}
const flexItemBehaviors = [
    'initial',
    'auto',
    'none'
];
function getFlexItemBehaviorClassNames(flex) {
    switch(flex){
        case undefined:
            return;
        case 'initial':
            return _flexcss.default.flexItemInitial;
        case 'auto':
            return _flexcss.default.flexItemAuto;
        case 'none':
            return _flexcss.default.flexItemNone;
        default:
            throw new _preconditions.UnreachableError(flex);
    }
}
const justifyContents = [
    'normal',
    'center',
    'start',
    'end',
    'spaceBetween'
];
function justifyContentAtom(justifyContent, display) {
    if (!justifyContent) return null;
    if (display === 'flex' && (justifyContent === 'start' || justifyContent === 'end'))
    return (0, _alignmentcss.getStyle)(`${justifyContent}FlexJustifyContent`);
    return (0, _alignmentcss.getStyle)(`${justifyContent}JustifyContent`);
}
const alignItems = [
    'stretch',
    'center',
    'start',
    'end'
];
function alignItemsAtom(alignItems, display) {
    if (!alignItems) return null;
    if (display === 'flex' && (alignItems === 'start' || alignItems === 'end'))
    return (0, _alignmentcss.getStyle)(`${alignItems}FlexAlignItems`);
    return (0, _alignmentcss.getStyle)(`${alignItems}AlignItems`);
}
const alignSelves = [
    'stretch',
    'center',
    'start',
    'end'
];
function alignSelfAtom(parentType, alignSelf) {
    if (!alignSelf) return null;
    if (parentType === 'flex' && (alignSelf === 'start' || alignSelf === 'end'))
    return (0, _alignmentcss.getStyle)(`${alignSelf}FlexAlignSelf`);
    return (0, _alignmentcss.getStyle)(`${alignSelf}AlignSelf`);
}
const positions = [
    'static',
    'relative',
    'absolute',
    'sticky'
];
function positionAtom(position) {
    if (!position || position === 'static') return null;
    return (0, _positioncss.getStyle)(`${position}Position`);
}
const positionInsets = [
    '0'
];
function positionInsetAtom(inset) {
    if (!inset) return null;
    return (0, _positioncss.getStyle)(`inset${inset}`);
}
function positionStartAtom(inset) {
    if (!inset) return null;
    return (0, _positioncss.getStyle)(`start${inset}`);
}
function positionEndAtom(inset) {
    if (!inset) return null;
    return (0, _positioncss.getStyle)(`end${inset}`);
}
function positionTopAtom(inset) {
    if (!inset) return null;
    return (0, _positioncss.getStyle)(`top${inset}`);
}
function positionBottomAtom(inset) {
    if (!inset) return null;
    return (0, _positioncss.getStyle)(`bottom${inset}`);
}
