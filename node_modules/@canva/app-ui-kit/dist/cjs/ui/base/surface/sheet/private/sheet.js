"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Sheet", {
    enumerable: true,
    get: function() {
        return Sheet;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _preconditions = require('../../../../../base/preconditions');
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _reacttransitiongroup = require("react-transition-group");
const _keyboard = require('../../../device_capabilities/keyboard');
const _viewport_variance = require('../../../device_capabilities/viewport_variance');
const _visual_viewport = require('../../../device_capabilities/visual_viewport');
const _layer = require('../../../layer/layer');
const _layout = require('../../../layout/layout');
const _metrics = require('../../../metrics/metrics');
const _mobile_event_handler = require('../../../mobile_event_handler/mobile_event_handler');
const _get_safe_area_insets = require('../../../platform_quirks/get_safe_area_insets');
const _provider = require('../../../provider/provider');
const _header = require('../../header/header');
const _content_container = require('../../internal/content_container');
const _scroll_padding = require('../../internal/scroll_padding');
const _behavior = require('../behavior/behavior');
const _content_scrollable = require("./content_scrollable");
const _sheetcss = _interop_require_wildcard(require("./sheet.css"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const Sheet = _react.forwardRef(
    function Sheet({ open, onOpenComplete, onCloseComplete, onBackButton, backdropVisible = true, ...inner }, ref) {
        const Wrapper = (0, _provider.useEnableAnimations)() ? TransitionWrapper : StaticWrapper;
        const handleBackButton = _react.useCallback((event)=>{
            var _inner_onRequestClose;
            if (!open || onBackButton == null && inner.onRequestClose == null) return;
            event.stopPropagation();
            if (onBackButton) {
                onBackButton(event);
                return;
            }
            (_inner_onRequestClose = inner.onRequestClose) === null || _inner_onRequestClose === void 0 ? void 0 : _inner_onRequestClose.call(inner, {
                action: 'backButton'
            });
        }, [
            open,
            onBackButton,
            inner
        ]);
        return (0, _jsxruntime.jsx)(Wrapper, {
            open: open,
            onOpenComplete: onOpenComplete,
            onCloseComplete: onCloseComplete,
            backdropVisible: backdropVisible,
            children: (0, _jsxruntime.jsx)(_mobile_event_handler.MobileEventHandler, {
                onBackButton: handleBackButton,
                children: (0, _jsxruntime.jsx)(SheetInner, {
                    ...inner,
                    backdropVisible: backdropVisible,
                    handleRef: ref
                })
            })
        });
    }
);
const TRANSITION_DURATION = parseInt(_sheetcss.default.transitionTime, 10);
const TRANSITION_CLASS_NAMES = {
    appear: _sheetcss.default.transitioning,
    enter: _sheetcss.default.transitioning,
    exit: _sheetcss.default.transitioning,
    appearActive: _sheetcss.default.visible,
    appearDone: _sheetcss.default.visible,
    enterActive: _sheetcss.default.visible,
    enterDone: _sheetcss.default.visible
};
function TransitionWrapper({ open: propOpen, onOpenComplete, onCloseComplete, backdropVisible, children }) {
    const [transitionOpen, setTransitionOpen] = _react.useState(propOpen);
    const nodeRef = _react.useRef(null);
    return (0, _jsxruntime.jsx)(_layer.Layer, {
        open: propOpen || transitionOpen,
        markOutsideInert: backdropVisible,
        children: (0, _jsxruntime.jsx)(_reacttransitiongroup.CSSTransition, {
            in: propOpen,
            appear: true,
            timeout: TRANSITION_DURATION,
            classNames: TRANSITION_CLASS_NAMES,
            onEnter: ()=>setTransitionOpen(true),
            onEntered: ()=>onOpenComplete === null || onOpenComplete === void 0 ? void 0 : onOpenComplete(),
            onExited: ()=>{
                setTransitionOpen(false);
                onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
            },
            nodeRef: nodeRef,
            children: (0, _jsxruntime.jsx)("div", {
                ref: nodeRef,
                children: children
            })
        })
    });
}
function StaticWrapper({ open, onCloseComplete, backdropVisible, children }) {
    const prevOpen = _react.useRef(open);
    _react.useEffect(()=>{
        if (prevOpen.current && !open)
            onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
        prevOpen.current = open;
    }, [
        open,
        onCloseComplete
    ]);
    return (0, _jsxruntime.jsx)(_layer.Layer, {
        open: open,
        markOutsideInert: backdropVisible,
        children: (0, _jsxruntime.jsx)("div", {
            className: _sheetcss.default.visible,
            children: children
        })
    });
}
const heightMap = {
    ['half']: 50,
    ['full']: 100
};
const dismissPoint = {
    type: 'fixed',
    height: 0
};
function resolveHeight(height) {
    if (height === 'auto') height = {
        autoUpTo: 'full'
    };
    return typeof height === 'string' ? {
        type: 'fixed',
        height: heightMap[height]
    } : {
        type: 'auto',
        height: heightMap[height.autoUpTo]
    };
}
function SheetInner({ handleRef, height = 'auto', scrollToResizeBelow, onRequestClose, onScroll, backdropVisible, handleSafeAreaInsetBottom = true, id, children, title, description, header, headerStart, headerEnd, headerAlignment, headerDivider = 'always', footer, handleVisible = 'auto', ...contentContainerProps }) {
    var _containerRef_current;
    const heights = Array.isArray(height) ? height : [
        height
    ];
    _preconditions.Preconditions.checkArgument(heights.length > 0, 'Sheets require at least one height value');
    const snapPoints = [
        ...heights.map(resolveHeight),
        ...(onRequestClose != null ? [
            dismissPoint
        ] : [])
    ];
    const [snapPointIndex, setSnapPointIndex] = useStabilizedSnapPoint(snapPoints);
    const containerRef = _react.useRef(null);
    const footerRef = _react.useRef(null);
    const contentRef = _react.useRef(null);
    const endMarkerRef = _react.useRef(null);
    _react.useImperativeHandle(handleRef, ()=>({
            setHeight: (height)=>{
                const newPoint = resolveHeight(height);
                const newIndex = snapPoints.findIndex((point)=>pointsEqual(point, newPoint));
                _preconditions.Preconditions.checkArgument(newIndex !== -1);
                setSnapPointIndex(newIndex);
            },
            scrollTo: (options)=>{
                var _contentRef_current;
                return (_contentRef_current = contentRef.current) === null || _contentRef_current === void 0 ? void 0 : _contentRef_current.scrollTo(options);
            },
            getBoundingClientRect: ()=>{
                var _contentRef_current;
                return (_contentRef_current = contentRef.current) === null || _contentRef_current === void 0 ? void 0 : _contentRef_current.getBoundingClientRect();
            },
            get scrollTop () {
                var _contentRef_current;
                return (_contentRef_current = contentRef.current) === null || _contentRef_current === void 0 ? void 0 : _contentRef_current.scrollTop;
            },
            get scrollLeft () {
                var _contentRef_current1;
                return (_contentRef_current1 = contentRef.current) === null || _contentRef_current1 === void 0 ? void 0 : _contentRef_current1.scrollLeft;
            },
            get scrollHeight () {
                var _contentRef_current2;
                return (_contentRef_current2 = contentRef.current) === null || _contentRef_current2 === void 0 ? void 0 : _contentRef_current2.scrollHeight;
            },
            get scrollWidth () {
                var _contentRef_current3;
                return (_contentRef_current3 = contentRef.current) === null || _contentRef_current3 === void 0 ? void 0 : _contentRef_current3.scrollWidth;
            },
            get clientHeight () {
                var _contentRef_current4;
                return (_contentRef_current4 = contentRef.current) === null || _contentRef_current4 === void 0 ? void 0 : _contentRef_current4.clientHeight;
            },
            get clientWidth () {
                var _contentRef_current5;
                return (_contentRef_current5 = contentRef.current) === null || _contentRef_current5 === void 0 ? void 0 : _contentRef_current5.clientWidth;
            },
            get offsetHeight () {
                var _contentRef_current6;
                return (_contentRef_current6 = contentRef.current) === null || _contentRef_current6 === void 0 ? void 0 : _contentRef_current6.offsetHeight;
            },
            get offsetWidth () {
                var _contentRef_current7;
                return (_contentRef_current7 = contentRef.current) === null || _contentRef_current7 === void 0 ? void 0 : _contentRef_current7.offsetWidth;
            }
        }));
    const { resizing, controls } = (0, _behavior.useSheetControls)({
        snapPoints,
        snapPointIndex,
        setSnapPointIndex: (index)=>{
            if (onRequestClose != null && snapPoints[index] === dismissPoint) {
                onRequestClose({
                    action: 'resize'
                });
                return;
            }
            setSnapPointIndex(index);
        },
        getScrollHeight: ()=>{
            var _endMarkerRef_current, _footerRef_current;
            var _endMarkerRef_current_offsetTop;
            const endMarkerTop = (_endMarkerRef_current_offsetTop = (_endMarkerRef_current = endMarkerRef.current) === null || _endMarkerRef_current === void 0 ? void 0 : _endMarkerRef_current.offsetTop) !== null && _endMarkerRef_current_offsetTop !== void 0 ? _endMarkerRef_current_offsetTop : 0;
            var _footerRef_current_clientHeight;
            const footerHeight = (_footerRef_current_clientHeight = (_footerRef_current = footerRef.current) === null || _footerRef_current === void 0 ? void 0 : _footerRef_current.clientHeight) !== null && _footerRef_current_clientHeight !== void 0 ? _footerRef_current_clientHeight : 0;
            const dragHandleContainerHeight = _metrics.baseUnit;
            return dragHandleContainerHeight + endMarkerTop + footerHeight + (0, _get_safe_area_insets.getSafeAreaInsets)().bottom;
        },
        setOffset: (offset, snapPointHeight)=>requestAnimationFrame(()=>{
                const el = containerRef.current;
                if (el == null) return;
                let finalOffset = offset;
                if (offset != null && offset > 0) {
                    if (el.clientHeight === snapPointHeight) finalOffset = undefined;
                }
                el.style.transform = finalOffset != null ? `translateY(${-finalOffset}px)` : '';
                const footerEl = footerRef.current;
                if (footerEl == null) return;
                const footerDisplacementY = el.clientHeight - (snapPointHeight !== null && snapPointHeight !== void 0 ? snapPointHeight : 0);
                footerEl.style.transform = finalOffset != null ? `translateY(${finalOffset - footerDisplacementY}px)` : '';
            })
    });
    const viewportDifferenceHeight = (0, _viewport_variance.useViewportHeightVariance)();
    const visualViewport = (0, _visual_viewport.useViewportContainerSize)();
    const virtualKeyboardHeight = (0, _keyboard.getVirtualKeyboardOverlayHeight)() + 'px';
    const hasHandle = handleVisible === 'auto' && snapPoints.length > 1;
    const snapPoint = snapPoints[snapPointIndex];
    var _containerRef_current_clientHeight;
    const snapHeight = calculateSnapHeight(snapPoint, resizing, (_containerRef_current_clientHeight = (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.clientHeight) !== null && _containerRef_current_clientHeight !== void 0 ? _containerRef_current_clientHeight : 0);
    const onRequestCloseByBackdrop = _react.useCallback(()=>{
        onRequestClose === null || onRequestClose === void 0 ? void 0 : onRequestClose({
            action: 'backdrop'
        });
    }, [
        onRequestClose
    ]);
    const [isScrolled, setIsScrolled] = _react.useState(false);
    const scrollTopRef = _react.useRef(0);
    const handleScroll = _react.useCallback(({ scrollTop })=>{
        onScroll === null || onScroll === void 0 ? void 0 : onScroll({
            scrollTop
        });
        if (headerDivider !== 'when-scrolled') return;
        if (scrollTopRef.current === 0 && scrollTop > 0 || scrollTopRef.current > 0 && scrollTop === 0) {
            scrollTopRef.current = scrollTop;
            setIsScrolled(scrollTop > 0);
        }
    }, [
        onScroll,
        headerDivider,
        setIsScrolled,
        scrollTopRef
    ]);
    const { containerRef: scrollPaddingContainerRef, headerRef: scrollPaddingHeaderRef, footerRef: scrollPaddingFooterRef } = (0, _scroll_padding.useScrollPaddingRefs)();
    let content = (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            children,
            (0, _jsxruntime.jsx)("div", {
                ref: endMarkerRef
            })
        ]
    });
    const showHeaderDivider = headerDivider === 'always' || headerDivider === 'when-scrolled' && isScrolled;
    let endDecorator;
    if (headerEnd == null && onRequestClose != null) endDecorator = (0, _jsxruntime.jsx)(_header.SurfaceHeaderCloseButton, {
        onClick: ()=>onRequestClose()
    });
    else endDecorator = headerEnd === 'none' ? undefined : headerEnd;
    const standardHeader = title != null ? (0, _jsxruntime.jsx)(_header.SurfaceHeader, {
        title: title,
        description: description,
        start: headerStart,
        end: endDecorator,
        alignment: headerAlignment,
        divider: false
    }) : undefined;
    const hasDecorations = standardHeader != null || header != null || footer != null;
    if (hasDecorations) content = (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            (standardHeader != null || header != null) && (0, _jsxruntime.jsxs)("div", {
                ref: scrollPaddingHeaderRef,
                className: (0, _classnames.default)(_sheetcss.default.header, {
                    [_sheetcss.default.headerBorder]: showHeaderDivider
                }),
                children: [
                    standardHeader,
                    header
                ]
            }),
            (0, _jsxruntime.jsx)("div", {
                className: _sheetcss.default.content,
                children: content
            }),
            footer != null && (0, _jsxruntime.jsx)("div", {
                className: _sheetcss.default.footer,
                ref: (0, _composereactrefs.default)(footerRef, scrollPaddingFooterRef),
                children: footer
            })
        ]
    });
    const visualViewportOffsetTop = visualViewport ? `${visualViewport.offsetTop}px` : undefined;
    const visualViewportHeight = visualViewport ? `${visualViewport.height}px` : undefined;
    return (0, _jsxruntime.jsx)("div", {
        className: (0, _classnames.default)(_sheetcss.default.sheetContainer, backdropVisible && _sheetcss.default.backdrop, hasDecorations && _sheetcss.default.hasDecorations),
        style: {
            [_sheetcss.customProperties.visualViewportOffsetTop]: visualViewportOffsetTop,
            [_sheetcss.customProperties.virtualKeyboardHeight]: virtualKeyboardHeight
        },
        children: (0, _jsxruntime.jsx)("div", {
            className: _sheetcss.default.safeAreaHandler,
            style: {
                [_sheetcss.customProperties.viewportDifferenceHeight]: viewportDifferenceHeight
            },
            children: (0, _jsxruntime.jsxs)("div", {
                className: (0, _classnames.default)(_sheetcss.default.sheet, snapPoint.type === 'auto' && _sheetcss.default.auto, resizing && _sheetcss.default.resizing),
                style: {
                    [_sheetcss.customProperties.snapHeight]: snapHeight,
                    [_sheetcss.customProperties.visualViewportHeight]: visualViewportHeight
                },
                ref: containerRef,
                children: [
                    backdropVisible && onRequestClose != null && (0, _jsxruntime.jsx)("div", {
                        role: "none",
                        className: _sheetcss.default.dismissArea,
                        onClick: onRequestCloseByBackdrop
                    }),
                    hasHandle ? (0, _jsxruntime.jsx)(SheetDragHandle, {
                        controls: controls
                    }) : (0, _jsxruntime.jsx)(_layout.Spacer, {
                        size: "1u"
                    }),
                    (0, _jsxruntime.jsx)(SheetContent, {
                        ref: contentRef,
                        scrollPaddingRef: scrollPaddingContainerRef,
                        scrollToResizeBelow: scrollToResizeBelow && resolveHeight(scrollToResizeBelow),
                        controls: controls,
                        handleSafeAreaInsetBottom: handleSafeAreaInsetBottom,
                        id: id,
                        onScroll: handleScroll,
                        ...contentContainerProps,
                        children: content
                    })
                ]
            })
        })
    });
}
function useStabilizedSnapPoint(snapPoints) {
    const [index, setIndex] = _react.useState(0);
    const previousSnapPoints = _react.useRef(snapPoints);
    _react.useLayoutEffect(()=>{
        const previousPoint = previousSnapPoints.current[index];
        if (!pointsEqual(snapPoints[index], previousPoint)) {
            let newIndex = snapPoints.findIndex((point)=>pointsEqual(point, previousPoint));
            if (newIndex === -1) newIndex = 0;
            setIndex(newIndex);
        }
        previousSnapPoints.current = snapPoints;
    }, [
        snapPoints,
        index
    ]);
    return [
        Math.min(index, snapPoints.length - 1),
        setIndex
    ];
}
const pointsEqual = (a, b)=>a != null && b != null && a.type === b.type && a.height === b.height;
function calculateSnapHeight(snapPoint, resizing, containerHeight) {
    switch(snapPoint.type){
        case 'fixed':
            return snapPoint.height + '%';
        case 'auto':
            if (!resizing)
                return snapPoint.height + '%';
            return containerHeight - (0, _get_safe_area_insets.getSafeAreaInsets)().bottom + 'px';
        default:
            throw new _preconditions.UnreachableError(snapPoint);
    }
}
function SheetDragHandle({ controls }) {
    const { dragRef } = (0, _behavior.useSheetDrag)({
        controls
    });
    return (0, _jsxruntime.jsx)("div", {
        className: _sheetcss.default.dragHandleContainer,
        ref: dragRef,
        children: (0, _jsxruntime.jsx)("div", {
            className: _sheetcss.default.dragHandle
        })
    });
}
const SheetContent = _react.forwardRef(
    function SheetContent({ controls, scrollToResizeBelow, handleSafeAreaInsetBottom, onScroll, id, children, scrollPaddingRef, ...contentContainerProps }, ref) {
        const { contentRef } = (0, _behavior.useSheetScroll)({
            controls,
            scrollToResizeBelow
        });
        const { hasScroll, contentScrollRef } = (0, _content_scrollable.useContentScrollable)();
        const imperativeScrollRef = useImperativeScrollRef(ref);
        const handleScroll = _react.useCallback((e)=>{
            var _e_target;
            var _e_target_scrollTop;
            const scrollTop = (_e_target_scrollTop = (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.scrollTop) !== null && _e_target_scrollTop !== void 0 ? _e_target_scrollTop : 0;
            onScroll === null || onScroll === void 0 ? void 0 : onScroll({
                scrollTop
            });
        }, [
            onScroll
        ]);
        return (0, _jsxruntime.jsx)(_content_container.ContentContainer, {
            ref: (0, _composereactrefs.default)(contentRef, contentScrollRef, imperativeScrollRef, scrollPaddingRef),
            id: id,
            className: (0, _classnames.default)(_sheetcss.default.contentContainer, {
                [_sheetcss.default.handleSafeAreaInsetBottom]: handleSafeAreaInsetBottom,
                [_sheetcss.default.noTouchAction]: !hasScroll
            }),
            onScroll: handleScroll,
            ...contentContainerProps,
            children: children
        });
    }
);
function useImperativeScrollRef(ref) {
    const innerRef = _react.useRef(null);
    _react.useImperativeHandle(ref, ()=>({
            scrollTo: (options)=>{
                const el = innerRef === null || innerRef === void 0 ? void 0 : innerRef.current;
                if (el == null) return;
                if (typeof options === 'number') el.scrollTo(0, options);
                else el.scrollTo(options);
            },
            getBoundingClientRect: ()=>{
                var _innerRef_current;
                return (_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.getBoundingClientRect();
            },
            get scrollTop () {
                var _innerRef_current;
                return (_innerRef_current = innerRef.current) === null || _innerRef_current === void 0 ? void 0 : _innerRef_current.scrollTop;
            },
            get scrollLeft () {
                var _innerRef_current1;
                return (_innerRef_current1 = innerRef.current) === null || _innerRef_current1 === void 0 ? void 0 : _innerRef_current1.scrollLeft;
            },
            get scrollHeight () {
                var _innerRef_current2;
                return (_innerRef_current2 = innerRef.current) === null || _innerRef_current2 === void 0 ? void 0 : _innerRef_current2.scrollHeight;
            },
            get scrollWidth () {
                var _innerRef_current3;
                return (_innerRef_current3 = innerRef.current) === null || _innerRef_current3 === void 0 ? void 0 : _innerRef_current3.scrollWidth;
            },
            get clientHeight () {
                var _innerRef_current4;
                return (_innerRef_current4 = innerRef.current) === null || _innerRef_current4 === void 0 ? void 0 : _innerRef_current4.clientHeight;
            },
            get clientWidth () {
                var _innerRef_current5;
                return (_innerRef_current5 = innerRef.current) === null || _innerRef_current5 === void 0 ? void 0 : _innerRef_current5.clientWidth;
            },
            get offsetHeight () {
                var _innerRef_current6;
                return (_innerRef_current6 = innerRef.current) === null || _innerRef_current6 === void 0 ? void 0 : _innerRef_current6.offsetHeight;
            },
            get offsetWidth () {
                var _innerRef_current7;
                return (_innerRef_current7 = innerRef.current) === null || _innerRef_current7 === void 0 ? void 0 : _innerRef_current7.offsetWidth;
            }
        }));
    return innerRef;
}
