"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get Popover () {
        return Popover;
    },
    get isReferenceObject () {
        return isReferenceObject;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _reactmeasure = _interop_require_default(require("react-measure"));
const _reacttransitiongroup = require("react-transition-group");
const _metrics = require('../../../metrics/metrics');
const _provider = require('../../../provider/provider');
const _stable_function = require('../../../stable_function/stable_function');
const _header = require('../../header/header');
const _content_container = require('../../internal/content_container');
const _pin = require('../../pin/pin');
const _arrow = require("./arrow");
const _popovercss = _interop_require_wildcard(require("./popover.css"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const WIDTH_CLASS = {
    ['16u']: _popovercss.default.width16U,
    ['32u']: _popovercss.default.width32U,
    ['40u']: _popovercss.default.width40U,
    ['45u']: _popovercss.default.width45U,
    ['52u']: _popovercss.default.width52U,
    ['reference']: _popovercss.default.widthReference,
    ['auto']: _popovercss.default.widthAuto
};
const isReferenceObject = (reference)=>{
    const refObj = reference;
    return refObj && typeof refObj.getBoundingClientRect === 'function';
};
function Popover({ id: idProp, open, onRequestClose, onCloseComplete, onScroll, blockOutsidePointerEvents = false, reference, placement = 'auto', width = 'auto', widthMode = 'fixed', offset = '1u', arrow = false, children, title, description, header, headerStart, headerEnd, headerAlignment, headerDivider = 'always', footer, ...contentContainerProps }) {
    const defaultId = _react.useId();
    const id = idProp || defaultId;
    const PinComponent = (0, _provider.useEnableAnimations)() ? TransitionPin : StaticPin;
    const contentContainerRef = _react.useRef(null);
    const contentContainerClassName = (0, _classnames.default)(_popovercss.default.contentContainer, WIDTH_CLASS[width], widthMode === 'maximum' && _popovercss.default.widthModeMaximum);
    const onCalculateLayout = _react.useCallback((data)=>{
        const element = contentContainerRef.current;
        if (element == null) return;
        element.style.setProperty(_popovercss.customProperties.referenceWidth, `${Math.floor(data.reference.width)}px`);
        element.style.setProperty(_popovercss.customProperties.availableWidth, `${data.available.width}px`);
        element.style.setProperty(_popovercss.customProperties.availableHeight, `${data.available.height}px`);
    }, []);
    const pinRef = _react.useRef(null);
    const contentHeightRef = _react.useRef(0);
    const updatePinPosition = _react.useCallback(()=>{
        var _pinRef_current;
        (_pinRef_current = pinRef.current) === null || _pinRef_current === void 0 ? void 0 : _pinRef_current.update();
    }, []);
    const onResize = _react.useCallback((contentRect)=>{
        var _contentRect_client;
        var _contentRect_client_height;
        const contentHeight = (_contentRect_client_height = (_contentRect_client = contentRect.client) === null || _contentRect_client === void 0 ? void 0 : _contentRect_client.height) !== null && _contentRect_client_height !== void 0 ? _contentRect_client_height : 0;
        if (contentHeightRef.current !== contentHeight) {
            contentHeightRef.current = contentHeight;
            updatePinPosition();
        }
    }, [
        updatePinPosition
    ]);
    const [isScrolled, setIsScrolled] = _react.useState(false);
    const scrollTopRef = _react.useRef(0);
    const handleScroll = _react.useCallback((e)=>{
        var _e_target;
        var _e_target_scrollTop;
        const scrollTop = (_e_target_scrollTop = (_e_target = e.target) === null || _e_target === void 0 ? void 0 : _e_target.scrollTop) !== null && _e_target_scrollTop !== void 0 ? _e_target_scrollTop : 0;
        onScroll === null || onScroll === void 0 ? void 0 : onScroll({
            scrollTop
        });
        if (headerDivider !== 'when-scrolled') return;
        if (scrollTopRef.current === 0 && scrollTop > 0 || scrollTopRef.current > 0 && scrollTop === 0) {
            scrollTopRef.current = scrollTop;
            setIsScrolled(scrollTop > 0);
        }
    }, [
        onScroll,
        setIsScrolled,
        headerDivider
    ]);
    const showHeaderDivider = headerDivider === 'always' || headerDivider === 'when-scrolled' && isScrolled;
    const onOutsidePointerDown = _react.useCallback(({ target })=>{
        if (onRequestClose && target !== 'reference')
        onRequestClose();
    }, [
        onRequestClose
    ]);
    const resolvedReference = typeof reference === 'function' ? reference({
        disclosure: true,
        pressed: open,
        active: open,
        ariaControls: open ? id : undefined,
        ariaHasPopup: contentContainerProps.role
    }) : reference;
    const standardHeader = title != null ? (0, _jsxruntime.jsx)(_header.SurfaceHeader, {
        title: title,
        description: description,
        start: headerStart,
        end: headerEnd,
        alignment: headerAlignment,
        divider: false
    }) : undefined;
    return (0, _jsxruntime.jsx)(PinComponent, {
        ref: pinRef,
        placement: placement,
        offset: resolveOffset(offset),
        open: open,
        onOutsidePointerDown: onOutsidePointerDown,
        onCloseComplete: onCloseComplete,
        blockOutsidePointerEvents: blockOutsidePointerEvents,
        onCalculateLayout: onCalculateLayout,
        reference: resolvedReference,
        children: ({ setArrow })=>(0, _jsxruntime.jsx)(_reactmeasure.default, {
                onResize: onResize,
                client: true,
                children: ({ measureRef })=>(0, _jsxruntime.jsxs)(_content_container.ContentContainer, {
                        ref: (0, _composereactrefs.default)(contentContainerRef, measureRef),
                        className: contentContainerClassName,
                        id: id,
                        onRequestEscape: onRequestClose,
                        onScroll: handleScroll,
                        ...contentContainerProps,
                        children: [
                            arrow ? (0, _jsxruntime.jsx)(_arrow.Arrow, {
                                ref: setArrow
                            }) : null,
                            (standardHeader != null || header != null) && (0, _jsxruntime.jsxs)("div", {
                                className: (0, _classnames.default)(_popovercss.default.header, {
                                    [_popovercss.default.headerBorder]: showHeaderDivider
                                }),
                                children: [
                                    standardHeader,
                                    header
                                ]
                            }),
                            (0, _jsxruntime.jsx)("div", {
                                className: _popovercss.default.content,
                                children: children
                            }),
                            footer != null && (0, _jsxruntime.jsx)("div", {
                                className: _popovercss.default.footer,
                                children: footer
                            })
                        ]
                    })
            })
    });
}
const TRANSITION_DURATION = parseInt(_popovercss.default.transitionTime, 10);
const TRANSITION_CLASS_NAMES = {
    appear: _popovercss.default.visible,
    appearActive: _popovercss.default.visible,
    appearDone: _popovercss.default.visible,
    enter: _popovercss.default.visible,
    enterActive: _popovercss.default.visible,
    enterDone: _popovercss.default.visible,
    exit: _popovercss.default.hidden,
    exitActive: _popovercss.default.hidden,
    exitDone: _popovercss.default.hidden
};
const TransitionPin = _react.forwardRef(
    function TransitionPin({ open, onCloseComplete, children, ...props }, ref) {
        const [transitionOpen, setTransitionOpen] = _react.useState(open);
        const wrapper = (children)=>
            (0, _jsxruntime.jsx)(SuspendableCssTransition, {
                classNames: TRANSITION_CLASS_NAMES,
                open: open,
                onEnter: ()=>setTransitionOpen(true),
                onExiting: ()=>setTransitionOpen(false),
                onExited: onCloseComplete,
                timeout: TRANSITION_DURATION,
                children: children
            });
        const wrappedChildren = typeof children === 'function' ? (options)=>wrapper(children(options)) : wrapper(children);
        return (0, _jsxruntime.jsx)(_pin.Pin, {
            ...props,
            ref: ref,
            open: open || transitionOpen,
            children: wrappedChildren
        });
    }
);
const StaticPin = _react.forwardRef(function StaticPin({ open, onCloseComplete, children, ...props }, ref) {
    const prevOpen = _react.useRef(open);
    _react.useEffect(()=>{
        if (prevOpen.current && !open)
            onCloseComplete === null || onCloseComplete === void 0 ? void 0 : onCloseComplete();
        prevOpen.current = open;
    }, [
        open,
        onCloseComplete
    ]);
    const wrappedChildren = typeof children === 'function' ? (options)=>(0, _jsxruntime.jsx)("div", {
            className: _popovercss.default.visible,
            children: children(options)
        }) : (0, _jsxruntime.jsx)("div", {
        className: _popovercss.default.visible,
        children: children
    });
    return (0, _jsxruntime.jsx)(_pin.Pin, {
        ...props,
        ref: ref,
        open: open,
        children: wrappedChildren
    });
});
function resolveOffset(offset) {
    if (typeof offset === 'object') return offset;
    return {
        main: offset === '0' ? 0 : parseUnitMultiplier(offset),
        cross: 0
    };
}
const parseUnitMultiplier = (value)=>parseFloat(value.slice(0, -1)) * _metrics.baseUnit;
function SuspendableCssTransition({ children, classNames, onEnter, onExited, onExiting, open, timeout }) {
    const stableOnExiting = (0, _stable_function.useStableFunction)(onExiting !== null && onExiting !== void 0 ? onExiting : ()=>{});
    const stableOnExited = (0, _stable_function.useStableFunction)(onExited !== null && onExited !== void 0 ? onExited : ()=>{});
    const nodeRef = _react.useRef(null);
    _react.useEffect(()=>{
        if (open)
            return;
        const timerId = setTimeout(stableOnExiting, timeout);
        return ()=>clearTimeout(timerId);
    }, [
        timeout,
        stableOnExiting,
        open
    ]);
    _react.useEffect(()=>stableOnExited, [
        stableOnExited
    ]);
    return (0, _jsxruntime.jsx)(_reacttransitiongroup.CSSTransition, {
        in: open,
        appear: true,
        timeout: timeout,
        classNames: classNames,
        onEnter: onEnter,
        nodeRef: nodeRef,
        children: (0, _jsxruntime.jsx)("div", {
            ref: nodeRef,
            children: children
        })
    });
}
