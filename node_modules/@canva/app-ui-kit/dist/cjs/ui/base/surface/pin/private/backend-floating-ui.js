"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useFloatingUiBackend", {
    enumerable: true,
    get: function() {
        return useFloatingUiBackend;
    }
});
const _react = require("@floating-ui/react");
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _react1 = _interop_require_wildcard(require("react"));
const _visual_viewport = require('../../../device_capabilities/visual_viewport');
const _metrics = require('../../../metrics/metrics');
const _provider = require('../../../provider/provider');
const _stable_function = require('../../../stable_function/stable_function');
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const BOUNDARY_PADDING_MAP = {
    ['0']: 0,
    ['1u']: _metrics.baseUnit
};
function useFloatingUiBackend({ placement: backendPlacement, enableFlip, rtlAware, offset: backendOffset, boundary, boundaryPadding: backendBoundaryPadding, onCalculateLayout }) {
    var _middlewareData_hide;
    const arrowRef = _react1.useRef(null);
    const contentRef = _react1.useRef(null);
    const bootstrapDirection = (0, _provider.useDirection)();
    const isRtl = _react1.useCallback(()=>{
        if (!rtlAware) return false;
        return bootstrapDirection === 'RTL';
    }, [
        bootstrapDirection,
        rtlAware
    ]);
    const boundaryPadding = BOUNDARY_PADDING_MAP[backendBoundaryPadding];
    const { stickyPlacement, store, enableStickyPlacementRef, cachedPlacementRef } = useStickyPlacement(boundaryPadding);
    const isRtlDirection = isRtl();
    let floatingUiPlacement = getFloatingUiPlacement(backendPlacement, isRtlDirection);
    if (enableStickyPlacementRef.current && cachedPlacementRef.current != null) floatingUiPlacement = cachedPlacementRef.current;
    const calculateLayout = (0, _stable_function.useStableFunction)(({ placement, reference, content })=>{
        if (onCalculateLayout == null)
            return;
        const visualViewport = (0, _visual_viewport.getVisualViewport)();
        var _visualViewport_width;
        const viewportWidth = (_visualViewport_width = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.width) !== null && _visualViewport_width !== void 0 ? _visualViewport_width : window.innerWidth;
        var _visualViewport_height;
        const viewportHeight = (_visualViewport_height = visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.height) !== null && _visualViewport_height !== void 0 ? _visualViewport_height : window.innerHeight;
        const availableWidth = viewportWidth - 2 * boundaryPadding;
        let availableHeight = viewportHeight - 2 * boundaryPadding;
        const isVerticalPlacement = placement.startsWith('bottom') || placement.startsWith('top');
        if (isVerticalPlacement) {
            const referenceTop = reference.top;
            const referenceBottom = referenceTop + reference.height;
            const availableHeightTop = referenceTop;
            const availableHeightBottom = viewportHeight - referenceBottom;
            const availableHeightFromReference = Math.max(availableHeightTop, availableHeightBottom);
            availableHeight = Math.min(viewportHeight, availableHeightFromReference) - boundaryPadding - backendOffset.main;
        }
        onCalculateLayout({
            reference,
            content,
            available: {
                width: availableWidth,
                height: availableHeight
            }
        });
    });
    const { refs: { setReference, setFloating }, floatingStyles, update, middlewareData, placement } = (0, _react.useFloating)({
        platform: {
            ..._react.platform,
            isRTL: isRtl
        },
        strategy: 'fixed',
        placement: floatingUiPlacement,
        whileElementsMounted: (reference, floating, update)=>{
            const onUpdate = ()=>{
                calculateLayout({
                    placement: floatingUiPlacement,
                    reference: reference.getBoundingClientRect(),
                    content: floating.getBoundingClientRect()
                });
                update();
            };
            return (0, _react.autoUpdate)(reference, floating, onUpdate);
        },
        middleware: [
            enableFlip && stickyPlacement({
                backendOffset
            }),
            (0, _react.offset)({
                mainAxis: backendOffset.main,
                crossAxis: backendOffset.cross
            }),
            enableFlip && !enableStickyPlacementRef.current && (0, _react.flip)({
                flipAlignment: false,
                padding: boundaryPadding,
                boundary: boundary === 'viewport' ? 'clippingAncestors' : boundary,
                rootBoundary: typeof window !== 'undefined' ? getViewportRect() : undefined
            }),
            (0, _react.shift)({
                padding: boundaryPadding,
                crossAxis: true,
                boundary: boundary === 'viewport' ? 'clippingAncestors' : boundary
            }),
            enableFlip && store(),
            (0, _react.arrow)({
                element: arrowRef
            }),
            {
                name: 'hide',
                fn: (state)=>{
                    var _focusElement_ownerDocument;
                    const { rects: { reference } } = state;
                    const focusElement = window.document.activeElement;
                    var _focusElement_ownerDocument_defaultView;
                    const Node = ((_focusElement_ownerDocument_defaultView = focusElement === null || focusElement === void 0 ? void 0 : (_focusElement_ownerDocument = focusElement.ownerDocument) === null || _focusElement_ownerDocument === void 0 ? void 0 : _focusElement_ownerDocument.defaultView) !== null && _focusElement_ownerDocument_defaultView !== void 0 ? _focusElement_ownerDocument_defaultView : window).Node;
                    const isFocusInContent = focusElement instanceof Node && contentRef.current instanceof Node && contentRef.current.contains(focusElement);
                    const enabled = !isFocusInContent && !(reference.width === 0 && reference.height === 0 && reference.x === 0 && reference.y === 0);
                    if (!enabled) return {};
                    return (0, _react.hide)({
                        boundary: boundary === 'viewport' ? getViewportRect() : boundary
                    }).fn(state);
                }
            }
        ]
    });
    _react1.useLayoutEffect(()=>{
        const arrow = arrowRef.current;
        if (arrow != null) updateArrow(arrow, middlewareData, placement);
    }, [
        middlewareData,
        placement
    ]);
    return {
        setReference,
        contentProps: {
            ref: (0, _composereactrefs.default)(setFloating, contentRef),
            style: {
                ...floatingStyles,
                visibility: ((_middlewareData_hide = middlewareData.hide) === null || _middlewareData_hide === void 0 ? void 0 : _middlewareData_hide.referenceHidden) ? 'hidden' : 'visible'
            }
        },
        setArrow: (0, _stable_function.useStableFunction)((arrow)=>{
            arrowRef.current = arrow;
            if (arrow != null) updateArrow(arrow, middlewareData, placement);
        }),
        update
    };
}
const ARROW_ROTATION_MAP = {
    ['left']: '90deg',
    ['right']: '-90deg',
    ['top']: '180deg',
    ['bottom']: '0deg'
};
function updateArrow(arrow, middlewareData, placement) {
    var _middlewareData_arrow, _middlewareData_arrow1;
    const x = (_middlewareData_arrow = middlewareData.arrow) === null || _middlewareData_arrow === void 0 ? void 0 : _middlewareData_arrow.x;
    const y = (_middlewareData_arrow1 = middlewareData.arrow) === null || _middlewareData_arrow1 === void 0 ? void 0 : _middlewareData_arrow1.y;
    const side = placement.split('-')[0];
    arrow.style.setProperty('position', 'absolute');
    arrow.style.setProperty('left', x != null ? `${x}px` : '');
    arrow.style.setProperty('top', y != null ? `${y}px` : '');
    arrow.style.setProperty('right', '');
    arrow.style.setProperty('bottom', '');
    arrow.style.setProperty(side, '100%');
    arrow.style.setProperty('transform', `rotate(${ARROW_ROTATION_MAP[side]})`);
}
const FLOATING_UI_PLACEMENT_MAP = {
    ['start-top']: {
        ltr: 'left-start',
        rtl: 'right-start'
    },
    ['start-center']: {
        ltr: 'left',
        rtl: 'right'
    },
    ['start-bottom']: {
        ltr: 'left-end',
        rtl: 'right-end'
    },
    ['end-top']: {
        ltr: 'right-start',
        rtl: 'left-start'
    },
    ['end-center']: {
        ltr: 'right',
        rtl: 'left'
    },
    ['end-bottom']: {
        ltr: 'right-end',
        rtl: 'left-end'
    },
    ['top-start']: {
        ltr: 'top-start',
        rtl: 'top-start'
    },
    ['top-center']: {
        ltr: 'top',
        rtl: 'top'
    },
    ['top-end']: {
        ltr: 'top-end',
        rtl: 'top-end'
    },
    ['bottom-start']: {
        ltr: 'bottom-start',
        rtl: 'bottom-start'
    },
    ['bottom-center']: {
        ltr: 'bottom',
        rtl: 'bottom'
    },
    ['bottom-end']: {
        ltr: 'bottom-end',
        rtl: 'bottom-end'
    }
};
function getFloatingUiPlacement(placement, isRtl) {
    const mapping = FLOATING_UI_PLACEMENT_MAP[placement];
    return isRtl ? mapping.rtl : mapping.ltr;
}
function useStickyPlacement(boundaryPadding) {
    const contentHeightRef = _react1.useRef(undefined);
    const cachedPlacementRef = _react1.useRef(undefined);
    const enableStickyPlacementRef = _react1.useRef(false);
    const stickyPlacement = (0, _stable_function.useStableFunction)(({ backendOffset })=>({
            name: 'stickyPlacement',
            options: [
                backendOffset
            ],
            fn: ({ rects: { floating }, elements: { reference: referenceEl } })=>{
                if (cachedPlacementRef.current == null)
                    return {};
                const cachedPlacement = cachedPlacementRef.current;
                const viewportHeight = window.innerHeight;
                const referenceRect = referenceEl.getBoundingClientRect();
                const referenceTop = referenceRect.top;
                const additionalPadding = backendOffset.main + boundaryPadding;
                const contentHeight = floating.height;
                let hasEnoughSpaceInCurrentPlacement = false;
                if (cachedPlacement.startsWith('top')) {
                    const availableHeightTop = referenceTop - additionalPadding;
                    hasEnoughSpaceInCurrentPlacement = contentHeight <= availableHeightTop;
                } else if (cachedPlacement.startsWith('bottom')) {
                    const referenceBottom = referenceTop + referenceRect.height;
                    const availableHeightBottom = viewportHeight - referenceBottom - additionalPadding;
                    hasEnoughSpaceInCurrentPlacement = contentHeight <= availableHeightBottom;
                } else return {};
                if (!enableStickyPlacementRef.current && contentHeightRef.current !== contentHeight && hasEnoughSpaceInCurrentPlacement)
                    enableStickyPlacementRef.current = true;
                if (enableStickyPlacementRef.current && !hasEnoughSpaceInCurrentPlacement) {
                    enableStickyPlacementRef.current = false;
                    cachedPlacementRef.current = undefined;
                }
                return {};
            }
        }));
    const store = (0, _stable_function.useStableFunction)(()=>({
            name: 'store',
            fn: ({ placement: currentPlacement, rects: { floating } })=>{
                contentHeightRef.current = floating.height;
                if (!enableStickyPlacementRef.current) cachedPlacementRef.current = currentPlacement;
                return {};
            }
        }));
    return {
        stickyPlacement,
        store,
        enableStickyPlacementRef,
        cachedPlacementRef
    };
}
function getViewportRect() {
    let width = document.documentElement.clientWidth;
    let height = document.documentElement.clientHeight;
    let x = 0;
    let y = 0;
    const visualViewport = (0, _visual_viewport.getVisualViewport)();
    if (visualViewport) {
        width = visualViewport.width;
        height = visualViewport.height;
        x = visualViewport.offsetLeft;
        y = visualViewport.offsetTop;
        const iframe = window.frameElement;
        if (iframe) {
            const iframeRect = iframe.getBoundingClientRect();
            x = visualViewport.offsetLeft - iframeRect.left;
            y = visualViewport.offsetTop - iframeRect.top;
        }
    }
    return {
        x,
        y,
        width,
        height
    };
}
