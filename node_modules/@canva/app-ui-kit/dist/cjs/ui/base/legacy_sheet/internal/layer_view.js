"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get ANIMATION_TIME () {
        return ANIMATION_TIME;
    },
    get LayerView () {
        return LayerView;
    },
    get LayerViewUnMeasured () {
        return _LayerViewUnMeasured;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _make_observable = require('../../../../base/make_observable/make_observable');
const _dispose_on_unmount = require('../../../../base/mobx_react/dispose_on_unmount');
const _observer_for_class = require('../../../../base/mobx_react/observer_for_class');
const _preconditions = require('../../../../base/preconditions');
const _classnames = _interop_require_default(require("classnames"));
const _mobx = _interop_require_wildcard(require("mobx"));
const _react = _interop_require_wildcard(require("react"));
const _reactmeasure = _interop_require_wildcard(require("react-measure"));
const _visual_viewport = require('../../device_capabilities/visual_viewport');
const _gesture_recognizer = require('../../gestures/gesture_recognizer');
const _gesture_recognizer_view = require('../../gestures/gesture_recognizer_view');
const _get_safe_area_insets = require('../../platform_quirks/get_safe_area_insets');
const _overlay = require("./overlay");
const _sheetcss = _interop_require_default(require("./sheet.css"));
const _sheetmessages = require("./sheet.messages");
const _sheet_behavior = require("./sheet_behavior");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function applyDecs2203RFactory() {
    function createAddInitializerMethod(initializers, decoratorFinishedRef) {
        return function addInitializer(initializer) {
            assertNotFinished(decoratorFinishedRef, "addInitializer");
            assertCallable(initializer, "An initializer");
            initializers.push(initializer);
        };
    }
    function memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value) {
        var kindStr;
        switch(kind){
            case 1:
                kindStr = "accessor";
                break;
            case 2:
                kindStr = "method";
                break;
            case 3:
                kindStr = "getter";
                break;
            case 4:
                kindStr = "setter";
                break;
            default:
                kindStr = "field";
        }
        var ctx = {
            kind: kindStr,
            name: isPrivate ? "#" + name : name,
            static: isStatic,
            private: isPrivate,
            metadata: metadata
        };
        var decoratorFinishedRef = {
            v: false
        };
        ctx.addInitializer = createAddInitializerMethod(initializers, decoratorFinishedRef);
        var get, set;
        if (kind === 0) {
            if (isPrivate) {
                get = desc.get;
                set = desc.set;
            } else {
                get = function() {
                    return this[name];
                };
                set = function(v) {
                    this[name] = v;
                };
            }
        } else if (kind === 2) {
            get = function() {
                return desc.value;
            };
        } else {
            if (kind === 1 || kind === 3) {
                get = function() {
                    return desc.get.call(this);
                };
            }
            if (kind === 1 || kind === 4) {
                set = function(v) {
                    desc.set.call(this, v);
                };
            }
        }
        ctx.access = get && set ? {
            get: get,
            set: set
        } : get ? {
            get: get
        } : {
            set: set
        };
        try {
            return dec(value, ctx);
        } finally{
            decoratorFinishedRef.v = true;
        }
    }
    function assertNotFinished(decoratorFinishedRef, fnName) {
        if (decoratorFinishedRef.v) {
            throw new Error("attempted to call " + fnName + " after decoration was finished");
        }
    }
    function assertCallable(fn, hint) {
        if (typeof fn !== "function") {
            throw new TypeError(hint + " must be a function");
        }
    }
    function assertValidReturnValue(kind, value) {
        var type = typeof value;
        if (kind === 1) {
            if (type !== "object" || value === null) {
                throw new TypeError("accessor decorators must return an object with get, set, or init properties or void 0");
            }
            if (value.get !== undefined) {
                assertCallable(value.get, "accessor.get");
            }
            if (value.set !== undefined) {
                assertCallable(value.set, "accessor.set");
            }
            if (value.init !== undefined) {
                assertCallable(value.init, "accessor.init");
            }
        } else if (type !== "function") {
            var hint;
            if (kind === 0) {
                hint = "field";
            } else if (kind === 10) {
                hint = "class";
            } else {
                hint = "method";
            }
            throw new TypeError(hint + " decorators must return a function or void 0");
        }
    }
    function applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata) {
        var decs = decInfo[0];
        var desc, init, value;
        if (isPrivate) {
            if (kind === 0 || kind === 1) {
                desc = {
                    get: decInfo[3],
                    set: decInfo[4]
                };
            } else if (kind === 3) {
                desc = {
                    get: decInfo[3]
                };
            } else if (kind === 4) {
                desc = {
                    set: decInfo[3]
                };
            } else {
                desc = {
                    value: decInfo[3]
                };
            }
        } else if (kind !== 0) {
            desc = Object.getOwnPropertyDescriptor(base, name);
        }
        if (kind === 1) {
            value = {
                get: desc.get,
                set: desc.set
            };
        } else if (kind === 2) {
            value = desc.value;
        } else if (kind === 3) {
            value = desc.get;
        } else if (kind === 4) {
            value = desc.set;
        }
        var newValue, get, set;
        if (typeof decs === "function") {
            newValue = memberDec(decs, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
            if (newValue !== void 0) {
                assertValidReturnValue(kind, newValue);
                if (kind === 0) {
                    init = newValue;
                } else if (kind === 1) {
                    init = newValue.init;
                    get = newValue.get || value.get;
                    set = newValue.set || value.set;
                    value = {
                        get: get,
                        set: set
                    };
                } else {
                    value = newValue;
                }
            }
        } else {
            for(var i = decs.length - 1; i >= 0; i--){
                var dec = decs[i];
                newValue = memberDec(dec, name, desc, initializers, kind, isStatic, isPrivate, metadata, value);
                if (newValue !== void 0) {
                    assertValidReturnValue(kind, newValue);
                    var newInit;
                    if (kind === 0) {
                        newInit = newValue;
                    } else if (kind === 1) {
                        newInit = newValue.init;
                        get = newValue.get || value.get;
                        set = newValue.set || value.set;
                        value = {
                            get: get,
                            set: set
                        };
                    } else {
                        value = newValue;
                    }
                    if (newInit !== void 0) {
                        if (init === void 0) {
                            init = newInit;
                        } else if (typeof init === "function") {
                            init = [
                                init,
                                newInit
                            ];
                        } else {
                            init.push(newInit);
                        }
                    }
                }
            }
        }
        if (kind === 0 || kind === 1) {
            if (init === void 0) {
                init = function(instance, init) {
                    return init;
                };
            } else if (typeof init !== "function") {
                var ownInitializers = init;
                init = function(instance, init) {
                    var value = init;
                    for(var i = 0; i < ownInitializers.length; i++){
                        value = ownInitializers[i].call(instance, value);
                    }
                    return value;
                };
            } else {
                var originalInitializer = init;
                init = function(instance, init) {
                    return originalInitializer.call(instance, init);
                };
            }
            ret.push(init);
        }
        if (kind !== 0) {
            if (kind === 1) {
                desc.get = value.get;
                desc.set = value.set;
            } else if (kind === 2) {
                desc.value = value;
            } else if (kind === 3) {
                desc.get = value;
            } else if (kind === 4) {
                desc.set = value;
            }
            if (isPrivate) {
                if (kind === 1) {
                    ret.push(function(instance, args) {
                        return value.get.call(instance, args);
                    });
                    ret.push(function(instance, args) {
                        return value.set.call(instance, args);
                    });
                } else if (kind === 2) {
                    ret.push(value);
                } else {
                    ret.push(function(instance, args) {
                        return value.call(instance, args);
                    });
                }
            } else {
                Object.defineProperty(base, name, desc);
            }
        }
    }
    function applyMemberDecs(Class, decInfos, metadata) {
        var ret = [];
        var protoInitializers;
        var staticInitializers;
        var existingProtoNonFields = new Map();
        var existingStaticNonFields = new Map();
        for(var i = 0; i < decInfos.length; i++){
            var decInfo = decInfos[i];
            if (!Array.isArray(decInfo)) continue;
            var kind = decInfo[1];
            var name = decInfo[2];
            var isPrivate = decInfo.length > 3;
            var isStatic = kind >= 5;
            var base;
            var initializers;
            if (isStatic) {
                base = Class;
                kind = kind - 5;
                staticInitializers = staticInitializers || [];
                initializers = staticInitializers;
            } else {
                base = Class.prototype;
                protoInitializers = protoInitializers || [];
                initializers = protoInitializers;
            }
            if (kind !== 0 && !isPrivate) {
                var existingNonFields = isStatic ? existingStaticNonFields : existingProtoNonFields;
                var existingKind = existingNonFields.get(name) || 0;
                if (existingKind === true || existingKind === 3 && kind !== 4 || existingKind === 4 && kind !== 3) {
                    throw new Error("Attempted to decorate a public method/accessor that has the same name as a previously decorated public method/accessor. This is not currently supported by the decorators plugin. Property name was: " + name);
                } else if (!existingKind && kind > 2) {
                    existingNonFields.set(name, kind);
                } else {
                    existingNonFields.set(name, true);
                }
            }
            applyMemberDec(ret, base, decInfo, name, kind, isStatic, isPrivate, initializers, metadata);
        }
        pushInitializers(ret, protoInitializers);
        pushInitializers(ret, staticInitializers);
        return ret;
    }
    function pushInitializers(ret, initializers) {
        if (initializers) {
            ret.push(function(instance) {
                for(var i = 0; i < initializers.length; i++){
                    initializers[i].call(instance);
                }
                return instance;
            });
        }
    }
    function applyClassDecs(targetClass, classDecs, metadata) {
        if (classDecs.length > 0) {
            var initializers = [];
            var newClass = targetClass;
            var name = targetClass.name;
            for(var i = classDecs.length - 1; i >= 0; i--){
                var decoratorFinishedRef = {
                    v: false
                };
                try {
                    var nextNewClass = classDecs[i](newClass, {
                        kind: "class",
                        name: name,
                        addInitializer: createAddInitializerMethod(initializers, decoratorFinishedRef),
                        metadata
                    });
                } finally{
                    decoratorFinishedRef.v = true;
                }
                if (nextNewClass !== undefined) {
                    assertValidReturnValue(10, nextNewClass);
                    newClass = nextNewClass;
                }
            }
            return [
                defineMetadata(newClass, metadata),
                function() {
                    for(var i = 0; i < initializers.length; i++){
                        initializers[i].call(newClass);
                    }
                }
            ];
        }
    }
    function defineMetadata(Class, metadata) {
        return Object.defineProperty(Class, Symbol.metadata || Symbol.for("Symbol.metadata"), {
            configurable: true,
            enumerable: true,
            value: metadata
        });
    }
    return function applyDecs2203R(targetClass, memberDecs, classDecs, parentClass) {
        if (parentClass !== void 0) {
            var parentMetadata = parentClass[Symbol.metadata || Symbol.for("Symbol.metadata")];
        }
        var metadata = Object.create(parentMetadata === void 0 ? null : parentMetadata);
        var e = applyMemberDecs(targetClass, memberDecs, metadata);
        if (!classDecs.length) defineMetadata(targetClass, metadata);
        return {
            e: e,
            get c () {
                return applyClassDecs(targetClass, classDecs, metadata);
            }
        };
    };
}
function _apply_decs_2203_r(targetClass, memberDecs, classDecs, parentClass) {
    return (_apply_decs_2203_r = applyDecs2203RFactory())(targetClass, memberDecs, classDecs, parentClass);
}
function _identity(x) {
    return x;
}
var _class;
var _initClass, _React_Component;
const ANIMATION_TIME = parseInt(_sheetcss.default.animationTime, 10);
const HANDLE_HEIGHT = parseInt(_sheetcss.default.handleSize, 10);
const DRAGGING_THRESHOLD_MULTIPLIER = 0.2;
const VELOCITY_THRESHOLD = 1;
let _LayerViewUnMeasured;
new (_class = class extends _identity {
    constructor(){
        super(_LayerViewUnMeasured), _initClass();
    }
}, (()=>{
    class LayerViewUnMeasured extends (_React_Component = _react.Component) {
        static _makeObservable(instance) {
            (0, _make_observable.makeObservable)(instance, {
                viewContainerStyle: _mobx.observable.struct,
                updateViewContainerStyle: _mobx.action.bound,
                onPreviousTransitionEnd: _mobx.action,
                onContainerTransitionEnd: _mobx.action
            });
        }
        get safeAreaInsetTop() {
            const current = this.props.layer.current;
            const hasHandle = !!this.maybeGetRecognizers(current);
            return current == null || current.applyInsetStyles || hasHandle ? (0, _get_safe_area_insets.getSafeAreaInsets)().top : 0;
        }
        get maxVisibleSize() {
            const { current } = this.props.layer;
            if (!(current === null || current === void 0 ? void 0 : current.props.enableLayerDraggable)) return undefined;
            return current.props.maxVisibleSizePx;
        }
        get measuredSize() {
            const { layer, contentRect } = this.props;
            const { width, height } = contentRect.bounds;
            var _ref;
            const measuredSize = (_ref = layer.isHorizontal ? width : height) !== null && _ref !== void 0 ? _ref : 0;
            return Math.max(0, measuredSize);
        }
        get viewportSize() {
            const { props: { layer }, viewContainerStyle: { width, height } } = this;
            return layer.isHorizontal ? width : height;
        }
        maybeGetRecognizers(sheet) {
            if (sheet == null) return;
            const { props: { enableLayerDraggable }, sheetDragInternal } = sheet;
            return enableLayerDraggable ? this.recognizers : sheetDragInternal === null || sheetDragInternal === void 0 ? void 0 : sheetDragInternal.recognizers;
        }
        render() {
            const { contentRect, layer } = this.props;
            const { current, previous, hasOuterContent, enableAnimations } = layer;
            const { style, className } = this.getContainerStyles();
            const outerContentStyles = this.getOuterContentStyles();
            const sheetBehavior = current && current.sheetDragInternal && current.sheetDragInternal.sheetBehavior;
            const overlayOpacity = (sheetBehavior === null || sheetBehavior === void 0 ? void 0 : sheetBehavior.transparentOverlay) ? 'transparent' : current === null || current === void 0 ? void 0 : current.props.overlayOpacity;
            const showOverlay = Boolean(current && current.show && current.props.overlay
             && contentRect && contentRect.bounds && contentRect.bounds.width != null);
            return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                children: [
                    (0, _jsxruntime.jsx)(_overlay.Overlay, {
                        ariaLabel: (current === null || current === void 0 ? void 0 : current.props.closeSheetText) || _sheetmessages.SheetMessages.closeSheetText(),
                        show: showOverlay,
                        opacity: overlayOpacity,
                        transitionTimeout: enableAnimations ? ANIMATION_TIME : 0,
                        onClick: this.onClickOverlay
                    }),
                    (0, _jsxruntime.jsxs)("div", {
                        id: current === null || current === void 0 ? void 0 : current.props.id,
                        role: (current === null || current === void 0 ? void 0 : current.props.role) || undefined,
                        "aria-roledescription": current === null || current === void 0 ? void 0 : current.props.ariaRoleDescription,
                        className: _sheetcss.default.viewContainer,
                        style: this.viewContainerStyle,
                        ref: this.viewContainerRef,
                        children: [
                            hasOuterContent && (0, _jsxruntime.jsxs)("div", {
                                className: (0, _classnames.default)(_sheetcss.default.outerContainer, !enableAnimations && _sheetcss.default.disableAnimations),
                                style: outerContentStyles,
                                children: [
                                    previous && (0, _jsxruntime.jsx)("div", {
                                        className: current ? _sheetcss.default.hiddenSheet : _sheetcss.default.visibleSheet,
                                        ref: this.previousOuterContentRef
                                    }, previous.id),
                                    current && (0, _jsxruntime.jsx)("div", {
                                        className: previous ? _sheetcss.default.hiddenSheet : _sheetcss.default.visibleSheet,
                                        ref: this.currentOuterContentRef
                                    }, current.id)
                                ]
                            }),
                            (0, _jsxruntime.jsxs)("div", {
                                className: className,
                                style: style,
                                onTransitionEnd: this.onContainerTransitionEnd,
                                ref: this.containerRef,
                                children: [
                                    previous && (0, _jsxruntime.jsx)("div", {
                                        className: current ? _sheetcss.default.hiddenSheet : _sheetcss.default.visibleSheet,
                                        style: previous.contentStyles,
                                        onTransitionEnd: this.onPreviousTransitionEnd,
                                        ref: this.previousContentRef,
                                        children: (0, _jsxruntime.jsx)(DragHandle, {
                                            recognizers: this.maybeGetRecognizers(previous),
                                            contrastHandle: previous.props.overlay
                                        })
                                    }, previous.id),
                                    current && (0, _jsxruntime.jsx)("div", {
                                        className: previous ? _sheetcss.default.hiddenSheet : _sheetcss.default.visibleSheet,
                                        tabIndex: -1,
                                        style: current.contentStyles,
                                        ref: this.currentContentRef,
                                        children: (0, _jsxruntime.jsx)(DragHandle, {
                                            recognizers: this.maybeGetRecognizers(current),
                                            contrastHandle: current.props.overlay
                                        })
                                    }, current.id),
                                    (current === null || current === void 0 ? void 0 : current.applyInsetStyles) && !current.props.sheetContainsTextInput && (0, _jsxruntime.jsx)(_reactmeasure.default, {
                                        bounds: true,
                                        onResize: this.onSafeAreaResize,
                                        children: ({ measureRef })=>(0, _jsxruntime.jsx)("div", {
                                                ref: measureRef,
                                                className: _sheetcss.default.safeAreaObserver
                                            })
                                    })
                                ]
                            })
                        ]
                    })
                ]
            });
        }
        componentDidMount() {
            const visualViewport = (0, _visual_viewport.getVisualViewport)(this.props.window);
            if (visualViewport) {
                this.updateViewContainerStyle();
                visualViewport.addEventListener('resize', this.updateViewContainerStyle);
                visualViewport.addEventListener('scroll', this.updateViewContainerStyle);
                (0, _dispose_on_unmount.disposeOnUnmount)(this, ()=>{
                    visualViewport.removeEventListener('resize', this.updateViewContainerStyle);
                    visualViewport.removeEventListener('scroll', this.updateViewContainerStyle);
                });
            }
            (0, _dispose_on_unmount.disposeOnUnmount)(this, [
                _mobx.autorun(() => {
                    var _current_sheetDragInternal;
                    const { layer: { current } } = this.props;
                    const sheetBehavior = current === null || current === void 0 ? void 0 : (_current_sheetDragInternal = current.sheetDragInternal) === null || _current_sheetDragInternal === void 0 ? void 0 : _current_sheetDragInternal.sheetBehavior;
                    const { current: containerElement } = this.containerRef;
                    if (!sheetBehavior || !containerElement) return;
                    containerElement.style.transform = sheetBehavior.containerTransform;
                    containerElement.style.transition = sheetBehavior.containerTransition;
                }, {
                    scheduler: requestAnimationFrame
                }),
                _mobx.reaction(()=>{
                    var _this_props_layer_current;
                    return (_this_props_layer_current = this.props.layer.current) === null || _this_props_layer_current === void 0 ? void 0 : _this_props_layer_current.show;
                }, (shown)=>{
                    const { current: containerElement } = this.containerRef;
                    if (shown || !containerElement) return;
                    containerElement.style.transition = '';
                }),
                _mobx.reaction(()=>{
                    var _this_props_layer_current_sheetDragInternal_sheetBehavior, _this_props_layer_current_sheetDragInternal, _this_props_layer_current;
                    return (_this_props_layer_current = this.props.layer.current) === null || _this_props_layer_current === void 0 ? void 0 : (_this_props_layer_current_sheetDragInternal = _this_props_layer_current.sheetDragInternal) === null || _this_props_layer_current_sheetDragInternal === void 0 ? void 0 : (_this_props_layer_current_sheetDragInternal_sheetBehavior = _this_props_layer_current_sheetDragInternal.sheetBehavior) === null || _this_props_layer_current_sheetDragInternal_sheetBehavior === void 0 ? void 0 : _this_props_layer_current_sheetDragInternal_sheetBehavior.containerMaxSizeInPeek;
                }, (maxSize)=>{
                    const { current: containerElement } = this.containerRef;
                    if (maxSize || !containerElement) return;
                    containerElement.style.maxHeight = '';
                }, {
                    scheduler: requestAnimationFrame
                }),
                _mobx.reaction(()=>{
                    var _this_props_layer_current_sheetDragInternal_sheetBehavior, _this_props_layer_current_sheetDragInternal, _this_props_layer_current;
                    return (_this_props_layer_current = this.props.layer.current) === null || _this_props_layer_current === void 0 ? void 0 : (_this_props_layer_current_sheetDragInternal = _this_props_layer_current.sheetDragInternal) === null || _this_props_layer_current_sheetDragInternal === void 0 ? void 0 : (_this_props_layer_current_sheetDragInternal_sheetBehavior = _this_props_layer_current_sheetDragInternal.sheetBehavior) === null || _this_props_layer_current_sheetDragInternal_sheetBehavior === void 0 ? void 0 : _this_props_layer_current_sheetDragInternal_sheetBehavior.containerMaxSizeInPeek;
                }, (maxSize)=>{
                    const { current: containerElement } = this.containerRef;
                    if (!maxSize || !containerElement) return;
                    containerElement.style.maxHeight = maxSize;
                }, {
                    delay: ANIMATION_TIME
                })
            ]);
        }
        updateViewContainerStyle() {
            const visualViewport = _preconditions.Preconditions.checkExists((0, _visual_viewport.getVisualViewport)(this.props.window));
            const widthDelta = visualViewport.width - this.viewContainerStyle.width;
            const heightDelta = visualViewport.height - this.viewContainerStyle.height;
            this.viewportResizeDirection = this.props.layer.isHorizontal ? widthDelta : heightDelta;
            this.didViewportResize = widthDelta !== 0 || heightDelta !== 0;
            this.viewportResizeDirection < 0 && (this.trackedMeasure = this.measuredSize);
            const localViewport = _preconditions.Preconditions.checkExists((0, _visual_viewport.getViewportContainerSize)(this.props.window));
            this.viewContainerStyle = {
                left: localViewport.offsetLeft,
                top: localViewport.offsetTop,
                width: localViewport.width,
                height: localViewport.height
            };
            const { layer: { current } } = this.props;
            const sheetBehavior = current && current.sheetDragInternal && current.sheetDragInternal.sheetBehavior;
            if (sheetBehavior) sheetBehavior.onViewportHeightChanges(visualViewport.height);
        }
        componentDidUpdate() {
            var _this_currentRef,
            _activeElement_scrollIntoView;
            const { layer: { current, previous }, contentRect: { bounds } } = this.props;
            const onContentResize = !previous && current && current.props.onContentResize;
            const handleHeight = (current === null || current === void 0 ? void 0 : current.props.enableLayerDraggable) ? HANDLE_HEIGHT : 0;
            if (onContentResize && bounds && bounds.height !== handleHeight) onContentResize(bounds);
            const globalWindow = window;
            const { window: propWindow } = this.props;
            const activeElement = propWindow.document.activeElement;
            if (this.didViewportResize && (current === null || current === void 0 ? void 0 : current.show) && activeElement != null && isInputElement(activeElement, globalWindow) && ((_this_currentRef = this.currentRef) === null || _this_currentRef === void 0 ? void 0 : _this_currentRef.contains(activeElement))) (_activeElement_scrollIntoView = activeElement.scrollIntoView) === null || _activeElement_scrollIntoView === void 0 ? void 0 : _activeElement_scrollIntoView.call(activeElement, {
                block: 'center',
                inline: 'center'
            });
            window.requestAnimationFrame(()=>{
                this.viewportResizeDirection = 0;
                this.didViewportResize = false;
            });
            if (this.currentRef && current && current.autoFocusOnOpen && this.currentFocused !== current.id) {
                this.currentFocused = current.id;
                this.currentRef.focus();
            } else if (!current || !current.props.open)
            this.currentFocused = undefined;
            if (current && current.sheetDragInternal) {
                const sheetBehavior = current.sheetDragInternal.sheetBehavior;
                sheetBehavior && bounds && sheetBehavior.configureBounds(bounds, !!current.props.open);
            }
        }
        maybeTriggerTopOfLayerChange(sheet, onTop) {
            sheet && sheet.props.onTopOfLayerChange && sheet.props.onTopOfLayerChange(onTop);
        }
        createLayerContainer() {
            const element = this.props.window.document.createElement('div');
            element.classList.add(_sheetcss.default.layerContainer);
            return element;
        }
        getContainerSize() {
            const { layer } = this.props;
            if (!(layer.current && layer.current.show))
            return 0;
            const measuredSize = this.measuredSize;
            if (measuredSize <= 0)
            return 0;
            const viewportSizeWithOffset = layer.isHorizontal ? this.viewportSize : this.viewportSize - this.safeAreaInsetTop;
            if (layer.current.props.enableLayerDraggable && this.viewportResizeDirection > 0)
                return Math.min(viewportSizeWithOffset, Math.max(this.trackedMeasure, measuredSize));
            var _ref;
            const peekSizePx = (_ref = layer.current && layer.current.sheetDragInternal && layer.current.sheetDragInternal.sheetBehavior && layer.current.sheetDragInternal.sheetBehavior.peekSizePx) !== null && _ref !== void 0 ? _ref : 0;
            if (peekSizePx > 0) return peekSizePx;
            if (this.maxVisibleSize != null)
                return Math.min(viewportSizeWithOffset, Math.min(measuredSize, this.maxVisibleSize));
            return Math.min(viewportSizeWithOffset, measuredSize);
        }
        get sheetContentContainerStyles() {
            const { layer: { current } } = this.props;
            const backgroundColor = current === null || current === void 0 ? void 0 : current.props.backgroundColor;
            const isFullScreen = current === null || current === void 0 ? void 0 : current.isFullscreen;
            const roundedCorners = !isFullScreen && (current === null || current === void 0 ? void 0 : current.roundedCorners) === true;
            const hasHandle = !!this.maybeGetRecognizers(current);
            const className = (0, _classnames.default)(_sheetcss.default.contentContainer, {
                [_sheetcss.default.roundedCorners]: roundedCorners,
                [_sheetcss.default.hasShadow]: current === null || current === void 0 ? void 0 : current.props.hasShadow,
                [_sheetcss.default.hasHandle]: hasHandle
            });
            return {
                className,
                style: {
                    backgroundColor
                }
            };
        }
        getContainerStyles() {
            var _current_sheetDragInternal_sheetBehavior, _current_sheetDragInternal;
            const { layer } = this.props;
            const { current, from, enableAnimations } = layer;
            const isFullScreen = current === null || current === void 0 ? void 0 : current.isFullscreen;
            const sheetContainerStyles = !this.maybeGetRecognizers(current) ? this.sheetContentContainerStyles : undefined;
            const backgroundColor = sheetContainerStyles && sheetContainerStyles.style.backgroundColor;
            const size = this.getContainerSize();
            this.visibleAreaSize = size;
            const viewportWithOffset = this.viewportSize - this.safeAreaInsetTop;
            const containerMaxSizeInPeek = current === null || current === void 0 ? void 0 : (_current_sheetDragInternal = current.sheetDragInternal) === null || _current_sheetDragInternal === void 0 ? void 0 : (_current_sheetDragInternal_sheetBehavior = _current_sheetDragInternal.sheetBehavior) === null || _current_sheetDragInternal_sheetBehavior === void 0 ? void 0 : _current_sheetDragInternal_sheetBehavior.containerMaxSizeInPeek;
            const maxPeekHeight = containerMaxSizeInPeek === '' ? undefined : containerMaxSizeInPeek;
            const maxFullHeight = this.maxVisibleSize ? `${Math.min(viewportWithOffset, this.maxVisibleSize)}px` : viewportWithOffset;
            const maxHeight = maxPeekHeight !== null && maxPeekHeight !== void 0 ? maxPeekHeight : maxFullHeight;
            const isSheetVisible = size > 0;
            const commonClassNames = (0, _classnames.default)(sheetContainerStyles === null || sheetContainerStyles === void 0 ? void 0 : sheetContainerStyles.className, current === null || current === void 0 ? void 0 : current.themeClass, {
                [_sheetcss.default.applyInsets]: (current === null || current === void 0 ? void 0 : current.applyInsetStyles) && !(current === null || current === void 0 ? void 0 : current.props.sheetContainsTextInput),
                [_sheetcss.default.containsTextInput]: current === null || current === void 0 ? void 0 : current.props.sheetContainsTextInput,
                [_sheetcss.default.disableAnimations]: !enableAnimations,
                [_sheetcss.default.slideIn]: !this.didViewportResize && isSheetVisible,
                [_sheetcss.default.slideOut]: !this.didViewportResize && !isSheetVisible,
                [_sheetcss.default.displayOverflow]: (current === null || current === void 0 ? void 0 : current.props.enableOverflow) === true
            });
            switch(from){
                case 'top':
                    return {
                        style: {
                            transform: `translateY(${size}px)`,
                            backgroundColor
                        },
                        className: (0, _classnames.default)(_sheetcss.default.top, commonClassNames)
                    };
                case 'bottom':
                    return {
                        style: !enableAnimations && isFullScreen ? {
                            top: 0,
                            backgroundColor
                        } : {
                            transform: `translateY(-${size}px)`,
                            backgroundColor,
                            maxHeight
                        },
                        className: (0, _classnames.default)(_sheetcss.default.bottom, commonClassNames, {
                            [_sheetcss.default.top]: isFullScreen && !enableAnimations
                        })
                    };
                case 'left':
                    return {
                        style: {
                            transform: `translateX(${size}px)`,
                            backgroundColor
                        },
                        className: (0, _classnames.default)(_sheetcss.default.left, commonClassNames)
                    };
                case 'right':
                    return {
                        style: {
                            transform: `translateX(-${size}px)`,
                            backgroundColor
                        },
                        className: (0, _classnames.default)(_sheetcss.default.right, commonClassNames)
                    };
                default:
                    throw new _preconditions.UnreachableError(from);
            }
        }
        getOuterContentStyles() {
            const { from, isHorizontal } = this.props.layer;
            const size = this.getContainerSize();
            return isHorizontal ? {
                width: `calc(100% - ${size}px)`,
                top: 0,
                bottom: 0,
                left: from === 'left' ? undefined : 0,
                right: from === 'right' ? undefined : 0
            } : {
                height: `calc(100% - ${size}px)`,
                left: 0,
                right: 0,
                top: from === 'top' ? undefined : 0,
                bottom: from === 'bottom' ? undefined : 0
            };
        }
        constructor(...args){
            super(...args), this.containerRef = (_LayerViewUnMeasured._makeObservable(this), _react.createRef()), this.viewContainerStyle = {
                width: this.props.window.innerWidth,
                height: this.props.window.innerHeight,
                top: 0,
                left: 0
            },
            this.viewportResizeDirection = 0, this.didViewportResize = false,
            this.trackedMeasure = 0, this.visibleAreaSize = 0, this.initialTransform = '', this.initialMaxHeight = '', this.onDraggableHandlePanStart = ()=>{
                var _this_props_layer_current;
                if (!((_this_props_layer_current = this.props.layer.current) === null || _this_props_layer_current === void 0 ? void 0 : _this_props_layer_current.props.enableLayerDraggable) || !this.containerRef.current) return;
                this.initialTransform = this.containerRef.current.style.transform;
                this.initialMaxHeight = this.containerRef.current.style.maxHeight;
                this.containerRef.current.style.maxHeight = '';
                this.containerRef.current.style.transition = 'none';
            }, this.onDraggableHandlePanMove = (e)=>{
                var _this_props_layer_current;
                if (!((_this_props_layer_current = this.props.layer.current) === null || _this_props_layer_current === void 0 ? void 0 : _this_props_layer_current.props.enableLayerDraggable) || !this.containerRef.current) return;
                if ((0, _sheet_behavior.isVerticalDirection)(e)) {
                    const nextSize = this.visibleAreaSize - e.distanceY;
                    const clampedNextSize = Math.max(0, Math.min(this.measuredSize, nextSize));
                    this.containerRef.current.style.transform = `translateY(-${clampedNextSize}px)`;
                }
            }, this.onDraggableHandlePanEnd = (e)=>{
                var _this_props_layer_current;
                if (!((_this_props_layer_current = this.props.layer.current) === null || _this_props_layer_current === void 0 ? void 0 : _this_props_layer_current.props.enableLayerDraggable) || !this.containerRef.current) return;
                this.containerRef.current.style.transition = '';
                this.containerRef.current.style.transform = this.initialTransform;
                this.containerRef.current.style.maxHeight = this.initialMaxHeight;
                const { onLayerDraggingThresholdTriggered } = this.props.layer.current.props;
                const direction = e.distanceY < 0 ? 'opening' : 'closing';
                const draggingThreshold = this.visibleAreaSize * DRAGGING_THRESHOLD_MULTIPLIER;
                const passedDraggingThreshold = Math.abs(e.distanceY) > draggingThreshold;
                const passedVelocityThreshold = Math.abs(e.velocityY) > VELOCITY_THRESHOLD;
                if (passedDraggingThreshold || passedVelocityThreshold) onLayerDraggingThresholdTriggered && onLayerDraggingThresholdTriggered({
                    direction
                });
            }, this.recognizers = this.props.layer.from === 'bottom' ? [
                new _gesture_recognizer.PanRecognizer({
                    minDistance: 4,
                    direction: 'vertical',
                    onStart: this.onDraggableHandlePanStart,
                    onMove: this.onDraggableHandlePanMove,
                    onEnd: this.onDraggableHandlePanEnd
                })
            ] : undefined, this.onClickOverlay = ()=>{
                var _layer_current_props_onRequestClose, _layer_current, _layer_current_props;
                const { layer } = this.props;
                (_layer_current = layer.current) === null || _layer_current === void 0 ? void 0 : (_layer_current_props_onRequestClose = (_layer_current_props = _layer_current.props).onRequestClose) === null || _layer_current_props_onRequestClose === void 0 ? void 0 : _layer_current_props_onRequestClose.call(_layer_current_props, {
                    action: 'backdrop'
                });
            }, this.contentParentLayerContainer = this.createLayerContainer(), this.viewContainerRef = (ref)=>{
                var _this_viewContainerReactionDisposer, _this;
                (_this_viewContainerReactionDisposer = (_this = this).viewContainerReactionDisposer) === null || _this_viewContainerReactionDisposer === void 0 ? void 0 : _this_viewContainerReactionDisposer.call(_this);
                if (ref == null) return;
                ref.appendChild(this.contentParentLayerContainer);
                this.viewContainerReactionDisposer = _mobx.reaction(()=>this.props.layer.current, (currentLayer, previousLayer)=>{
                    if (previousLayer != null)
                        previousLayer.parentLayerContainer = undefined;
                    if (currentLayer != null)
                        currentLayer.parentLayerContainer = this.contentParentLayerContainer;
                }, {
                    fireImmediately: true
                });
            }, this.previousContentRef = (ref)=>{
                const { previous } = this.props.layer;
                const element = previous && previous.contentElement;
                if (ref && element) {
                    const elementToAdd = this.maybeGetRecognizers(previous) ? applySheetContainerStylesTo(element, this.sheetContentContainerStyles) : element;
                    ref.appendChild(elementToAdd);
                    this.maybeTriggerTopOfLayerChange(previous, false);
                }
            }, this.currentContentRef = (ref)=>{
                const { layer, measureRef } = this.props;
                const { current } = layer;
                const element = current && current.contentElement;
                if (ref && element) {
                    const elementToAdd = this.maybeGetRecognizers(current) ? applySheetContainerStylesTo(element, this.sheetContentContainerStyles) : element;
                    ref.appendChild(elementToAdd);
                    this.maybeTriggerTopOfLayerChange(current, true);
                }
                measureRef(ref);
                layer.currentMounted = !!ref;
                this.currentRef = ref || undefined;
            }, this.previousOuterContentRef = (ref)=>{
                const element = this.props.layer.previous && this.props.layer.previous.outerElement;
                ref && element && ref.appendChild(element);
            }, this.currentOuterContentRef = (ref)=>{
                const element = this.props.layer.current && this.props.layer.current.outerElement;
                ref && element && ref.appendChild(element);
            }, this.onPreviousTransitionEnd = ()=>{
                this.props.layer.previous = undefined;
            }, this.onContainerTransitionEnd = ()=>{
                this.props.onLayerClose(this.props.layer);
            }, this.onSafeAreaResize = ()=>{
                const { layer, measure } = this.props;
                if (!layer.currentMounted) return;
                measure();
            };
        }
    }
    ({ c: [_LayerViewUnMeasured, _initClass] } = _apply_decs_2203_r(LayerViewUnMeasured, [], [
        _observer_for_class.observerForClass
    ], _React_Component));
})(), _class)();
const DragHandle = _react.memo(({ recognizers, contrastHandle })=>{
    if (!recognizers) return null;
    return (0, _jsxruntime.jsx)(_gesture_recognizer_view.GestureRecognizerView, {
        recognizers: recognizers,
        children: ({ gestureRef })=>(0, _jsxruntime.jsx)("div", {
                ref: gestureRef,
                className: _sheetcss.default.handle,
                children: (0, _jsxruntime.jsx)("div", {
                    className: (0, _classnames.default)(_sheetcss.default.handleTab, {
                        [_sheetcss.default.contrast]: contrastHandle
                    })
                })
            })
    });
});
const applySheetContainerStylesTo = (element, styles)=>{
    const { className, style } = styles;
    element.className = (0, _classnames.default)(element.className, className);
    var _style_backgroundColor;
    element.style.backgroundColor = (_style_backgroundColor = style.backgroundColor) !== null && _style_backgroundColor !== void 0 ? _style_backgroundColor : '';
    return element;
};
const LayerView = (0, _reactmeasure.withContentRect)('bounds')(_LayerViewUnMeasured);
function isInputElement(element, _window) {
    return element instanceof _window.HTMLTextAreaElement || element instanceof _window.HTMLInputElement && element.type !== 'submit';
}
