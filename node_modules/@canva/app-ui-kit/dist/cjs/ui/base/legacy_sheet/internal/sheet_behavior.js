"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get BottomSheetDragBehavior () {
        return BottomSheetDragBehavior;
    },
    get calculateNextStateImpl () {
        return calculateNextStateImpl;
    },
    get isVerticalDirection () {
        return isVerticalDirection;
    }
});
const _make_observable = require('../../../../base/make_observable/make_observable');
const _preconditions = require('../../../../base/preconditions');
const _mobx = _interop_require_wildcard(require("mobx"));
const _gesture_recognizer = require('../../gestures/gesture_recognizer');
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const UPPER_SNAP_MULTIPLIER = 0.8;
const LOWER_SNAP_MULTIPLIER = 0.2;
const VELOCITY_THRESHOLD = 1;
class BottomSheetDragBehavior {
    static _makeObservable(instance) {
        (0, _make_observable.makeObservable)(instance, {
            sheetState: _mobx.observable.ref,
            _hasTransition: _mobx.observable.ref,
            _containerSize: _mobx.observable.ref,
            _viewPortSize: _mobx.observable.ref,
            _isPanning: _mobx.observable.ref,
            _isSwiping: _mobx.observable.ref,
            containerTransition: _mobx.computed,
            containerMaxSizeInPeek: _mobx.computed,
            isSwiping: _mobx.computed,
            containerTransform: _mobx.computed,
            transparentOverlay: _mobx.computed,
            resetToPreviousSheetState: _mobx.action.bound,
            setContainerHeightToContentHeight: _mobx.action.bound,
            configureBounds: _mobx.action,
            closeSheet: _mobx.action.bound,
            onEventStart: _mobx.action.bound,
            onMoveVertical: _mobx.action.bound,
            onEndVertical: _mobx.action.bound,
            animateToSheetState: _mobx.action.bound,
            onViewportHeightChanges: _mobx.action.bound,
            updateSheetState: _mobx.action
        });
    }
    get containerTransition() {
        return this._hasTransition ? '' : 'none';
    }
    get containerMaxSizeInPeek() {
        if (this._isPanning || this.sheetState !== 'peek' || !this._containerSize) return '';
        return `${this._containerSize}px`;
    }
    get isSwiping() {
        return this._isSwiping || false;
    }
    get containerTransform() {
        if (!this._containerSize) return '';
        let size = this.snapSize;
        if (this._isPanning) size = Math.min(this._viewPortSize - this.viewportTopOffset, this._containerSize);
        return `translateY(-${size}px)`;
    }
    get transparentOverlay() {
        return this.sheetState !== 'expanded' && this.transparentOverlayOnPeek;
    }
    get hasPeekState() {
        return !!this.peekSizePx;
    }
    setInitialOpenSheetState(state) {
        this._initialOpenSheetState = state;
    }
    setEnableDragging(enable) {
        this.enableDragging = enable;
    }
    resetToPreviousSheetState() {
        if (this.sheetState !== 'collapsed')
            this.updateSheetState(this.previousStaticSheetState);
        this._containerSize = this.snapSize;
    }
    setContainerHeightToContentHeight(contentHeight) {
        this.contentHeight = contentHeight;
        if (contentHeight) this.updateSheetState('peek');
        this._containerSize = this.snapSize;
    }
    configureBounds(bound, open) {
        if (bound.height == null) return;
        if (this.currentOpenState !== open || this.maxSize < bound.height) {
            const size = Math.min(this._viewPortSize - this.viewportTopOffset, bound.height);
            this.maxSize = size;
            if (this.peekSizePx != null)
                this.midSize = Math.min(this.peekSizePx, size);
            else
                this.midSize = size;
            this.minSize = this.minSize > 0 ? this.minSize * size / 100 : 0;
            if (open) {
                this.updateSheetState(this.midSize >= this.maxSize ? 'expanded' : this._initialOpenSheetState);
                this._containerSize = this.snapSize;
            } else this.updateSheetState('collapsed');
        }
        this.currentOpenState = open;
    }
    closeSheet() {
        this.currentOpenState = false;
        this.updateSheetState('collapsed');
        this._containerSize = undefined;
    }
    onEventStart() {
        this._isPanning = true;
        if (this.hasPeekState) _preconditions.Preconditions.checkArgument(this.midSize > 0, 'the peek height is not defined');
        _preconditions.Preconditions.checkArgument(this.maxSize > 0, 'the max height is not defined');
    }
    onMoveVertical(e) {
        const deltaSize = this.snapSize - e.distanceY;
        this._hasTransition = false;
        const prevContainerSize = this._containerSize;
        this._containerSize = this.clampBetweenMinAndMaxSize(deltaSize);
        if (this._containerSize !== prevContainerSize) this._isSwiping = true;
    }
    onEndVertical(e) {
        this._isPanning = false;
        this._isSwiping = false;
        const direction = e.distanceY < 0 ? 'up' : 'down';
        const { hasPeekState, maxSize, midSize, contentHeight } = this;
        const deltaSize = this.snapSize - e.distanceY - e.velocityY;
        const velocity = Math.abs(e.velocityY);
        const state = this.calculateNextState({
            direction,
            deltaSize,
            velocity,
            hasPeekState,
            maxSize: contentHeight !== null && contentHeight !== void 0 ? contentHeight : maxSize,
            midSize: contentHeight != null ? contentHeight / 2 : midSize
        });
        const nextState = contentHeight != null && state === 'expanded' ? 'peek' : state;
        this.updateSheetState(nextState);
        this._hasTransition = true;
        this._containerSize = this.snapSize;
    }
    animateToSheetState(state) {
        if (state === 'peek' && !this.hasPeekState)
            throw new Error();
        this.updateSheetState(state);
        this._hasTransition = true;
        this._containerSize = this.snapSize;
    }
    onViewportHeightChanges(viewportHeight) {
        this.maxSize = viewportHeight - this.viewportTopOffset;
        this._containerSize = Math.min(this.snapSize, this.maxSize);
        this._viewPortSize = viewportHeight;
    }
    updateSheetState(state) {
        if (this.sheetState === state) return;
        if (this.contentHeight == null && state !== 'collapsed')
            this.previousStaticSheetState = state;
        this.sheetState = state;
        this.onStateChanged && this.onStateChanged(state);
    }
    get snapSize() {
        if (this.contentHeight != null) return this.contentHeight;
        switch(this.sheetState){
            case 'peek':
                return this.midSize;
            case 'collapsed':
                return this.minSize;
            case 'expanded':
                return this.maxSize;
            default:
                throw new _preconditions.UnreachableError(this.sheetState);
        }
    }
    clampBetweenMinAndMaxSize(nextSheetSize) {
        var _this_contentHeight;
        return Math.min((_this_contentHeight = this.contentHeight) !== null && _this_contentHeight !== void 0 ? _this_contentHeight : this.maxSize, Math.max(this.minSize, nextSheetSize));
    }
    constructor(_window, onStateChanged, peekSizePx = typeof window !== 'undefined' ? window.innerHeight * 0.44 : undefined, transparentOverlayOnPeek = false, offsetForViewportHeight, onPanning, calculateNextState = calculateNextStateImpl){
        this._window = _window;
        this.onStateChanged = onStateChanged;
        this.peekSizePx = peekSizePx;
        this.transparentOverlayOnPeek = transparentOverlayOnPeek;
        this.onPanning = onPanning;
        this.calculateNextState = calculateNextState;
        this.sheetState = (BottomSheetDragBehavior._makeObservable(this), 'collapsed');
        this._hasTransition = true;
        this._viewPortSize = this._window.innerHeight;
        this._initialOpenSheetState = this.hasPeekState ? 'peek' : 'expanded';
        this.previousStaticSheetState = 'expanded';
        this.enableDragging = true;
        this.minSize = 0;
        this.midSize = 0;
        this.maxSize = 0;
        this.currentOpenState = false;
        this.recognizer = new _gesture_recognizer.PanRecognizer({
            minDistance: 4,
            direction: 'vertical',
            onStart: ()=>{
                if (!this.enableDragging) return;
                if (this.onPanning) this.onPanning(true);
                this.onEventStart();
            },
            onMove: (e)=>{
                if (!this.enableDragging) return;
                if (isVerticalDirection(e)) this.onMoveVertical(e);
            },
            onEnd: (e)=>{
                if (!this.enableDragging) return;
                if (this.onPanning) this.onPanning(false);
                this.onEndVertical(e);
            }
        });
        this.viewportTopOffset = offsetForViewportHeight || 0;
    }
}
function isVerticalDirection(e) {
    return e.direction === 'up' || e.direction === 'down' || e.direction === 'none';
}
function calculateNextStateImpl({ direction, deltaSize, velocity, hasPeekState, midSize, maxSize }) {
    let threshold = 0;
    switch(direction){
        case 'up':
        case 'right':
            if (hasPeekState) {
                if (deltaSize <= midSize) {
                    threshold = LOWER_SNAP_MULTIPLIER * midSize;
                    if (deltaSize >= threshold || velocity >= VELOCITY_THRESHOLD) return 'peek';
                    else return 'collapsed';
                } else {
                    threshold = UPPER_SNAP_MULTIPLIER * (maxSize - midSize);
                    if (maxSize - deltaSize <= threshold || velocity >= VELOCITY_THRESHOLD) return 'expanded';
                    else return 'peek';
                }
            } else {
                threshold = LOWER_SNAP_MULTIPLIER * maxSize;
                if (deltaSize >= threshold || velocity >= VELOCITY_THRESHOLD) return 'expanded';
                else return 'collapsed';
            }
        case 'down':
        case 'left':
            if (hasPeekState) {
                if (deltaSize >= midSize) {
                    threshold = UPPER_SNAP_MULTIPLIER * (maxSize - midSize);
                    if (deltaSize - midSize <= threshold || velocity >= VELOCITY_THRESHOLD) return 'peek';
                    else return 'expanded';
                } else {
                    threshold = UPPER_SNAP_MULTIPLIER * midSize;
                    if (deltaSize <= threshold || velocity >= VELOCITY_THRESHOLD) return 'collapsed';
                    else return 'peek';
                }
            } else {
                threshold = UPPER_SNAP_MULTIPLIER * maxSize;
                if (deltaSize <= threshold || velocity >= VELOCITY_THRESHOLD) return 'collapsed';
                else return 'expanded';
            }
        default:
            throw new _preconditions.UnreachableError(direction);
    }
}
