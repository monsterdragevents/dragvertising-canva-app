"use strict"
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ScrollPositioner", {
    enumerable: true,
    get: function() {
        return ScrollPositioner;
    }
});
const _easings = require('../animation/easings');
class ScrollPositioner {
    static animate(
    getScrollTop,
    setScrollTop,
    newScrollTop,
    duration = 150,
    easingFn = _easings.Easings.linear
) {
        const oldScrollTop = getScrollTop();
        let startTime;
        const scroll = (timestamp)=>{
            startTime = startTime || timestamp;
            const progress = timestamp - startTime;
            if (progress < duration) {
                setScrollTop(easingFn(oldScrollTop, newScrollTop, progress, duration));
                window.requestAnimationFrame(scroll);
            } else setScrollTop(newScrollTop);
        };
        window.requestAnimationFrame(scroll);
    }
    static animateElement(element, newScrollTop, duration = 150, easingFn = _easings.Easings.linear) {
        ScrollPositioner.animate(()=>element.scrollTop, (scrollTop)=>element.scrollTop = scrollTop, newScrollTop, duration, easingFn);
    }
    static isAboveVisibleScroll(container, element) {
        return element.offsetTop < container.scrollTop;
    }
    static isBelowVisibleScroll(container, element) {
        const elementBottom = element.offsetTop + element.offsetHeight;
        const visibleScrollBottom = container.scrollTop + container.clientHeight;
        return elementBottom > visibleScrollBottom;
    }
    static scrollToPutAtTop(container, element, withAnimation = false) {
        const containerOuterToInnerHeightDiff = (container.offsetHeight - container.clientHeight) / 2;
        const newScrollTop = element.offsetTop - containerOuterToInnerHeightDiff;
        if (withAnimation) ScrollPositioner.animateElement(container, newScrollTop);
        else container.scrollTop = newScrollTop;
    }
    static scrollToPutAtBottom(container, element, withAnimation = false) {
        const containerOuterToInnerHeightDiff = (container.offsetHeight - container.clientHeight) / 2;
        const elementBottom = element.offsetTop + element.offsetHeight;
        const newScrollTop = elementBottom - container.offsetHeight + containerOuterToInnerHeightDiff;
        if (withAnimation) ScrollPositioner.animateElement(container, newScrollTop);
        else container.scrollTop = newScrollTop;
    }
    static scrollToCenter(container, element, withAnimation = false) {
        const oldScrollTop = container.scrollTop;
        const containerHeight = container.offsetHeight;
        const elementTop = element.offsetTop - oldScrollTop;
        const elementHeight = element.offsetHeight;
        const newScrollTop = elementTop + elementHeight / 2 + oldScrollTop - containerHeight / 2;
        if (withAnimation) ScrollPositioner.animateElement(container, newScrollTop);
        else container.scrollTop = newScrollTop;
    }
}
