"use strict"
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get command () {
        return command;
    },
    get control () {
        return control;
    },
    get equal () {
        return equal;
    },
    get isKeyRange () {
        return isKeyRange;
    },
    get isModified () {
        return isModified;
    },
    get isModifierKey () {
        return isModifierKey;
    },
    get makeHumanReadableArray () {
        return makeHumanReadableArray;
    },
    get makeHumanReadableString () {
        return makeHumanReadableString;
    },
    get makeKeyTrigger () {
        return makeKeyTrigger;
    },
    get option () {
        return option;
    },
    get shift () {
        return shift;
    }
});
const _exists = require('../../../../base/exists');
const _key_combinationmessages = require("./key_combination.messages");
const globalNavigator = typeof navigator !== 'undefined' ? navigator : undefined;
const ensureMappings = (mappings)=>mappings;
const mappingsLTR = ensureMappings({
    ['previous']: 'ArrowLeft',
    ['next']: 'ArrowRight'
});
const mappingsRTL = ensureMappings({
    ['previous']: 'ArrowRight',
    ['next']: 'ArrowLeft'
});
const resolveMapping = (key, direction)=>{
    const mappings = direction === 'LTR' ? mappingsLTR : mappingsRTL;
    return key in mappings ? mappings[key] : key;
};
const control = makeModifier(()=>({
        Control: true
    }));
const command = makeModifier(()=>({
        command: true
    }));
const option = makeModifier(()=>({
        Alt: true
    }));
const shift = makeModifier(()=>({
        Shift: true
    }));
function equal(a, b, direction) {
    if (!isModified(a) && !isModified(b) && !isKeyRange(a) && !isKeyRange(b)) return resolveMapping(a, direction) === resolveMapping(b, direction);
    else if (isModified(a) && isModified(b)) return resolveMapping(a.key, direction) === resolveMapping(b.key, direction) && a.Alt === b.Alt && a.Shift === b.Shift && (a.Control || a.command) === (b.Control || b.command);
    else if (isKeyRange(a) && isKeyRange(b)) return a[0] === b[0] && a[1] === b[1];
    return false;
}
function makeModifier(modify) {
    return (key)=>({
            ...(isModified(key) ? key : {
                key
            }),
            ...modify()
        });
}
function isIpad() {
    return globalNavigator != null && /iPad|Macintosh/i.test(globalNavigator.userAgent) && globalNavigator.maxTouchPoints != null && globalNavigator.maxTouchPoints > 2;
}
function isAppleDevice() {
    return globalNavigator != null && /Mac|iPod|iPhone/.test(globalNavigator.platform) || isIpad();
}
function makeHumanReadableArray(keyCombination, direction, platform = isAppleDevice() ? 'apple' : 'other') {
    const strings = platform === 'apple' ? MAC_HUMAN_READABLE_STRINGS : OTHER_HUMAN_READABLE_STRINGS;
    if (isModifierKey(keyCombination)) return [
        strings[keyCombination]
    ];
    if (isModified(keyCombination)) {
        const orderedModifiers = platform === 'apple' ? [
            keyCombination.Alt ? strings['Alt'] : null,
            keyCombination.Shift ? strings['Shift'] : null,
            keyCombination.command ? strings['Command'] : null,
            keyCombination.Control ? strings['Control'] : null
        ] : [
            keyCombination.command ? strings['Command'] : null,
            keyCombination.Alt ? strings['Alt'] : null,
            keyCombination.Shift ? strings['Shift'] : null,
            keyCombination.Control ? strings['Control'] : null
        ];
        return [
            ...orderedModifiers,
            ...makeHumanReadableArray(keyCombination.key, direction)
        ].filter(_exists.exists);
    }
    if (isKeyRange(keyCombination)) return [
        `${makeHumanReadableString(keyCombination[0], direction)}–${makeHumanReadableString(keyCombination[1], direction)}`
    ];
    const resolvedKey = resolveMapping(keyCombination, direction);
    const s = strings[resolvedKey];
    return [
        s ? s : resolvedKey.toLocaleUpperCase()
    ];
}
function makeHumanReadableString(keyCombination, direction, platform = isAppleDevice() ? 'apple' : 'other') {
    const separator = platform === 'apple' ? '' : '+';
    return makeHumanReadableArray(keyCombination, direction, platform).join(separator);
}
const MODIFIER_KEYS = new Set([
    'Command',
    'Alt',
    'Shift'
]);
const COMMON_HUMAN_READABLE_STRINGS = {
    ['ArrowUp']: _key_combinationmessages.KeyCombinationMessages.commonUpArrowLabel(),
    ['ArrowDown']: _key_combinationmessages.KeyCombinationMessages.commonDownArrowLabel(),
    ['ArrowLeft']: _key_combinationmessages.KeyCombinationMessages.commonLeftArrowLabel(),
    ['ArrowRight']: _key_combinationmessages.KeyCombinationMessages.commonRightArrowLabel(),
    [' ']: _key_combinationmessages.KeyCombinationMessages.commonSpaceLabel(),
    ['Escape']: _key_combinationmessages.KeyCombinationMessages.escapeLabel()
};
const MAC_HUMAN_READABLE_STRINGS = {
    ...COMMON_HUMAN_READABLE_STRINGS,
    ['Command']: '⌘',
    ['Alt']: '⌥',
    ['Shift']: '⇧',
    ['Control']: '⌃',
    ['Enter']: '⏎'
};
const OTHER_HUMAN_READABLE_STRINGS = {
    ...COMMON_HUMAN_READABLE_STRINGS,
    ['Command']: _key_combinationmessages.KeyCombinationMessages.nonMacControlLabel(),
    ['Control']: _key_combinationmessages.KeyCombinationMessages.nonMacControlLabel(),
    ['Alt']: _key_combinationmessages.KeyCombinationMessages.nonMacAltLabel(),
    ['Shift']: _key_combinationmessages.KeyCombinationMessages.nonMacShiftLabel(),
    ['Enter']: _key_combinationmessages.KeyCombinationMessages.nonMacEnterLabel()
};
function makeKeyTrigger(keyCombination, direction, platform = isAppleDevice() ? 'apple' : 'other') {
    const isOnAppleDevice = platform === 'apple';
    var _keyCombination_command;
    if (isModified(keyCombination)) return {
        key: resolveMapping(keyCombination.key, direction),
        altKey: keyCombination.Alt,
        shiftKey: keyCombination.Shift,
        ctrlKey: isOnAppleDevice ? keyCombination.Control : (_keyCombination_command = keyCombination.command) !== null && _keyCombination_command !== void 0 ? _keyCombination_command : keyCombination.Control,
        metaKey: isOnAppleDevice ? keyCombination.command : false
    };
    const mod = isOnAppleDevice ? 'Meta' : 'Control';
    return {
        key: keyCombination === 'Command' ? mod : resolveMapping(keyCombination, direction)
    };
}
function isKeyRange(keyCombination) {
    return Array.isArray(keyCombination);
}
function isModified(keyCombination) {
    return typeof keyCombination !== 'string' && !Array.isArray(keyCombination);
}
function isModifierKey(keyCombination) {
    return typeof keyCombination === 'string' && MODIFIER_KEYS.has(keyCombination);
}
