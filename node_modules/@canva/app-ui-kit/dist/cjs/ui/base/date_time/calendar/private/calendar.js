"use strict"
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Calendar", {
    enumerable: true,
    get: function() {
        return Calendar;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _preconditions = require('../../../../../base/preconditions');
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _utils = require('../../utils/utils');
const _calendarcss = _interop_require_default(require("./calendar.css"));
const _day = require("./day");
const _days_week_labels = require("./days_week_labels");
const _week = require("./week");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const WEEKS_IN_CALENDAR = 6;
const DAYS_IN_CALENDAR = _week.DAYS_IN_WEEK * WEEKS_IN_CALENDAR;
const Calendar = _react.memo(
    ({ autoFocus = true, today = (0, _utils.toLocalDateTimeObject)(new Date()), CalendarDay = _day.CalendarDayWithWrapper, CalendarWeek = _week.CalendarWeek, DaysOfWeekLabels = _days_week_labels.CalendarDaysOfWeekLabels, month, year, animate, ariaLabel, ariaLabelledBy, ariaDescribedBy, locale, selected, focused, includedInTabOrder, selectedInvalid, canSelectPastDates, className, onSelect, minSelectableDate, maxSelectableDate })=>{
        const previousMonthYearRef = _react.useRef({
            month,
            year
        });
        const animatedRef = _react.useRef(null);
        const selectedDayRef = _react.useRef(null);
        const focusedDayRef = _react.useRef(null);
        _react.useEffect(()=>{
            var _focusedDayRef_current;
            if (autoFocus) (_focusedDayRef_current = focusedDayRef.current) === null || _focusedDayRef_current === void 0 ? void 0 : _focusedDayRef_current.focus();
        }, [
            autoFocus
        ]);
        _react.useEffect(()=>{
            if (!animate) return;
            previousMonthYearRef.current = {
                month,
                year
            };
            setTimeout(()=>{
                requestAnimationFrame(()=>{
                    if (animatedRef.current) animatedRef.current.classList.add(_calendarcss.default.animate);
                });
            }, 0);
        }, [
            month,
            year,
            animate
        ]);
        const onAnimationScrollRef = _react.useCallback((ref)=>{
            animatedRef.current = ref;
        }, []);
        const onSelectedDayRef = _react.useCallback((ref)=>{
            selectedDayRef.current = ref;
        }, []);
        const onFocusedDayRef = _react.useCallback((ref)=>{
            focusedDayRef.current = ref;
        }, []);
        const handleSelect = _react.useCallback((date)=>{
            onSelect === null || onSelect === void 0 ? void 0 : onSelect((0, _utils.toUTCDateTimeObject)(date));
        }, [
            onSelect
        ]);
        const todayValue = _preconditions.Preconditions.checkExists(today);
        const isToday = _react.useCallback((date)=>{
            return (0, _utils.isEqualDates)(date, todayValue);
        }, [
            todayValue
        ]);
        const isSelectedDate = _react.useCallback((date)=>{
            if (!selected) return false;
            const dates = Array.isArray(selected) ? selected : [
                selected
            ];
            return dates.some((selectedDate)=>(0, _utils.isEqualDates)(date, selectedDate));
        }, [
            selected
        ]);
        const isFocusedDate = _react.useCallback((date)=>{
            return !!(focused && (0, _utils.isEqualDates)(date, focused));
        }, [
            focused
        ]);
        const isIncludedInTabOrderDate = _react.useCallback((date)=>{
            return !!(includedInTabOrder && (0, _utils.isEqualDates)(date, includedInTabOrder));
        }, [
            includedInTabOrder
        ]);
        const isPastDate = _react.useCallback((date)=>{
            return (0, _utils.compareDays)(date, todayValue) < 0;
        }, [
            todayValue
        ]);
        const isDisabledDate = _react.useCallback((date)=>{
            if ((!canSelectPastDates || minSelectableDate === 'today') && isPastDate(date)) return true;
            if (!!minSelectableDate && minSelectableDate !== 'today' && (0, _utils.compareDates)(date, minSelectableDate) < 0) return true;
            if (maxSelectableDate) return (0, _utils.compareDates)(date, maxSelectableDate) > 0;
            return false;
        }, [
            canSelectPastDates,
            minSelectableDate,
            maxSelectableDate,
            isPastDate
        ]);
        const isCurrentMonth = _react.useCallback((date, month)=>{
            return (0, _utils.checkMonth)(date, month);
        }, []);
        const compareWithPrevious = _react.useCallback(()=>{
            return (0, _utils.compareMonthAndYear)(previousMonthYearRef.current, {
                month,
                year
            });
        }, [
            month,
            year
        ]);
        const getPreviousWeeksNumber = _react.useCallback(()=>{
            const comparedWithPrevious = compareWithPrevious();
            if (comparedWithPrevious < 0) return (0, _utils.numberOfCompleteWeeks)(previousMonthYearRef.current);
            if (comparedWithPrevious > 0) return (0, _utils.numberOfCompleteWeeks)({
                month,
                year
            });
            return 0;
        }, [
            compareWithPrevious,
            month,
            year
        ]);
        const getDates = _react.useCallback(({ month, year })=>{
            const dates = [];
            dates.push(...(0, _utils.monthDays)({
                month,
                year
            }));
            const firstDayIndex = (0, _utils.dayOfWeekStartOfMonth)({
                month,
                year
            });
            if (firstDayIndex > 0) dates.unshift(...(0, _utils.monthDays)((0, _utils.prevMonth)({
                month,
                year
            }), -firstDayIndex));
            if (dates.length < DAYS_IN_CALENDAR) dates.push(...(0, _utils.monthDays)((0, _utils.nextMonth)({
                month,
                year
            }), DAYS_IN_CALENDAR - dates.length));
            return dates;
        }, []);
        const splitToWeeks = _react.useCallback((days)=>{
            return days.reduce((weeks, day)=>{
                if (!weeks[weeks.length - 1] || weeks[weeks.length - 1].length >= _week.DAYS_IN_WEEK) weeks.push([]);
                weeks[weeks.length - 1].push(day);
                return weeks;
            }, []);
        }, []);
        const renderAnimatedDays = ()=>{
            const comparedWithPrevious = compareWithPrevious();
            const previousWeeksNumber = getPreviousWeeksNumber();
            const previousMonthWeeks = comparedWithPrevious < 0 && previousWeeksNumber ? {
                count: previousWeeksNumber
            } : undefined;
            const nextMonthWeeks = comparedWithPrevious > 0 && previousWeeksNumber ? {
                count: previousWeeksNumber,
                offset: 6 - previousWeeksNumber
            } : undefined;
            return (0, _jsxruntime.jsx)("div", {
                className: _calendarcss.default.animationWrap,
                children: (0, _jsxruntime.jsxs)("div", {
                    className: (0, _classnames.default)(_calendarcss.default.animationScroll, {
                        [_calendarcss.default.animateToPrevious]: comparedWithPrevious < 0,
                        [_calendarcss.default.animateToNext]: comparedWithPrevious > 0,
                        [_calendarcss.default.weeks4]: previousWeeksNumber === 4,
                        [_calendarcss.default.weeks5]: previousWeeksNumber === 5
                    }),
                    ref: onAnimationScrollRef,
                    children: [
                        previousMonthWeeks && (0, _jsxruntime.jsx)("div", {
                            className: _calendarcss.default.previousMonth,
                            children: renderDays(previousMonthYearRef.current, previousMonthWeeks, 'prev')
                        }),
                        renderDays({
                            month,
                            year
                        }, undefined, 'current'),
                        nextMonthWeeks && (0, _jsxruntime.jsx)("div", {
                            className: _calendarcss.default.nextMonth,
                            children: renderDays(previousMonthYearRef.current, nextMonthWeeks, 'next')
                        })
                    ]
                })
            }, `days${month}-${year}`);
        };
        const renderDays = (monthYear, weeksChunk, renderedMonth)=>{
            let weeks = splitToWeeks(getDates(monthYear));
            if (weeksChunk) {
                const offset = weeksChunk.offset || 0;
                weeks = weeks.slice(offset, offset + weeksChunk.count);
            }
            const Week = _preconditions.Preconditions.checkExists(CalendarWeek);
            return weeks.map((week)=>(0, _jsxruntime.jsx)(Week, {
                    renderedMonth: renderedMonth,
                    children: week.map((day)=>renderDay((0, _utils.toISO)(day), monthYear, renderedMonth === 'current'))
                }, (0, _utils.key)(week[0], 'week')));
        };
        const renderDay = (date, { month }, active = true)=>{
            const current = isCurrentMonth(date, month);
            const isSelected = isSelectedDate(date);
            const isFocused = isFocusedDate(date);
            const onSelectedDayRefCallback = isSelected && active ? onSelectedDayRef : undefined;
            const onFocusedDayRefCallback = isFocused ? onFocusedDayRef : undefined;
            const onDayRef = onSelectedDayRefCallback || onFocusedDayRefCallback ? (ref)=>{
                onSelectedDayRefCallback === null || onSelectedDayRefCallback === void 0 ? void 0 : onSelectedDayRefCallback(ref);
                onFocusedDayRefCallback === null || onFocusedDayRefCallback === void 0 ? void 0 : onFocusedDayRefCallback(ref);
            } : undefined;
            const Day = _preconditions.Preconditions.checkExists(CalendarDay);
            return (0, _jsxruntime.jsx)(Day, {
                locale: locale,
                date: date,
                current: current,
                today: isToday(date),
                past: isPastDate(date),
                selected: isSelected,
                selectedInvalid: selectedInvalid,
                disabled: isDisabledDate(date),
                onSelect: active && onSelect ? handleSelect : undefined,
                onDayRef: onDayRef,
                includeInTabOrder: isIncludedInTabOrderDate(date)
            }, (0, _utils.key)(date, 'day'));
        };
        return (0, _jsxruntime.jsxs)("div", {
            className: (0, _classnames.default)(_calendarcss.default.calendar, className),
            role: "grid",
            "aria-label": ariaLabelledBy ? undefined : ariaLabel,
            "aria-labelledby": ariaLabelledBy,
            "aria-describedby": ariaDescribedBy,
            children: [
                DaysOfWeekLabels && (0, _jsxruntime.jsx)(DaysOfWeekLabels, {
                    locale: locale
                }),
                (0, _jsxruntime.jsx)("div", {
                    className: _calendarcss.default.days,
                    children: animate ? renderAnimatedDays() : renderDays({
                        month,
                        year
                    }, undefined, 'current')
                })
            ]
        });
    }
);
