"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get DateTimePickerPresenter () {
        return DateTimePickerPresenter;
    },
    get DateTimePickerStore () {
        return DateTimePickerStore;
    }
});
const _make_observable = require('../../../../../base/make_observable/make_observable');
const _mobx = _interop_require_wildcard(require("mobx"));
const _utils = require('../../utils/utils');
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
class DateTimePickerStore {
    static _makeObservable(instance) {
        (0, _make_observable.makeObservable)(instance, {
            _date: _mobx.observable.ref,
            viewDate: _mobx.observable.ref,
            focusedDate: _mobx.observable.ref,
            timezone: _mobx.computed,
            dateInTimezone: _mobx.computed,
            focusedDateInTimezone: _mobx.computed,
            todayInTimezone: _mobx.computed,
            date: _mobx.computed
        });
    }
    get timezone() {
        return this.defaultTimezone || (0, _utils.getTimezone)(this.viewDate, this.locale);
    }
    get todayTimezoneOffset() {
        return this.defaultTimezone ? this.defaultTimezone.offset : (0, _utils.getTimezoneOffset)(this.today);
    }
    get dateInTimezone() {
        return (0, _utils.toUTCDateTimeObject)((0, _utils.fromUTCToTimezone)(this.viewDate, this.timezone.offset));
    }
    get focusedDateInTimezone() {
        if (this.focusedDate == null) return;
        return (0, _utils.toUTCDateTimeObject)((0, _utils.fromUTCToTimezone)(this.focusedDate, this.timezone.offset));
    }
    get todayInTimezone() {
        return (0, _utils.toUTCDateTimeObject)((0, _utils.fromUTCToTimezone)(this.today, this.todayTimezoneOffset));
    }
    get date() {
        return this._date;
    }
    set date(date) {
        this._date = date;
        if (date != null) this.viewDate = date;
    }
    constructor(utcDate, locale, utcToday, defaultTimezone){
        this.locale = locale;
        this.defaultTimezone = defaultTimezone;
        this._date = (DateTimePickerStore._makeObservable(this), undefined);
        this.today = utcToday || (0, _utils.toISO)(new Date());
        this._date = utcDate;
        this.viewDate = utcDate !== null && utcDate !== void 0 ? utcDate : this.today;
    }
}
class DateTimePickerPresenter {
    static _makeObservable(instance) {
        (0, _make_observable.makeObservable)(instance, {
            unsetDate: _mobx.action,
            updateFocusedDate: _mobx.action,
            unsetFocusedDate: _mobx.action,
            updateDateTime: _mobx.action
        });
    }
    createStore(date, locale, today, timeZone) {
        return new DateTimePickerStore(date, locale, today, timeZone);
    }
    getDate(store) {
        return store.dateInTimezone;
    }
    getMonth(store) {
        return (0, _utils.getMonth)(store.dateInTimezone);
    }
    getYear(store) {
        return (0, _utils.getYear)(store.dateInTimezone);
    }
    getTime(store) {
        return (0, _utils.getTimeOfDay)(store.dateInTimezone);
    }
    getUTCDate(store) {
        return (0, _utils.toISO)(store.viewDate);
    }
    updateDate(store, dateInTimezone, options) {
        this.updateDateTime(store, dateInTimezone, (0, _utils.getTimeOfDay)(store.dateInTimezone), options === null || options === void 0 ? void 0 : options.updateFocus);
    }
    updateTime(store, timeMs) {
        this.updateDateTime(store, store.dateInTimezone, timeMs);
    }
    unsetDate(store) {
        store.date = undefined;
    }
    updateFocusedDate(store, dateInTimezone) {
        const utcDate = this.getUtcDate(store, dateInTimezone, (0, _utils.getTimeOfDay)(store.dateInTimezone));
        store.focusedDate = (0, _utils.toISO)(utcDate);
        store.viewDate = store.focusedDate;
    }
    unsetFocusedDate(store) {
        store.focusedDate = undefined;
    }
    getUtcDate(store, dateInTimezone, dayTime) {
        const localDate = (0, _utils.setTimeToDate)(dateInTimezone, dayTime);
        const timezoneOffset = store.defaultTimezone ? store.defaultTimezone.offset : (0, _utils.getTimezoneOffset)(localDate);
        let utcDate = (0, _utils.fromTimezoneToUTC)(localDate, timezoneOffset);
        const utcDateTimezoneOffset = store.defaultTimezone ? store.defaultTimezone.offset : (0, _utils.getTimezoneOffset)(utcDate);
        if (timezoneOffset !== utcDateTimezoneOffset)
            utcDate = (0, _utils.fromTimezoneToUTC)(localDate, utcDateTimezoneOffset);
        return utcDate;
    }
    updateDateTime(store, dateInTimezone, dayTime, updateFocus) {
        const utcDate = this.getUtcDate(store, dateInTimezone, dayTime);
        store.date = (0, _utils.toISO)(utcDate);
        store.viewDate = store.date;
        if (updateFocus) store.focusedDate = store.date;
    }
    constructor(){
        DateTimePickerPresenter._makeObservable(this);
    }
}
