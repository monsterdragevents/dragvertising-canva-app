"use strict"
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get Internal () {
        return Internal;
    },
    get getGlyphAndClassForSize () {
        return getGlyphAndClassForSize;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _preconditions = require('../../../../base/preconditions');
const _classnames = _interop_require_default(require("classnames"));
require("react");
const _escape_hatch = require('../../theme/escape_hatch');
const _base_iconcss = _interop_require_wildcard(require("./base_icon.css"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const renderIcon = ({ className, style, glyph })=>{
    let children = null;
    let innerHtml;
    if (!glyph || typeof glyph === 'string') innerHtml = {
        __html: glyph
    };
    else {
        const GlyphComponent = glyph;
        children = (0, _jsxruntime.jsx)(GlyphComponent, {});
    }
    return (0, _jsxruntime.jsx)("span", {
        "aria-hidden": "true",
        className: className,
        style: style,
        dangerouslySetInnerHTML: innerHtml,
        children: children
    });
};
const createIconClass = (glyphs, { extraClassName, followDirection, defaultSize = 'medium' } = {})=>{
    const Component = (props)=>{
        const { className, size = defaultSize, tone, ...restProps } = props;
        const [glyph, sizeClassName] = getGlyphAndClassForSize(size, glyphs);
        const classes = (0, _classnames.default)(className, sizeClassName, extraClassName, tone ? (0, _base_iconcss.getStyle)(tone) : undefined, {
            [_base_iconcss.default.followDirection]: followDirection
        });
        return renderIcon({
            ...restProps,
            glyph,
            className: classes
        });
    };
    Component.glyphs = glyphs;
    Component.followDirection = followDirection;
    return Component;
};
function getGlyphAndClassForSize(size, glyphs) {
    const fallbackGlyph = glyphs.medium || glyphs.small || glyphs.large || glyphs.tiny;
    switch(size){
        case 'tiny':
            return [
                glyphs.tiny || fallbackGlyph,
                _base_iconcss.default.tiny
            ];
        case 'small':
            return [
                glyphs.small || fallbackGlyph,
                _base_iconcss.default.small
            ];
        case 'medium':
            return [
                glyphs.medium || fallbackGlyph,
                _base_iconcss.default.medium
            ];
        case 'large':
            return [
                glyphs.large || fallbackGlyph,
                _base_iconcss.default.large
            ];
        default:
            throw new _preconditions.UnreachableError(size);
    }
}
const Internal = {
    create: (sources, followDirection)=>createIconClass(sources, {
            followDirection
        }),
    createSpinning: (sources, followDirection)=>createIconClass(sources, {
            extraClassName: _base_iconcss.default.spinning,
            followDirection
        }),
    createWithExtraClassname: (sources, extraClassName, followDirection, defaultSize)=>createIconClass(sources, {
            extraClassName,
            followDirection,
            defaultSize
        }),
    createThemed: (defaultMedia, themedMedia, followDirection)=>{
        const Icon = (props)=>{
            const media = (0, _escape_hatch.useThemedMedia)(themedMedia);
            const sources = {
                ...defaultMedia,
                ...media
            };
            const Component = createIconClass(sources, {
                followDirection
            });
            return (0, _jsxruntime.jsx)(Component, {
                ...props,
                tone: "primary"
            });
        };
        Icon.glyphs = defaultMedia;
        Icon.followDirection = followDirection;
        return Icon;
    }
};
