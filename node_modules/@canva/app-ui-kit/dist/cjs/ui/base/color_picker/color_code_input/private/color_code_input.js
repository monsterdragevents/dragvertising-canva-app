"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ColorCodeInput", {
    enumerable: true,
    get: function() {
        return ColorCodeInput;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _color = require('../../../../../base/color/color');
const _react = _interop_require_wildcard(require("react"));
const _box = require('../../../box/box');
const _number_input = require('../../../form/number_input/number_input');
const _text_input = require('../../../form/text_input/text_input');
const _swatch = require('../../../swatch/swatch');
const _typography = require('../../../typography/typography');
const _color_code_inputcss = _interop_require_default(require("./color_code_input.css"));
const _color_code_inputmessages = require("./color_code_input.messages");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function ColorCodeInput({ color, alpha, onChange: onChangeProp, onAlphaChange: onAlphaChangeProp, withSwatch, ariaLabel, ariaLabelledBy, ariaDescribedBy, autoFocus }) {
    const colorInputRef = _react.useRef(null);
    const recentlyBlurredRef = _react.useRef(false);
    const [inputValue, setInputValue] = _react.useState(color);
    const onChange = _react.useCallback((value)=>{
        const inputLength = value.length;
        value = value.replace(/[^0-9a-f]/gi, '');
        const lengthDiff = inputLength - value.length;
        value = `#${value.slice(0, 6)}`;
        setInputValue(value);
        const fudgedValue = fudgeHex(value);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(fudgedValue);
        const colorInput = colorInputRef.current;
        if (colorInput) {
            const cursorPosition = colorInput.selectionStart - lengthDiff + 1;
            colorInput.value = value;
            colorInput.selectionStart = cursorPosition;
            colorInput.selectionEnd = cursorPosition;
        }
    }, [
        onChangeProp
    ]);
    const onAlphaChange = _react.useCallback((alpha)=>{
        const value = isNaN(alpha) ? 0 : Math.max(0, Math.min(100, alpha)) / 100;
        onAlphaChangeProp === null || onAlphaChangeProp === void 0 ? void 0 : onAlphaChangeProp(value);
    }, [
        onAlphaChangeProp
    ]);
    const onFocus = _react.useCallback(()=>{
        if (!recentlyBlurredRef.current) setTimeout(()=>{
            var _colorInputRef_current;
            return (_colorInputRef_current = colorInputRef.current) === null || _colorInputRef_current === void 0 ? void 0 : _colorInputRef_current.select();
        });
    }, []);
    const onBlur = _react.useCallback(()=>{
        recentlyBlurredRef.current = true;
        setTimeout(()=>recentlyBlurredRef.current = false, 0);
    }, []);
    const colorValue = fudgeHex(inputValue) === color ? inputValue : color;
    const { r, g, b } = _color.RgbColor.fromHexString(fudgeHex(colorValue));
    const valueWithAlpha = new _color.RgbaColor(r, g, b, alpha).toRgbaString();
    const shouldRenderAlpha = onAlphaChangeProp != null;
    return (0, _jsxruntime.jsx)(_text_input.TextInput, {
        inputClassName: _color_code_inputcss.default.input,
        start: withSwatch ? (0, _jsxruntime.jsx)(_swatch.Swatch, {
            size: "xxsmall",
            fill: [
                valueWithAlpha
            ]
        }) : undefined,
        value: colorValue,
        end: shouldRenderAlpha && (0, _jsxruntime.jsxs)(_box.Box, {
            display: "flex",
            alignItems: "center",
            paddingEnd: "1u",
            className: _color_code_inputcss.default.numInputWrapper,
            children: [
                (0, _jsxruntime.jsx)(_number_input.NumberInput, {
                    className: _color_code_inputcss.default.numInput,
                    inputClassName: _color_code_inputcss.default.numInputField,
                    value: Math.round(alpha * 100),
                    borderless: true,
                    max: 100,
                    min: 0,
                    onChange: onAlphaChange,
                    ariaLabel: _color_code_inputmessages.ColorCodeInputMessages.alphaInputLabel()
                }),
                (0, _jsxruntime.jsx)(_typography.Text, {
                    tone: "tertiary",
                    children: "%"
                })
            ]
        }),
        disableSpellcheck: true,
        onChange: onChange,
        onFocus: onFocus,
        onBlur: onBlur,
        ref: colorInputRef,
        textAlignCenter: !withSwatch && !shouldRenderAlpha,
        autoFocus: autoFocus,
        ariaLabel: ariaLabel,
        ariaLabelledBy: ariaLabelledBy,
        ariaDescribedBy: ariaDescribedBy
    });
}
const fudgeHex = (hex)=>{
    hex = hex.toLowerCase().replace(/[^0-9a-f]/g, '').slice(0, 6);
    hex = hex || 'ffffff';
    if (hex.length <= 3) {
        hex += '0'.repeat(3 - hex.length);
        hex = hex[0].repeat(2) + hex[1].repeat(2) + hex[2].repeat(2);
    } else if (hex.length < 6) hex += '0'.repeat(6 - hex.length);
    return `#${hex}`;
};
