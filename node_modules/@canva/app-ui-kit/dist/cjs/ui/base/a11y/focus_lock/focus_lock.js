"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "FocusLock", {
    enumerable: true,
    get: function() {
        return FocusLock;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _exists = require('../../../../base/exists');
const _mobxreactlite = require("mobx-react-lite");
const _react = _interop_require_wildcard(require("react"));
const _key_combinations = require('../../key_combinations/key_combinations');
const _dom_utils = require("./dom_utils");
const _focus_lock_manager = require("./focus_lock_manager");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const FOCUS_GUARD_PROP = {
    [_dom_utils.FOCUS_GUARD_ATTR]: true
};
const FocusLock = (0, _mobxreactlite.observer)(_react.forwardRef(
    function FocusLock({ autoFocus = true, children, className, disabled: propsDisabled = false, lockProps, returnFocus = true, preventScroll = 'never', makeContainerFocusable = false, onRequestEscape, keyCombinationMap = [], handleKeysOnInputs = true }, ref) {
        const [browserWindow, setBrowserWindow] = _react.useState();
        const previouslyFocusedElement = _react.useRef(null);
        const rootRef = _react.useRef(null);
        const focusables = _react.useRef([]);
        const isFocusablesOutdated = _react.useRef(true);
        const preventAutoFocusScroll = preventScroll === 'always' || preventScroll === 'on-autofocus';
        const preventWrappingScroll = preventScroll === 'always';
        _react.useEffect(()=>{
            setBrowserWindow(window);
            previouslyFocusedElement.current = window.document.activeElement;
        }, []);
        _react.useLayoutEffect(()=>{
            var _rootRef_current;
            const currentWindow = (_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.ownerDocument.defaultView;
            if (currentWindow && currentWindow !== browserWindow) {
                setBrowserWindow(currentWindow);
                previouslyFocusedElement.current = currentWindow.document.activeElement;
            }
        }, [
            browserWindow
        ]);
        _react.useLayoutEffect(()=>{
            if (!propsDisabled && browserWindow) {
                previouslyFocusedElement.current = browserWindow.document.activeElement;
                isFocusablesOutdated.current = true;
            }
        }, [
            propsDisabled,
            browserWindow
        ]);
        const { manager } = (0, _focus_lock_manager.useFocusLockManager)({
            browserWindow,
            disabled: propsDisabled
        });
        const disabled = propsDisabled || manager.surrenderLock;
        _react.useLayoutEffect(()=>{
            if (!rootRef.current || disabled) return;
            const observer = new MutationObserver(()=>{
                isFocusablesOutdated.current = true;
            });
            observer.observe(rootRef.current, {
                childList: true,
                subtree: true
            });
            return ()=>{
                observer.disconnect();
            };
        }, [
            disabled
        ]);
        const regenerateFocusables = _react.useCallback(()=>{
            if (isFocusablesOutdated.current && rootRef.current) {
                isFocusablesOutdated.current = false;
                focusables.current = (0, _dom_utils.getFocusablesInside)(rootRef.current);
            }
        }, []);
        const findFirstFocusable = _react.useCallback(()=>{
            regenerateFocusables();
            if (focusables.current.length > 0) return focusables.current[0];
        }, [
            regenerateFocusables
        ]);
        const focusFirst = _react.useCallback(()=>{
            const firstFocusable = findFirstFocusable();
            if (firstFocusable) firstFocusable.focus({
                preventScroll: preventWrappingScroll
            });
        }, [
            preventWrappingScroll,
            findFirstFocusable
        ]);
        const focusLast = _react.useCallback(()=>{
            regenerateFocusables();
            if (focusables.current.length > 0) focusables.current[focusables.current.length - 1].focus({
                preventScroll: preventWrappingScroll
            });
        }, [
            preventWrappingScroll,
            regenerateFocusables
        ]);
        const onFocusIn = _react.useCallback((e)=>{
            if (!rootRef.current || e.target == null) return;
            if (isTargetExceptedFromFocusLock(e.target)) return;
            if (e.relatedTarget == null && !rootRef.current.contains(e.target)) {
                focusFirst();
                return;
            }
        }, [
            focusFirst
        ]);
        const onFocusOut = _react.useCallback((e)=>{
            if (!rootRef.current || manager.surrenderLock) return;
            if (!e.relatedTarget || rootRef.current.contains(e.relatedTarget) || isTargetExceptedFromFocusLock(e.relatedTarget))
                return;
            if (e.target && rootRef.current.contains(e.target)) {
                e.target.focus({
                    preventScroll: preventWrappingScroll
                });
                return;
            }
            focusFirst();
        }, [
            focusFirst,
            manager,
            preventWrappingScroll
        ]);
        _react.useLayoutEffect(()=>{
            if (!disabled && browserWindow) {
                browserWindow.document.addEventListener('focusout', onFocusOut, true);
                browserWindow.document.addEventListener('focusin', onFocusIn, true);
                return ()=>{
                    browserWindow.document.removeEventListener('focusout', onFocusOut, true);
                    browserWindow.document.removeEventListener('focusin', onFocusIn, true);
                };
            }
        }, [
            browserWindow,
            disabled,
            onFocusIn,
            onFocusOut
        ]);
        _react.useLayoutEffect(()=>{
            if (!manager.isReady || browserWindow == null) return;
            if (propsDisabled || manager.surrenderLock || !rootRef.current) return;
            const { activeElement } = browserWindow.document;
            if (rootRef.current.contains(activeElement))
            return;
            if (!autoFocus) {
                activeElement === null || activeElement === void 0 ? void 0 : activeElement.blur();
                return;
            }
            const autoFocusElement = (rootRef.current ? (0, _dom_utils.findAutoFocusElement)(rootRef.current) : null) || findFirstFocusable();
            if (autoFocusElement && !isTargetExceptedFromFocusLock(autoFocusElement)) (0, _dom_utils.focusWithConditionalDelayHack)(autoFocusElement, {
                preventScroll: preventAutoFocusScroll
            });
        }, [
            autoFocus,
            browserWindow,
            findFirstFocusable,
            manager.isReady,
            manager,
            preventAutoFocusScroll,
            propsDisabled
        ]);
        const returnFocusRef = _react.useRef(returnFocus && !disabled);
        returnFocusRef.current = returnFocus && !disabled;
        _react.useEffect(()=>{
            if (!propsDisabled) {
                const el = previouslyFocusedElement.current;
                return ()=>{
                    if (returnFocusRef.current && !manager.surrenderLock && el) el.focus({
                        preventScroll: preventWrappingScroll
                    });
                };
            }
        }, [
            propsDisabled
        ]);
        const finalKeyCombinationMap = _react.useMemo(()=>{
            const escapeKeyHandler = onRequestEscape && !disabled ? [
                'Escape',
                (e)=>{
                    e.stopPropagation();
                    onRequestEscape();
                }
            ] : undefined;
            return [
                escapeKeyHandler,
                ...keyCombinationMap
            ].filter(_exists.exists);
        }, [
            disabled,
            keyCombinationMap,
            onRequestEscape
        ]);
        const { ref: keyHandlerRef } = (0, _key_combinations.useKeyCombinationHandler)(finalKeyCombinationMap, {
            handleInputs: handleKeysOnInputs
        });
        return (0, _jsxruntime.jsx)(_focus_lock_manager.FocusLockManagerContextProvider, {
            value: manager,
            children: (0, _jsxruntime.jsxs)("div", {
                ...lockProps,
                className: className,
                ref: (0, _composereactrefs.default)(rootRef, ref, keyHandlerRef),
                tabIndex: makeContainerFocusable ? -1 : undefined,
                children: [
                    (0, _jsxruntime.jsx)("div", {
                        onFocus: disabled ? undefined : focusLast,
                        tabIndex: disabled ? undefined : 0,
                        ...FOCUS_GUARD_PROP
                    }),
                    children,
                    (0, _jsxruntime.jsx)("div", {
                        onFocus: disabled ? undefined : focusFirst,
                        tabIndex: disabled ? undefined : 0,
                        ...FOCUS_GUARD_PROP
                    })
                ]
            })
        });
    }
));
function isTargetExceptedFromFocusLock(target) {
    if ('hasAttribute' in target) return target.hasAttribute(_dom_utils.FOCUS_LOCK_EXCEPTED_ATTR);
    return false;
}
