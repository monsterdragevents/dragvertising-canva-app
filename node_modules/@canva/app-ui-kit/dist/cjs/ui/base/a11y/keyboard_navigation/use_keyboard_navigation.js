"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "useKeyboardNavigation", {
    enumerable: true,
    get: function() {
        return useKeyboardNavigation;
    }
});
const _react = _interop_require_wildcard(require("react"));
const _access_mode_state = require('../access_mode_state/access_mode_state');
const _key_combinations = require('../../key_combinations/key_combinations');
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function useKeyboardNavigation(size, options = {}) {
    const { direction = 'vertical', mode = 'default', handleInputs = false, extraNavigation = true, onChange, onPrev, onNext, onFirst, onLast, onSelect, onExit } = options;
    const [index, setIndex] = _react.useState(()=>-1);
    const sizeRef = _react.useRef(size);
    const indexRef = _react.useRef(index);
    const onChangeRef = _react.useRef(onChange);
    sizeRef.current = size;
    indexRef.current = index;
    onChangeRef.current = onChange;
    const moveTo = _react.useCallback((index = -1)=>{
        if (indexRef.current !== index) {
            var _onChangeRef_current;
            setIndex(indexRef.current = index);
            (_onChangeRef_current = onChangeRef.current) === null || _onChangeRef_current === void 0 ? void 0 : _onChangeRef_current.call(onChangeRef, indexRef.current);
        }
    }, []);
    const moveToFirst = _react.useCallback(()=>moveTo(0), [
        moveTo
    ]);
    const moveToLast = _react.useCallback(()=>moveTo(sizeRef.current - 1), [
        moveTo
    ]);
    _react.useEffect(()=>{
        moveTo(size != null ? Math.min(indexRef.current, size - 1) : -1);
    }, [
        size,
        moveTo
    ]);
    const _onPrev = _react.useCallback((e)=>{
        e.preventDefault();
        if (e.isComposing)
            return;
        const index = indexRef.current;
        let newIndex = Math.max(0, index - 1);
        onPrev === null || onPrev === void 0 ? void 0 : onPrev(e, index);
        if (mode === 'cycle' && newIndex === index) newIndex = sizeRef.current - 1;
        else if (newIndex === 0) onFirst === null || onFirst === void 0 ? void 0 : onFirst(e, index);
        moveTo(newIndex);
        _access_mode_state.accessModeState.setAccessMode('keyboard');
    }, [
        onPrev,
        onFirst,
        moveTo,
        mode
    ]);
    const _onNext = _react.useCallback((e)=>{
        e.preventDefault();
        if (e.isComposing)
            return;
        const index = indexRef.current;
        const size = sizeRef.current;
        let newIndex = Math.min(size - 1, index + 1);
        onNext === null || onNext === void 0 ? void 0 : onNext(e, index);
        if (mode === 'cycle' && newIndex === index) newIndex = 0;
        else if (newIndex === size - 1) onLast === null || onLast === void 0 ? void 0 : onLast(e, index);
        moveTo(newIndex);
        _access_mode_state.accessModeState.setAccessMode('keyboard');
    }, [
        onNext,
        mode,
        moveTo,
        onLast
    ]);
    const _onFirst = _react.useCallback((e)=>{
        e.preventDefault();
        onFirst === null || onFirst === void 0 ? void 0 : onFirst(e, indexRef.current);
        moveToFirst();
        _access_mode_state.accessModeState.setAccessMode('keyboard');
    }, [
        onFirst,
        moveToFirst
    ]);
    const _onLast = _react.useCallback((e)=>{
        e.preventDefault();
        onLast === null || onLast === void 0 ? void 0 : onLast(e, indexRef.current);
        moveToLast();
        _access_mode_state.accessModeState.setAccessMode('keyboard');
    }, [
        onLast,
        moveToLast
    ]);
    const _onSelectWithSpace = _react.useCallback((e)=>{
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(e, indexRef.current);
    }, [
        onSelect
    ]);
    const _onSelectWithEnter = _react.useCallback((e)=>{
        if (e.keyCode === 229)
        return;
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(e, indexRef.current);
    }, [
        onSelect
    ]);
    const _onExit = _react.useCallback((e)=>{
        if (e.isComposing)
        return;
        onExit === null || onExit === void 0 ? void 0 : onExit(e, indexRef.current);
    }, [
        onExit
    ]);
    const keyCombinationMap = _react.useMemo(()=>{
        const prevKey = direction === 'vertical' ? 'ArrowUp' : 'previous';
        const nextKey = direction === 'vertical' ? 'ArrowDown' : 'next';
        const map = [
            [
                prevKey,
                _onPrev
            ],
            [
                nextKey,
                _onNext
            ],
            [
                ' ',
                _onSelectWithSpace
            ],
            [
                'Enter',
                _onSelectWithEnter
            ],
            [
                'Escape',
                _onExit
            ],
            [
                'Tab',
                _onExit
            ],
            [
                (0, _key_combinations.shift)('Tab'),
                _onExit
            ]
        ];
        if (extraNavigation) map.push([
            'Home',
            _onFirst
        ], [
            (0, _key_combinations.option)(prevKey),
            _onFirst
        ], [
            (0, _key_combinations.command)(prevKey),
            _onFirst
        ], [
            'End',
            _onLast
        ], [
            (0, _key_combinations.option)(nextKey),
            _onLast
        ], [
            (0, _key_combinations.command)(nextKey),
            _onLast
        ]);
        return map;
    }, [
        direction,
        extraNavigation,
        _onPrev,
        _onNext,
        _onFirst,
        _onLast,
        _onSelectWithEnter,
        _onSelectWithSpace,
        _onExit
    ]);
    const { ref } = (0, _key_combinations.useKeyCombinationHandler)(keyCombinationMap, {
        handleInputs
    });
    return {
        ref,
        index,
        moveTo,
        moveToFirst,
        moveToLast
    };
}
