"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get FocusLockManagerContextProvider () {
        return FocusLockManagerContextProvider;
    },
    get useFocusLockManager () {
        return useFocusLockManager;
    }
});
const _make_observable = require('../../../../base/make_observable/make_observable');
const _mobx = _interop_require_wildcard(require("mobx"));
const _mobxreactlite = require("mobx-react-lite");
const _react = _interop_require_wildcard(require("react"));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function isRealFocusLockManager(manager) {
    return manager.kind === 'real';
}
class FakeFocusLockManager {
    constructor(){
        this.kind = 'fake';
        this.surrenderLock = true;
        this.isReady = false;
    }
}
class RealFocusLockManager {
    static _makeObservable(instance) {
        (0, _make_observable.makeObservable)(instance, {
            windowToChildrenManagers: _mobx.observable.shallow,
            browserWindow: _mobx.observable.ref,
            _isReady: _mobx.observable.ref,
            _isEnabled: _mobx.observable.ref,
            hasEnabledDescendant: _mobx.computed,
            isActiveBranch: _mobx.computed,
            surrenderLock: _mobx.computed,
            isReady: _mobx.computed,
            setReady: _mobx.action.bound,
            isEnabled: _mobx.computed,
            setEnabled: _mobx.action.bound,
            setWindow: _mobx.action.bound,
            addChildManager: _mobx.action.bound,
            removeChildManager: _mobx.action.bound
        });
    }
    get hasEnabledDescendant() {
        const childManagers = this.windowToChildrenManagers.get(this.browserWindow);
        if (childManagers == null || childManagers.length === 0) return false;
        return childManagers.some((manager)=>manager.isEnabled || manager.hasEnabledDescendant);
    }
    get isActiveBranch() {
        if (!this.parentManager) return true;
        var _this_parentManager_windowToChildrenManagers_get;
        const childrenManagers = (_this_parentManager_windowToChildrenManagers_get = this.parentManager.windowToChildrenManagers.get(this.browserWindow)) !== null && _this_parentManager_windowToChildrenManagers_get !== void 0 ? _this_parentManager_windowToChildrenManagers_get : [];
        const siblingManagers = childrenManagers.filter((manager)=>manager !== this);
        const isSelfOrDescendantsEnabled = this.isEnabled || this.hasEnabledDescendant;
        if (siblingManagers == null || siblingManagers.length === 0 || childrenManagers[childrenManagers.length - 1] === this)
        return this.parentManager.isActiveBranch && isSelfOrDescendantsEnabled;
        else {
            const selfIndex = childrenManagers.indexOf(this);
            if (selfIndex === -1)
            return false;
            const hasActiveNewerSiblings = childrenManagers.slice(selfIndex + 1).some((manager)=>manager.isActiveBranch);
            return !hasActiveNewerSiblings && this.parentManager.isActiveBranch && isSelfOrDescendantsEnabled;
        }
    }
    get surrenderLock() {
        if (!this.isReady) return true;
        if (!this.isActiveBranch) return true;
        return this.hasEnabledDescendant;
    }
    get isReady() {
        return this._isReady;
    }
    setReady() {
        this._isReady = true;
    }
    get isEnabled() {
        return this._isEnabled;
    }
    setEnabled(enabled) {
        this._isEnabled = enabled;
    }
    setWindow(browserWindow) {
        this.browserWindow = browserWindow;
    }
    addChildManager(newManager, browserWindow) {
        var _this_windowToChildrenManagers_get;
        const childrenManagers = (_this_windowToChildrenManagers_get = this.windowToChildrenManagers.get(browserWindow)) !== null && _this_windowToChildrenManagers_get !== void 0 ? _this_windowToChildrenManagers_get : [];
        this.windowToChildrenManagers.set(browserWindow, [
            ...childrenManagers,
            newManager
        ]);
    }
    removeChildManager(manager, browserWindow) {
        const childrenManagers = this.windowToChildrenManagers.get(browserWindow);
        if (!childrenManagers) return;
        const resultManagers = childrenManagers.filter((childManager)=>childManager !== manager);
        if (resultManagers.length === 0) this.windowToChildrenManagers.delete(browserWindow);
        else this.windowToChildrenManagers.set(browserWindow, resultManagers);
    }
    constructor(parentManager){
        this.parentManager = parentManager;
        this.kind = (RealFocusLockManager._makeObservable(this), 'real');
        this.windowToChildrenManagers = new Map();
        this.browserWindow = window;
        this._isReady = false;
        this._isEnabled = false;
    }
}
function createFocusLockManager(parentManager) {
    if (typeof window !== 'undefined') return new RealFocusLockManager(parentManager);
    else return new FakeFocusLockManager();
}
const FocusLockManagerContext = _react.createContext(createFocusLockManager());
const FocusLockManagerContextProvider = FocusLockManagerContext.Provider;
function useFocusLockManager({ browserWindow, disabled }) {
    const parentManager = _react.useContext(FocusLockManagerContext);
    const manager = (0, _mobxreactlite.useLocalObservable)(()=>{
        if (isRealFocusLockManager(parentManager)) return new RealFocusLockManager(parentManager);
        else return new FakeFocusLockManager();
    });
    _react.useLayoutEffect(()=>{
        if (!isRealFocusLockManager(manager) || !isRealFocusLockManager(parentManager) || browserWindow == null) return;
        manager.setWindow(browserWindow);
        parentManager.addChildManager(manager, browserWindow);
        manager.setReady();
        return ()=>{
            parentManager.removeChildManager(manager, browserWindow);
        };
    }, [
        browserWindow,
        manager,
        parentManager
    ]);
    _react.useLayoutEffect(()=>{
        if (!isRealFocusLockManager(manager) || !isRealFocusLockManager(parentManager) || browserWindow == null) return;
        manager.setEnabled(!disabled);
    }, [
        browserWindow,
        disabled,
        manager,
        parentManager
    ]);
    return {
        manager
    };
}
