"use strict"
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "BaseSelect", {
    enumerable: true,
    get: function() {
        return BaseSelect;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _mobx = require("mobx");
const _mobxreactlite = require("mobx-react-lite");
const _react = _interop_require_wildcard(require("react"));
const _use_keyboard_navigation = require('../../../a11y/keyboard_navigation/use_keyboard_navigation');
const _base_input = require('../../base_input/base_input');
const _input_decorators = require('../../input_decorators/input_decorators');
const _base_select_presenter = require("./base_select_presenter");
const _base_select_util = require("./base_select_util");
const _stateless_base_select = require("./stateless_base_select");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const BaseSelect = (0, _mobxreactlite.observer)(function BaseSelect(props) {
    const { Menu = _stateless_base_select.BaseSelectMenu, menu = (props)=> (0, _jsxruntime.jsx)(Menu, {
            ...props
        }), triggerContainerRef, menuContainerRef, searchable, isSelected = _base_select_util.defaultIsSelected, disabled, onChange, onOpen, onClose, closeOnSelection } = props;
    const [store] = _react.useState(()=>{
        var _props_store;
        return (_props_store = props.store) !== null && _props_store !== void 0 ? _props_store : new _base_select_presenter.BaseSelectStore();
    });
    const [presenter] = _react.useState(()=>{
        var _props_presenter;
        return (_props_presenter = props.presenter) !== null && _props_presenter !== void 0 ? _props_presenter : new _base_select_presenter.BaseSelectPresenter();
    });
    var _props_open;
    const open = (_props_open = props.open) !== null && _props_open !== void 0 ? _props_open : store.open;
    var _props_value;
    const value = (_props_value = props.value) !== null && _props_value !== void 0 ? _props_value : store.value;
    const { query } = store;
    const isSearchable = !!searchable;
    const { filterFn = _base_select_util.defaultFilterFn, onInputChange, inputPlaceholder, allowClear: searchableAllowClear = 'never' } = typeof searchable === 'object' ? searchable : {};
    const optionGroups = _react.useMemo(()=>{
        return (0, _base_select_util.normalizeOptionGroups)(props.options);
    }, [
        props.options
    ]);
    const options = _react.useMemo(()=>{
        if (!isSearchable || !query) return props.options;
        return optionGroups.map((optionGroup)=>{
            const filteredOptions = filterFn(query, optionGroup.options, value, isSelected);
            return {
                label: optionGroup.label,
                options: filteredOptions
            };
        }).filter((optionGroup)=>optionGroup.options.length > 0);
    }, [
        query,
        isSearchable,
        filterFn,
        optionGroups,
        props.options,
        value,
        isSelected
    ]);
    const flatOptions = _react.useMemo(()=>{
        return (0, _base_select_util.flattenOptions)(options);
    }, [
        options
    ]);
    const defaultOnSelection = _react.useCallback((option, e)=>{
        if (!isSelected(option, value)) {
            presenter.setValue(store, option.value);
            onChange === null || onChange === void 0 ? void 0 : onChange(option.value, option);
        }
    }, [
        isSelected,
        value,
        presenter,
        store,
        onChange
    ]);
    var _props_onSelection;
    const onSelection = (_props_onSelection = props.onSelection) !== null && _props_onSelection !== void 0 ? _props_onSelection : defaultOnSelection;
    const openMenu = _react.useCallback(()=>{
        if (!open) {
            presenter.toggle(store, true);
            onOpen === null || onOpen === void 0 ? void 0 : onOpen();
        }
    }, [
        open,
        store,
        presenter,
        onOpen
    ]);
    const closeMenu = _react.useCallback(()=>{
        if (open) {
            presenter.toggle(store, false);
            onClose === null || onClose === void 0 ? void 0 : onClose();
        }
    }, [
        open,
        store,
        presenter,
        onClose
    ]);
    const initialActiveIndex = _react.useRef(-1);
    const keyboardNavigation = (0, _use_keyboard_navigation.useKeyboardNavigation)(flatOptions.length, {
        handleInputs: true,
        onNext (e, index) {
            if (!open && !disabled) {
                initialActiveIndex.current = 0;
                openMenu();
            }
        },
        onPrev (e, index) {
            if (!open && !disabled) {
                initialActiveIndex.current = flatOptions.length - 1;
                openMenu();
            }
        },
        onSelect (e, index) {
            if (e.code === 'Space' && e.target instanceof HTMLInputElement && e.target.value.length > 0)
                return;
            e.preventDefault();
            if (!open) return openMenu();
            if (index === -1) return closeMenu();
            const activeOption = flatOptions[index];
            if (activeOption == null) return;
            if (activeOption.disabled) return;
            onSelection === null || onSelection === void 0 ? void 0 : onSelection(activeOption, e);
            if (closeOnSelection === true)
                return closeMenu();
            if (closeOnSelection === false) return;
            if (e.code === 'Enter') closeMenu();
        },
        onExit (e, index) {
            if (!open) return;
            if (e.code === 'Escape' && e.target instanceof HTMLInputElement)
                return;
            closeMenu();
        }
    });
    const wasOpen = _react.useRef(open);
    const { moveTo } = keyboardNavigation;
    _react.useLayoutEffect(()=>{
        if (open && open !== wasOpen.current) {
            if (initialActiveIndex.current === -1) {
                const firstSelectedOptionIndex = flatOptions.findIndex((option)=>isSelected(option, value));
                if (firstSelectedOptionIndex > -1) initialActiveIndex.current = firstSelectedOptionIndex;
            }
            moveTo(initialActiveIndex.current);
        }
        wasOpen.current = open;
        initialActiveIndex.current = -1;
    });
    const onItemHover = _react.useCallback((option)=>{
        moveTo(flatOptions.indexOf(option));
    }, [
        flatOptions,
        moveTo
    ]);
    const onItemClick = _react.useCallback((option, e)=>{
        if (option.disabled) return;
        if (closeOnSelection !== false) closeMenu();
        onSelection(option, e);
    }, [
        onSelection,
        closeMenu,
        closeOnSelection
    ]);
    const onSearchInputChange = _react.useCallback((value)=>{
        onInputChange === null || onInputChange === void 0 ? void 0 : onInputChange(value);
        store.query = value.trimStart();
        moveTo(0);
    }, [
        onInputChange,
        moveTo,
        store
    ]);
    const menuWithSearchInput = (props)=>menu({
            ...props,
            header: (0, _jsxruntime.jsx)(_base_input.BaseInput, {
                type: "search",
                value: store.query,
                onChange: (0, _mobx.action)(onSearchInputChange),
                placeholder: inputPlaceholder,
                icon: {
                    type: 'search',
                    align: 'start'
                },
                ariaActiveDescendant: (0, _base_select_util.deriveIdentifier)(props.id, props.activeIndex),
                onKeyDown: (e)=>e.key === 'Tab' && e.preventDefault(),
                end: searchableAllowClear !== 'never' && (0, _jsxruntime.jsx)(_input_decorators.ClearDecorator, {
                    when: searchableAllowClear === 'always' ? 'always' : 'not-empty'
                })
            })
        });
    return (0, _jsxruntime.jsx)(_mobxreactlite.Observer, {
        children: ()=>(0, _jsxruntime.jsx)(_stateless_base_select.StatelessBaseSelect, {
                ...props,
                value: value,
                open: open,
                activeIndex: keyboardNavigation.index > -1 ? keyboardNavigation.index : undefined,
                onRequestClose: closeMenu,
                onRequestOpen: openMenu,
                onItemClick: onItemClick,
                onItemHover: onItemHover,
                focusOnMenu: isSearchable,
                triggerContainerRef: (0, _composereactrefs.default)(open && searchable ? null : keyboardNavigation.ref, triggerContainerRef),
                menuContainerRef: (0, _composereactrefs.default)(open && searchable ? keyboardNavigation.ref : null, menuContainerRef),
                menu: searchable ? menuWithSearchInput : menu,
                options: options,
                tooltipLabel: props.tooltipLabel,
                tooltipPlacement: props.tooltipPlacement,
                tooltipDisabled: props.tooltipDisabled
            })
    });
});
