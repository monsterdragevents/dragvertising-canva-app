"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RadioItem", {
    enumerable: true,
    get: function() {
        return RadioItem;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _classnames = _interop_require_default(require("classnames"));
const _mobxreactlite = require("mobx-react-lite");
const _react = _interop_require_wildcard(require("react"));
const _access_mode_state = require('../../../a11y/access_mode_state/access_mode_state');
const _handle = require('../../../handle/handle');
const _key_combinations = require('../../../key_combinations/key_combinations');
const _typography = require('../../../typography/typography');
const _radio_itemcss = _interop_require_default(require("./radio_item.css"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const setToKeyboardMode = ()=>{
    _access_mode_state.accessModeState.setAccessMode('keyboard');
};
const inputKeyMap = [
    [
        'ArrowUp',
        setToKeyboardMode
    ],
    [
        'ArrowDown',
        setToKeyboardMode
    ],
    [
        'ArrowLeft',
        setToKeyboardMode
    ],
    [
        'ArrowRight',
        setToKeyboardMode
    ]
];
const RadioItem = _react.forwardRef(RadioItemImpl);
function RadioItemImpl({ label, description, className, disabled, checked, ariaLabel, name, value, onChange: _onChange, onFocus, onBlur }, ref) {
    const formatValue = ()=>{
        if (value === undefined) return undefined;
        if (typeof value === 'string' || typeof value === 'number') return value;
        return JSON.stringify(value);
    };
    const onChange = (event)=>{
        if (_onChange != null && !checked) _onChange(value, event);
    };
    const inputId = _react.useId();
    const labelId = _react.useId();
    const descriptionId = _react.useId();
    const inputRef = _react.useRef(null);
    _react.useImperativeHandle(ref, ()=>(0, _handle.createBasicHTMLHandle)(inputRef));
    return (0, _jsxruntime.jsx)(_key_combinations.WithKeyCombinationHandler, {
        map: inputKeyMap,
        handleInputs: true,
        children: ({ ref: keyCombinationRef })=>(0, _jsxruntime.jsx)(_mobxreactlite.Observer, {
                children: ()=>(0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                        children: [
                            (0, _jsxruntime.jsx)("input", {
                                id: inputId,
                                "aria-label": ariaLabel,
                                "aria-labelledby": !ariaLabel && label ? labelId : undefined,
                                "aria-describedby": description ? descriptionId : undefined,
                                type: "radio",
                                className: _radio_itemcss.default.radio,
                                onChange: onChange,
                                ref: (0, _composereactrefs.default)(inputRef, keyCombinationRef),
                                value: formatValue(),
                                disabled: disabled,
                                checked: checked,
                                name: name,
                                onFocus: onFocus,
                                onBlur: onBlur
                            }),
                            (0, _jsxruntime.jsxs)("label", {
                                htmlFor: inputId,
                                "aria-hidden": true,
                                onClick: (event)=>event.stopPropagation(),
                                className: (0, _classnames.default)(_radio_itemcss.default.label, className, {
                                    [_radio_itemcss.default.hideOutline]: _access_mode_state.accessModeState.isMouseMode,
                                    [_radio_itemcss.default.disabled]: disabled
                                }),
                                children: [
                                    (0, _jsxruntime.jsx)("span", {
                                        "aria-hidden": true,
                                        className: (0, _classnames.default)(_radio_itemcss.default.uiRadio, {
                                            [_radio_itemcss.default.hasLabelText]: !!label
                                        })
                                    }),
                                    (0, _jsxruntime.jsx)(RadioItemLabel, {
                                        label: label,
                                        description: description,
                                        labelId: labelId,
                                        descriptionId: descriptionId,
                                        disabled: disabled
                                    })
                                ]
                            })
                        ]
                    })
            })
    });
}
function RadioItemLabel({ label, description, disabled, labelId, descriptionId }) {
    const labelElement = typeof label === 'string' ? (0, _jsxruntime.jsx)(_typography.Text, {
        id: labelId,
        tagName: "span",
        margins: "none",
        tone: disabled ? 'tertiary' : 'primary',
        children: label
    }) : (0, _jsxruntime.jsx)("div", {
        id: labelId,
        children: label
    });
    if (!description) return labelElement;
    return (0, _jsxruntime.jsxs)("div", {
        children: [
            labelElement,
            (0, _jsxruntime.jsx)(_typography.Text, {
                id: descriptionId,
                tone: "tertiary",
                size: "small",
                children: description
            })
        ]
    });
}
