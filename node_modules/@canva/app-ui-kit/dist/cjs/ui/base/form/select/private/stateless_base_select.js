"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get BaseSelectItem () {
        return BaseSelectItem;
    },
    get BaseSelectMenu () {
        return BaseSelectMenu;
    },
    get BaseSelectTrigger () {
        return BaseSelectTrigger;
    },
    get StatelessBaseSelect () {
        return StatelessBaseSelect;
    },
    get WindowedSelectMenu () {
        return WindowedSelectMenu;
    },
    get renderEmptyMenuContent () {
        return renderEmptyMenuContent;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _screen_reader_content = require('../../../a11y/screen_reader_content/screen_reader_content');
const _box = require('../../../box/box');
const _base_button = require('../../../button/base_button/base_button');
const _divider = require('../../../divider/divider');
const _checkbox = require('../../checkbox/checkbox');
const _icon = require('../../../icons/check/icon');
const _icon1 = require('../../../icons/chevron_down/icon');
const _layout = require('../../../layout/layout');
const _menu = require('../../../menu/menu');
const _metrics = require('../../../metrics/metrics');
const _scroll_window = require('../../../scroll_controls/scroll_window');
const _scroll_positioner = require('../../../scroll_positioner/scroll_positioner');
const _flyout = require('../../../surface/flyout/flyout');
const _colorcss = _interop_require_default(require('../../../tokens/color.css'));
const _typography = require('../../../typography/typography');
const _base_selectcss = _interop_require_default(require("./base_select.css"));
const _base_selectmessages = require("./base_select.messages");
const _base_select_util = require("./base_select_util");
const _truncated_list = require("./truncated_list");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const DEFAULT_FLYOUT_WIDTH_UNITS = '40u';
const DEFAULT_FLYOUT_WIDTH = parseInt(DEFAULT_FLYOUT_WIDTH_UNITS, 10) * _metrics.baseUnit;
function StatelessBaseSelect(props) {
    const { Trigger = BaseSelectTrigger, Menu = BaseSelectMenu, Item, Flyout = _flyout.Flyout, trigger = (props)=> (0, _jsxruntime.jsx)(Trigger, {
            ...props
        }), menu = (props)=> (0, _jsxruntime.jsx)(Menu, {
            ...props
        }), item, value, placeholder, open, disabled, error, stretch, activeIndex, options, focusOnMenu = false, flyoutPlacement = 'bottom-start', flyoutWidth: flyoutWidthProp, blockOutsidePointerEvents, id, ariaLabelledBy, ariaDescribedBy, tooltipLabel, tooltipPlacement, tooltipDisabled, className, onRequestClose, onRequestOpen, onBlur, onFocus, onItemClick, onItemHover, areEqual = _base_select_util.defaultAreEqual, isSelected = _base_select_util.defaultIsSelected, getLabel = _base_select_util.defaultGetLabel } = props;
    const menuId = _react.useId();
    const labelId = _react.useId();
    const triggerContainerRef = _react.useRef(null);
    const menuContainerRef = _react.useRef(null);
    const flatOptions = _react.useMemo(()=>{
        var _props_flatOptions;
        return (_props_flatOptions = props.flatOptions) !== null && _props_flatOptions !== void 0 ? _props_flatOptions : (0, _base_select_util.flattenOptions)(props.options);
    }, [
        props.options,
        props.flatOptions
    ]);
    const optionGroups = _react.useMemo(()=>{
        var _props_optionGroups;
        return (_props_optionGroups = props.optionGroups) !== null && _props_optionGroups !== void 0 ? _props_optionGroups : (0, _base_select_util.normalizeOptionGroups)(props.options);
    }, [
        props.options,
        props.optionGroups
    ]);
    const selectedOptions = _react.useMemo(()=>{
        var _props_selectedOptions;
        return (_props_selectedOptions = props.selectedOptions) !== null && _props_selectedOptions !== void 0 ? _props_selectedOptions : flatOptions.filter((option)=>isSelected(option, value));
    }, [
        flatOptions,
        props.selectedOptions,
        isSelected,
        value
    ]);
    const activeDescendantId = (0, _base_select_util.deriveIdentifier)(menuId, activeIndex);
    var _props_ariaLabel;
    const ariaLabel = (_props_ariaLabel = props.ariaLabel) !== null && _props_ariaLabel !== void 0 ? _props_ariaLabel : !ariaLabelledBy && typeof props.title === 'string' ? props.title : undefined;
    const [flyoutWidth, setFlyoutWidth] = _react.useState(flyoutWidthProp !== null && flyoutWidthProp !== void 0 ? flyoutWidthProp : DEFAULT_FLYOUT_WIDTH_UNITS);
    const onRequestToggle = _react.useCallback(()=>{
        if (open) onRequestClose();
        else onRequestOpen();
    }, [
        open,
        onRequestClose,
        onRequestOpen
    ]);
    _react.useEffect(()=>{
        var _triggerContainerRef_current;
        if (!stretch || flyoutWidthProp != null) {
            setFlyoutWidth(flyoutWidthProp !== null && flyoutWidthProp !== void 0 ? flyoutWidthProp : DEFAULT_FLYOUT_WIDTH_UNITS);
            return;
        }
        var _triggerContainerRef_current_getBoundingClientRect_width;
        const triggerWidth = (_triggerContainerRef_current_getBoundingClientRect_width = (_triggerContainerRef_current = triggerContainerRef.current) === null || _triggerContainerRef_current === void 0 ? void 0 : _triggerContainerRef_current.getBoundingClientRect().width) !== null && _triggerContainerRef_current_getBoundingClientRect_width !== void 0 ? _triggerContainerRef_current_getBoundingClientRect_width : 0;
        const width = triggerWidth < DEFAULT_FLYOUT_WIDTH ? DEFAULT_FLYOUT_WIDTH_UNITS : 'trigger';
        setFlyoutWidth(width);
    }, [
        flyoutWidthProp,
        stretch
    ]);
    return (0, _jsxruntime.jsx)(Flyout, {
        placement: flyoutPlacement,
        open: open !== null && open !== void 0 ? open : false,
        onRequestClose: onRequestClose,
        captureFocus: focusOnMenu,
        width: flyoutWidth,
        title: props.title,
        headerEnd: props.headerEnd,
        headerDivider: "always",
        blockOutsidePointerEvents: blockOutsidePointerEvents,
        trigger: (0, _jsxruntime.jsx)("div", {
            ref: (0, _composereactrefs.default)(triggerContainerRef, props.triggerContainerRef),
            className: (0, _classnames.default)(_base_selectcss.default.triggerContainer, className, {
                [_base_selectcss.default.triggerStretch]: stretch
            }),
            children: trigger({
                value,
                options,
                flatOptions,
                optionGroups,
                selectedOptions,
                placeholder,
                disabled,
                error,
                open,
                id,
                ariaLabel,
                ariaLabelledBy,
                ariaDescribedBy,
                activeIndex,
                onBlur,
                onFocus,
                role: 'combobox',
                disclosure: true,
                labelId,
                active: open,
                ariaActiveDescendant: activeDescendantId,
                ariaControls: menuId,
                onRequestToggle,
                getLabel,
                isSelected,
                tooltipLabel,
                tooltipPlacement,
                tooltipDisabled
            })
        }),
        children: ({ mode })=>(0, _jsxruntime.jsx)("div", {
                className: _base_selectcss.default.menuContainer,
                ref: (0, _composereactrefs.default)(menuContainerRef, props.menuContainerRef),
                children: menu({
                    Item,
                    item,
                    id: menuId,
                    options,
                    flatOptions,
                    optionGroups,
                    selectedOptions,
                    value,
                    activeIndex,
                    activeOption: flatOptions[activeIndex !== null && activeIndex !== void 0 ? activeIndex : -1],
                    onItemClick,
                    onItemHover,
                    areEqual,
                    isSelected,
                    getLabel,
                    sizingMode: mode === 'popover' ? 'fixed' : 'fill',
                    menuContainerRef,
                    ariaLabel,
                    ariaLabelledBy,
                    children: options.length === 0 ? renderEmptyMenuContent() : undefined
                })
            })
    });
}
function BaseSelectTrigger(props) {
    var _selectedOptions_;
    const { selectedOptions } = props;
    const noSelection = !selectedOptions.length;
    var _props_Icon;
    const Icon = getIcon((_props_Icon = props.Icon) !== null && _props_Icon !== void 0 ? _props_Icon : 'auto', (_selectedOptions_ = selectedOptions[0]) === null || _selectedOptions_ === void 0 ? void 0 : _selectedOptions_.Icon);
    const ariaLabelledBy = props.ariaLabelledBy || (props.ariaLabel ? undefined : props.labelId);
    const ariaDescribedBy = getTriggerAriaDescribedBy(props);
    return (0, _jsxruntime.jsxs)(_base_button.BaseButton, {
        onClick: props.onRequestToggle,
        onBlur: props.onBlur,
        onFocus: props.onFocus,
        disclosure: true,
        pressed: props.open,
        disabled: props.disabled,
        className: (0, _classnames.default)(_base_selectcss.default.triggerButton, props.className),
        id: props.id,
        role: props.role,
        tooltipLabel: props.tooltipLabel,
        tooltipPlacement: props.tooltipPlacement,
        tooltipDisabled: props.tooltipDisabled,
        ariaLabel: props.ariaLabel,
        ariaLabelledBy: ariaLabelledBy,
        ariaDescribedBy: ariaDescribedBy,
        ariaControls: props.ariaControls,
        ariaHasPopup: "listbox",
        ariaActiveDescendant: props.ariaActiveDescendant,
        borderRadius: "element",
        paddingX: "1.5u",
        alignItems: "center",
        width: "full",
        border: "standard",
        tone: "secondary",
        backgroundColor: {
            default: _colorcss.default.colorControlBg,
            pressed: _colorcss.default.colorControlBg,
            hovered: _colorcss.default.colorControlBg,
            disabled: _colorcss.default.colorControlBgDisabled
        },
        borderColor: {
            default: props.error ? _colorcss.default.colorControlCriticalBorder : _colorcss.default.colorControlBorder,
            pressed: _colorcss.default.colorControlBorderFocused,
            hovered: _colorcss.default.colorControlBorderHovered,
            disabled: _colorcss.default.colorControlBorderDisabled
        },
        children: [
            Icon && (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                children: [
                    (0, _jsxruntime.jsx)(Icon, {
                        size: "medium"
                    }),
                    (0, _jsxruntime.jsx)(_layout.Spacer, {
                        size: "1u"
                    })
                ]
            }),
            (0, _jsxruntime.jsx)(_typography.Text, {
                id: props.labelId,
                tagName: "span",
                lineClamp: 1,
                tone: _typography.InheritColor,
                className: (0, _classnames.default)(_base_selectcss.default.label, {
                    [_base_selectcss.default.placeholder]: noSelection || props.disabled
                }),
                children: getTriggerContent(props)
            }),
            (0, _jsxruntime.jsx)(_icon1.ChevronDownIcon, {
                size: "medium"
            })
        ]
    });
}
function getIcon(Icon, FallbackIcon) {
    if (Icon === 'none') return undefined;
    if (Icon === 'auto') return FallbackIcon;
    return Icon;
}
function getTriggerContent(props) {
    if (props.children) return props.children;
    const hasSelection = props.selectedOptions.length > 0;
    var _props_placeholder;
    if (!hasSelection && props.disabled)
    return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            (0, _jsxruntime.jsx)(_screen_reader_content.ScreenReaderContent, {
                tagName: "span",
                children: _base_selectmessages.BaseSelectMessages.defaultDisabledMessage()
            }),
            (0, _jsxruntime.jsx)("span", {
                "aria-hidden": true,
                children: (_props_placeholder = props.placeholder) !== null && _props_placeholder !== void 0 ? _props_placeholder : _base_selectmessages.BaseSelectMessages.defaultPlaceholder()
            })
        ]
    });
    var _props_placeholder1;
    if (!hasSelection)
    return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            (0, _jsxruntime.jsx)(_screen_reader_content.ScreenReaderContent, {
                tagName: "span",
                children: _base_selectmessages.BaseSelectMessages.defaultNoSelectionMessage()
            }),
            (0, _jsxruntime.jsx)("span", {
                "aria-hidden": true,
                id: `${props.labelId}--placeholder`,
                children: (_props_placeholder1 = props.placeholder) !== null && _props_placeholder1 !== void 0 ? _props_placeholder1 : _base_selectmessages.BaseSelectMessages.defaultPlaceholder()
            })
        ]
    });
    const items = props.selectedOptions.map(props.getLabel);
    if (items.length > 1 && items.every((item)=>typeof item === 'string')) return (0, _jsxruntime.jsx)(_truncated_list.TruncatedList, {
        tagName: "span",
        items: items
    });
    return (0, _base_select_util.joinLabels)(items);
}
function getTriggerAriaDescribedBy(props) {
    if (props.children)
    return props.ariaDescribedBy;
    const hasSelection = props.selectedOptions.length > 0;
    var _props_ariaDescribedBy;
    if (!hasSelection) return `${(_props_ariaDescribedBy = props.ariaDescribedBy) !== null && _props_ariaDescribedBy !== void 0 ? _props_ariaDescribedBy : ''} ${props.labelId}--placeholder`.trim();
    return props.ariaDescribedBy;
}
function useScrollToActiveItem({ activeIndex }) {
    const scrollRef = _react.useRef(null);
    const activeItemRef = _react.useRef(null);
    _react.useEffect(()=>{
        if (!scrollRef.current || !activeItemRef.current) return;
        if (_scroll_positioner.ScrollPositioner.isAboveVisibleScroll(scrollRef.current, activeItemRef.current)) _scroll_positioner.ScrollPositioner.scrollToPutAtTop(scrollRef.current, activeItemRef.current);
        if (_scroll_positioner.ScrollPositioner.isBelowVisibleScroll(scrollRef.current, activeItemRef.current)) _scroll_positioner.ScrollPositioner.scrollToPutAtBottom(scrollRef.current, activeItemRef.current);
    }, [
        activeIndex,
        scrollRef
    ]);
    return {
        scrollRef,
        activeItemRef
    };
}
function BaseSelectMenu(props) {
    const { Item = BaseSelectItem, item = (props)=> (0, _jsxruntime.jsx)(Item, {
            ...props
        }), flatOptions, optionGroups, value, activeIndex, id, ariaLabel, ariaLabelledBy, header, footer, isSelected, getLabel, onItemClick, onItemHover, className, children, sizingMode } = props;
    const { scrollRef, activeItemRef } = useScrollToActiveItem({
        activeIndex
    });
    const hasMultipleGroups = optionGroups.length > 1;
    return (0, _jsxruntime.jsx)(WithHeaderAndFooter, {
        header: header,
        footer: footer,
        children: (0, _jsxruntime.jsx)("div", {
            className: (0, _classnames.default)(_base_selectcss.default.scrollContainer, sizingMode === 'fixed' && _base_selectcss.default.popover, className),
            ref: scrollRef,
            id: hasMultipleGroups ? id : undefined,
            role: hasMultipleGroups ? 'listbox' : undefined,
            "aria-label": hasMultipleGroups ? ariaLabel : undefined,
            "aria-labelledby": hasMultipleGroups ? ariaLabelledBy : undefined,
            children: children ? (0, _jsxruntime.jsx)("div", {
                role: "alert",
                children: children
            }) : optionGroups.map((optionGroup, groupIndex)=>(0, _jsxruntime.jsxs)(_react.Fragment, {
                    children: [
                        groupIndex > 0 && (0, _jsxruntime.jsx)("div", {
                            className: _base_selectcss.default.groupDivider,
                            children: (0, _jsxruntime.jsx)(_divider.Divider, {})
                        }),
                        (0, _jsxruntime.jsx)(OptionGroup, {
                            item: item,
                            menuId: id,
                            id: hasMultipleGroups ? undefined : id,
                            role: hasMultipleGroups ? 'group' : 'listbox',
                            ariaLabel: hasMultipleGroups ? undefined : ariaLabel,
                            ariaLabelledBy: hasMultipleGroups ? undefined : ariaLabelledBy,
                            activeItemRef: activeItemRef,
                            value: value,
                            optionIndexOffset: flatOptions.findIndex((o)=>o === optionGroup.options[0]),
                            activeIndex: activeIndex,
                            label: optionGroup.label,
                            options: optionGroup.options,
                            isSelected: isSelected,
                            onItemClick: onItemClick,
                            onItemHover: onItemHover,
                            getLabel: getLabel
                        })
                    ]
                }, groupIndex))
        })
    });
}
function OptionGroup({ item = (props)=> (0, _jsxruntime.jsx)(BaseSelectItem, {
        ...props
    }), id, menuId, role, ariaLabel, ariaLabelledBy, value, optionIndexOffset = 0, activeIndex, label, options, isSelected, activeItemRef, onItemClick, onItemHover, getLabel }) {
    const headingId = _react.useId();
    const multiSelectable = Array.isArray(value);
    return (0, _jsxruntime.jsxs)(_menu.Menu, {
        id: id,
        role: role,
        ariaMultiSelectable: multiSelectable,
        ariaLabel: ariaLabel,
        ariaLabelledBy: label ? headingId : ariaLabelledBy,
        children: [
            label != null && (0, _jsxruntime.jsx)(_menu.MenuDivider, {
                id: headingId,
                children: label
            }),
            options.map((option, i)=>{
                const selected = isSelected(option, value);
                const itemIndex = optionIndexOffset + i;
                const active = activeIndex === itemIndex;
                const id = (0, _base_select_util.deriveIdentifier)(menuId, itemIndex);
                return (0, _jsxruntime.jsx)(_react.Fragment, {
                    children: item({
                        id,
                        selected,
                        active,
                        forwardedRef: active ? activeItemRef : undefined,
                        onItemClick,
                        onItemHover,
                        getLabel,
                        option,
                        multiSelectable
                    })
                }, id);
            })
        ]
    });
}
function WindowedSelectMenu(props) {
    const { Item = BaseSelectItem, item = (props)=> (0, _jsxruntime.jsx)(Item, {
            ...props
        }), optionGroups, flatOptions, value, activeIndex, id, ariaLabel, ariaLabelledBy, header, footer, isSelected, getLabel, onItemClick, onItemHover, className, children, sizingMode, itemHeightMultiplier = _menu.ITEM_HEIGHT_MULTIPIER } = props;
    const rootFontSize = _react.useMemo(()=>{
        return (0, _metrics.getRootFontSize)();
    }, []);
    const textZoomBaseUnit = (0, _metrics.useTextZoomBaseUnit)(rootFontSize);
    const itemSizes = _react.useMemo(()=>{
        const itemSizes = [];
        optionGroups.forEach((optionGroup, groupIndex)=>{
            optionGroup.options.forEach((option, optionIndex)=>{
                let height = itemHeightMultiplier * textZoomBaseUnit;
                if (optionIndex === 0 && groupIndex > 0)
                    height += _menu.DIVIDER_HEIGHT_MULTIPIER * textZoomBaseUnit;
                if (optionIndex === 0 && optionGroup.label != null)
                    height += _menu.TEXT_DIVIDER_HEIGHT_MULTIPIER * textZoomBaseUnit;
                itemSizes.push(height);
            });
        });
        return itemSizes;
    }, [
        itemHeightMultiplier,
        optionGroups,
        textZoomBaseUnit
    ]);
    const { scrollRef, activeItemRef } = useScrollToActiveItem({
        activeIndex
    });
    _react.useEffect(()=>{
        if (!scrollRef.current || activeIndex == null || activeIndex < 5)
            return;
        const activeOptionHeight = itemSizes[activeIndex];
        const activeOptionPosition = itemSizes.slice(0, activeIndex).reduce((a, h)=>a + h);
        const paddingTop = parseInt(window.getComputedStyle(scrollRef.current).paddingTop, 10);
        const scrollOffset = scrollRef.current.offsetHeight - paddingTop - activeOptionHeight;
        scrollRef.current.scrollTop = activeOptionPosition - scrollOffset;
    }, []);
    const hasMultipleGroups = optionGroups.length > 1;
    return (0, _jsxruntime.jsx)(WithHeaderAndFooter, {
        header: header,
        footer: footer,
        children: (0, _jsxruntime.jsx)(_scroll_window.ScrollWindow, {
            layout: "vertical",
            children: ({ scrollableRef, scrollState })=>(0, _jsxruntime.jsx)("div", {
                    className: (0, _classnames.default)(_base_selectcss.default.scrollContainer, sizingMode === 'fixed' && _base_selectcss.default.popover, className),
                    ref: (0, _composereactrefs.default)(scrollableRef, scrollRef),
                    id: hasMultipleGroups ? id : undefined,
                    role: hasMultipleGroups ? 'listbox' : undefined,
                    "aria-label": hasMultipleGroups ? ariaLabel : undefined,
                    "aria-labelledby": hasMultipleGroups ? ariaLabelledBy : undefined,
                    children: children ? (0, _jsxruntime.jsx)("div", {
                        role: "alert",
                        children: children
                    }) : (0, _jsxruntime.jsx)(_scroll_window.WindowedList, {
                        scrollState: scrollState,
                        itemSizes: itemSizes,
                        overscan: 2,
                        children: (state, itemPositions)=>{
                            if (!state) return (0, _jsxruntime.jsx)("div", {
                                role: "none",
                                style: {
                                    height: itemPositions[itemPositions.length - 1]
                                }
                            });
                            const { firstVisible, lastVisible } = state;
                            const spaceBefore = itemPositions[firstVisible];
                            const spaceAfter = itemPositions[itemPositions.length - 1] - itemPositions[lastVisible];
                            const visibleGroups = (0, _base_select_util.sliceOptionGroups)(optionGroups, firstVisible, lastVisible);
                            return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                                children: [
                                    (0, _jsxruntime.jsx)("div", {
                                        role: "none",
                                        style: {
                                            height: spaceBefore
                                        }
                                    }),
                                    visibleGroups.map((optionGroup)=>{
                                        const isFirstItemVisible = optionGroup.slice[0] === 0;
                                        return (0, _jsxruntime.jsxs)(_react.Fragment, {
                                            children: [
                                                optionGroup.originalIndex > 0 && isFirstItemVisible && (0, _jsxruntime.jsx)("div", {
                                                    className: _base_selectcss.default.groupDivider,
                                                    children: (0, _jsxruntime.jsx)(_divider.Divider, {})
                                                }),
                                                (0, _jsxruntime.jsx)(OptionGroup, {
                                                    item: item,
                                                    menuId: id,
                                                    id: hasMultipleGroups ? undefined : id,
                                                    role: hasMultipleGroups ? 'group' : 'listbox',
                                                    ariaLabel: hasMultipleGroups ? optionGroup.label : ariaLabel,
                                                    ariaLabelledBy: hasMultipleGroups ? undefined : ariaLabelledBy,
                                                    activeItemRef: activeItemRef,
                                                    value: value,
                                                    optionIndexOffset: flatOptions.findIndex((o)=>o === optionGroup.options[0]),
                                                    activeIndex: activeIndex,
                                                    label: isFirstItemVisible ? optionGroup.label : undefined,
                                                    options: optionGroup.options,
                                                    isSelected: isSelected,
                                                    onItemClick: onItemClick,
                                                    onItemHover: onItemHover,
                                                    getLabel: getLabel
                                                })
                                            ]
                                        }, optionGroup.originalIndex);
                                    }),
                                    (0, _jsxruntime.jsx)("div", {
                                        role: "none",
                                        style: {
                                            height: spaceAfter
                                        }
                                    })
                                ]
                            });
                        }
                    })
                })
        })
    });
}
function WithHeaderAndFooter(props) {
    const { header, footer, children } = props;
    return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            header && (0, _jsxruntime.jsx)("header", {
                className: _base_selectcss.default.menuHeader,
                children: typeof header === 'string' ? (0, _jsxruntime.jsx)(_typography.Text, {
                    children: header
                }) : header
            }),
            children,
            footer && (0, _jsxruntime.jsx)("footer", {
                className: _base_selectcss.default.menuFooter,
                children: typeof footer === 'string' ? (0, _jsxruntime.jsx)(_typography.Text, {
                    children: footer
                }) : footer
            })
        ]
    });
}
function renderEmptyMenuContent() {
    return (0, _jsxruntime.jsx)(_box.Box, {
        padding: "3u",
        children: (0, _jsxruntime.jsx)(_typography.Text, {
            children: _base_selectmessages.BaseSelectMessages.defaultEmptyMessage()
        })
    });
}
const BaseSelectItem = _react.memo(BaseSelectItem_);
function BaseSelectItem_(props) {
    const { onItemClick, onItemHover, option, multiSelectable } = props;
    const onClick = _react.useCallback((event)=>{
        onItemClick === null || onItemClick === void 0 ? void 0 : onItemClick(option, event);
    }, [
        onItemClick,
        option
    ]);
    const onMouseEnter = _react.useCallback((event)=>{
        onItemHover === null || onItemHover === void 0 ? void 0 : onItemHover(option, event);
    }, [
        onItemHover,
        option
    ]);
    const OptionIcon = option.Icon && (0, _jsxruntime.jsx)(option.Icon, {
        size: "medium"
    });
    const SelectedIcon = !multiSelectable && props.selected ? (0, _jsxruntime.jsx)(_icon.CheckIcon, {
        size: "medium"
    }) : undefined;
    const CheckboxIcon = (0, _jsxruntime.jsx)(_checkbox.FakeCheckbox, {
        checked: props.selected,
        disabled: props.option.disabled
    });
    var _props_start, _props_start1;
    const start = multiSelectable ? (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            CheckboxIcon,
            (_props_start = props.start) !== null && _props_start !== void 0 ? _props_start : OptionIcon
        ]
    }) : (_props_start1 = props.start) !== null && _props_start1 !== void 0 ? _props_start1 : OptionIcon;
    var _props_end;
    const end = (_props_end = props.end) !== null && _props_end !== void 0 ? _props_end : SelectedIcon;
    var _props_children;
    const content = (_props_children = props.children) !== null && _props_children !== void 0 ? _props_children : props.option.description != null ? (0, _jsxruntime.jsxs)(_layout.Rows, {
        tagName: "span",
        spacing: "0",
        children: [
            (0, _jsxruntime.jsx)(_typography.Text, {
                tagName: "span",
                lineClamp: 1,
                tone: _typography.InheritColor,
                children: props.getLabel(props.option)
            }),
            (0, _jsxruntime.jsx)(_typography.Text, {
                tagName: "span",
                size: "small",
                tone: option.disabled ? _typography.InheritColor : 'tertiary',
                children: props.option.description
            })
        ]
    }) : props.getLabel(props.option);
    return (0, _jsxruntime.jsx)(_menu.MenuItem, {
        id: props.id,
        ariaSelected: props.selected,
        buttonRef: props.forwardedRef,
        tabIndex: -1,
        onClick: onClick,
        onMouseEnter: onMouseEnter,
        start: start,
        end: end,
        className: (0, _classnames.default)(props.className, {
            [_base_selectcss.default.active]: props.active,
            [_base_selectcss.default.disabled]: props.option.disabled
        }),
        disabled: props.option.disabled,
        children: content
    });
}
