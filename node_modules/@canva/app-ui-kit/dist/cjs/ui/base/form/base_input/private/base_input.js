"use strict"
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get BaseInput () {
        return BaseInput;
    },
    get useFocusState () {
        return useFocusState;
    },
    get useOnWrapperMouseDown () {
        return useOnWrapperMouseDown;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _exists = require('../../../../../base/exists');
const _preconditions = require('../../../../../base/preconditions');
const _classnames = _interop_require_default(require("classnames"));
const _mobx = require("mobx");
const _mobxreactlite = require("mobx-react-lite");
const _react = _interop_require_wildcard(require("react"));
const _access_mode_state = require('../../../a11y/access_mode_state/access_mode_state');
const _pointer_input_state = require('../../../a11y/pointer_input_state/pointer_input_state');
const _controllable_value = require('../../../controllable_value/controllable_value');
const _device_capabilities = require('../../../device_capabilities/device_capabilities');
const _input = require('../../internal/input');
const _icon = require('../../../icons/calendar/icon');
const _icon1 = require('../../../icons/credit_card_back/icon');
const _icon2 = require('../../../icons/credit_card_front/icon');
const _icon3 = require('../../../icons/envelope/icon');
const _icon4 = require('../../../icons/link/icon');
const _icon5 = require('../../../icons/location/icon');
const _icon6 = require('../../../icons/search/icon');
const _icon7 = require('../../../icons/user/icon');
const _layout = require('../../../layout/layout');
const _base_inputcss = _interop_require_default(require("./base_input.css"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function getLegacyIcon({ icon, iconClassName }, position) {
    return (icon === null || icon === void 0 ? void 0 : icon.align) === position && (0, _jsxruntime.jsx)(Icon, {
        ...icon,
        className: iconClassName
    });
}
function getDecoration(decoration) {
    const content = typeof decoration === 'function' ? decoration() : decoration;
    return content ? (0, _jsxruntime.jsx)("div", {
        className: _base_inputcss.default.decoration,
        children: _react.isValidElement(content) && content.type === _react.Fragment ? _react.Children.toArray(content.props.children).filter(_exists.exists).map(addLeadingSpace) : content
    }) : undefined;
}
function addLeadingSpace(child, index) {
    return index === 0 ? child : [
        (0, _jsxruntime.jsx)(_layout.Spacer, {
            size: "0.5u"
        }, index),
        child
    ];
}
function useFocusState() {
    const store = (0, _mobxreactlite.useLocalObservable)(()=>({
            isFocused: false,
            setFocused: (0, _mobx.action)((value)=>store.isFocused = value)
        }));
    return {
        isFocused: store.isFocused,
        isKeyboardMode: _access_mode_state.accessModeState.isKeyboardMode,
        setFocused: store.setFocused
    };
}
function useOnWrapperMouseDown() {
    const ref = _react.useRef(null);
    const onMouseDown = _react.useCallback((e)=>{
        var _ref_current;
        let el = e.target;
        while(el && el !== e.currentTarget){
            if (isInteractive(el)) return;
            el = el.parentElement;
        }
        e.stopPropagation();
        e.preventDefault();
        (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();
    }, []);
    return {
        ref,
        onMouseDown
    };
}
function isInteractive(el) {
    return el.tagName === 'A' || el.tagName === 'BUTTON' || el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.getAttribute('tabIndex') != null;
}
const BaseInput = (0, _mobxreactlite.observer)(_react.forwardRef(function BaseInput(props_, forwardedRef) {
    const { props, setPropOverrides } = (0, _input.usePropOverrides)(props_);
    const { blurOnEnterKeyDown, onChange: onChangeProp, onFocus: onFocusProp, onBlur: onBlurProp, onKeyDown: onKeyDownProp, onChangeComplete: onChangeCompleteProp } = props;
    const wrapperRef = _react.useRef(null);
    const { ref: inputRef, onMouseDown: onWrapperMouseDown } = useOnWrapperMouseDown();
    const { isFocused, isKeyboardMode, setFocused } = useFocusState();
    var _props_defaultValue;
    const [value, setValue] = (0, _controllable_value.useControllableValue)({
        value: props.value,
        defaultValue: (_props_defaultValue = props.defaultValue) !== null && _props_defaultValue !== void 0 ? _props_defaultValue : ''
    });
    var _props_start;
    const startDecoration = getDecoration((_props_start = props.start) !== null && _props_start !== void 0 ? _props_start : getLegacyIcon(props, 'start'));
    var _props_end;
    const endDecoration = getDecoration((_props_end = props.end) !== null && _props_end !== void 0 ? _props_end : getLegacyIcon(props, 'end'));
    const controls = (0, _input.useCreateInputControls)({
        focus: ()=>{
            var _inputRef_current;
            return (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();
        },
        setType: (type)=>setPropOverrides(type ? {
                type
            } : undefined),
        setDisabled: (disabled)=>setPropOverrides({
                disabled
            }),
        setValue: (value)=>{
            setValue(value);
            onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(value);
        }
    });
    const onChange = _react.useCallback((e)=>{
        setValue(e.target.value);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(e.target.value, e);
    }, [
        onChangeProp,
        setValue
    ]);
    const onFocus = _react.useCallback((e)=>{
        onFocusProp === null || onFocusProp === void 0 ? void 0 : onFocusProp(e);
        setFocused(true);
    }, [
        onFocusProp,
        setFocused
    ]);
    const onBlur = _react.useCallback((e)=>{
        onBlurProp === null || onBlurProp === void 0 ? void 0 : onBlurProp(e);
        onChangeCompleteProp === null || onChangeCompleteProp === void 0 ? void 0 : onChangeCompleteProp(e.target.value);
        setFocused(false);
    }, [
        onBlurProp,
        onChangeCompleteProp,
        setFocused
    ]);
    const onKeyDown = _react.useCallback((e)=>{
        var _wrapperRef_current;
        if (e.keyCode === 229) {
            e.stopPropagation();
            return;
        }
        if (e.key === 'Enter' && blurOnEnterKeyDown) (_wrapperRef_current = wrapperRef.current) === null || _wrapperRef_current === void 0 ? void 0 : _wrapperRef_current.focus();
        onKeyDownProp === null || onKeyDownProp === void 0 ? void 0 : onKeyDownProp(e);
        if (!blurOnEnterKeyDown && e.key === 'Enter')
            onChangeCompleteProp === null || onChangeCompleteProp === void 0 ? void 0 : onChangeCompleteProp(e.currentTarget.value);
    }, [
        onKeyDownProp,
        onChangeCompleteProp,
        blurOnEnterKeyDown,
        wrapperRef
    ]);
    const hoverSupported = (0, _pointer_input_state.useIsHoveringInput)();
    const wrapperClassName = (0, _classnames.default)(_base_inputcss.default.wrapper, _base_inputcss.default.singleLineWrapper, {
        [_base_inputcss.default.hoverSupported]: hoverSupported,
        [_base_inputcss.default.focusOutline]: isFocused && isKeyboardMode,
        [_base_inputcss.default.borderless]: props.borderless,
        [_base_inputcss.default.withStartDecoration]: startDecoration != null,
        [_base_inputcss.default.withEndDecoration]: endDecoration != null
    }, props.disabled && _base_inputcss.default.disabled || isFocused && _base_inputcss.default.active || props.error && _base_inputcss.default.error, props.className);
    const inputClassName = (0, _classnames.default)(_base_inputcss.default.textField, _base_inputcss.default.singleLineTextField, {
        [_base_inputcss.default.textAlignCenter]: props.textAlignCenter,
        [_base_inputcss.default.noAutocomplete]: props.autoComplete === 'off'
    }, props.inputClassName);
    return ((0, _jsxruntime.jsx)("div", {
            ref: wrapperRef,
            tabIndex: blurOnEnterKeyDown ? -1 : undefined,
            className: wrapperClassName,
            onMouseDown: onWrapperMouseDown,
            children: (0, _jsxruntime.jsxs)(_input.BaseInputContextProvider, {
                controls: controls,
                value: value,
                children: [
                    startDecoration,
                    (0, _jsxruntime.jsx)("input", {
                        id: props.id,
                        className: inputClassName,
                        value: value,
                        onChange: onChange,
                        onFocus: onFocus,
                        onBlur: onBlur,
                        onKeyDown: onKeyDown,
                        onClick: props.onClick,
                        onMouseDown: props.onMouseDown,
                        onMouseUp: props.onMouseUp,
                        onContextMenu: props.onContextMenu,
                        onPaste: props.onPaste,
                        onKeyUp: props.onKeyUp,
                        ref: (0, _composereactrefs.default)(inputRef, forwardedRef),
                        dir: "auto",
                        spellCheck: props.disableSpellcheck ? false : undefined,
                        type: props.type,
                        inputMode: props.inputMode,
                        autoCapitalize: props.autoCapitalize,
                        autoCorrect: props.autoCorrect,
                        pattern: props.pattern,
                        autoFocus: props.autoFocus === 'always' || props.autoFocus === 'on-desktop' && !(0, _device_capabilities.isVirtualKeyboard)(),
                        autoComplete: props.autoComplete,
                        disabled: props.disabled,
                        readOnly: props.readOnly,
                        maxLength: props.maxLength,
                        max: props.max,
                        min: props.min,
                        placeholder: props.placeholder,
                        step: props.step,
                        name: props.name,
                        role: props.role,
                        enterKeyHint: props.enterKeyHint,
                        "aria-roledescription": props.ariaRoleDescription,
                        "aria-required": props.required || undefined,
                        "aria-invalid": props.error || undefined,
                        "aria-label": props.ariaLabel,
                        "aria-labelledby": props.ariaLabelledBy,
                        "aria-describedby": props.ariaDescribedBy,
                        "aria-autocomplete": props.ariaAutoComplete,
                        "aria-activedescendant": props.ariaActiveDescendant,
                        "aria-controls": props.ariaControls,
                        "aria-expanded": props.ariaExpanded,
                        "aria-haspopup": props.ariaHasPopup,
                        "aria-valuenow": props.ariaValueNow,
                        "aria-valuetext": props.ariaValueText,
                        "aria-valuemin": props.ariaValueMin,
                        "aria-valuemax": props.ariaValueMax
                    }),
                    endDecoration
                ]
            })
        }));
}));
function Icon({ type, className }) {
    const props = {
        size: 'medium',
        tone: 'primary',
        className
    };
    switch(type){
        case 'credit-card':
            return (0, _jsxruntime.jsx)(_icon2.CreditCardFrontIcon, {
                ...props
            });
        case 'credit-card-expiry':
            return (0, _jsxruntime.jsx)(_icon.CalendarIcon, {
                ...props
            });
        case 'credit-card-verification':
            return (0, _jsxruntime.jsx)(_icon1.CreditCardBackIcon, {
                ...props
            });
        case 'email':
            return (0, _jsxruntime.jsx)(_icon3.EnvelopeIcon, {
                ...props
            });
        case 'link':
            return (0, _jsxruntime.jsx)(_icon4.LinkIcon, {
                ...props
            });
        case 'location':
            return (0, _jsxruntime.jsx)(_icon5.LocationIcon, {
                ...props
            });
        case 'person':
            return (0, _jsxruntime.jsx)(_icon7.UserIcon, {
                ...props
            });
        case 'search':
            return (0, _jsxruntime.jsx)(_icon6.SearchIcon, {
                ...props
            });
        default:
            throw new _preconditions.UnreachableError(type);
    }
}
