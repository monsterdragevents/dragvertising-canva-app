"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "BaseSlider", {
    enumerable: true,
    get: function() {
        return BaseSlider;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _reactmeasure = _interop_require_default(require("react-measure"));
const _behavior = require('../../../surface/sheet/behavior/behavior');
const _bar_snap_behavior = require("./bar_snap_behavior");
const _base_slidercss = _interop_require_wildcard(require("./base_slider.css"));
const _slidercss = _interop_require_wildcard(require("./slider.css"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
class BaseSlider extends _react.PureComponent {
    componentWillUnmount() {
        this.isDragging && this.onDragEnd();
    }
    render() {
        const { id, min, max, step, snap, value, disabled, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaValueText, trackColor, track = defaultTrack, fill = defaultFill, handle = defaultHandle } = this.props;
        return (0, _jsxruntime.jsx)(SheetScrollIsolation, {
            children: (isolationRef)=>(0, _jsxruntime.jsxs)("div", {
                    className: _base_slidercss.default.root,
                    ref: isolationRef,
                    children: [
                        (0, _jsxruntime.jsx)(_reactmeasure.default, {
                            offset: true,
                            onResize: this.onBarResize,
                            children: ({ measureRef })=>(0, _jsxruntime.jsxs)("div", {
                                    className: _base_slidercss.default.styledBarRoot,
                                    ref: measureRef,
                                    children: [
                                        track({
                                            color: trackColor,
                                            min,
                                            max,
                                            snap
                                        }),
                                        fill({
                                            disabled,
                                            trackWidth: this.state.width,
                                            startFill: this.fillCalculations.startFill,
                                            endFill: this.fillCalculations.endFill,
                                            color: this.fillCalculations.color
                                        }),
                                        (0, _jsxruntime.jsx)("div", {
                                            className: _base_slidercss.default.handlePositionerContainer,
                                            children: (0, _jsxruntime.jsx)("div", {
                                                className: _base_slidercss.default.handlePositioner,
                                                style: this.handlePositionerStyle,
                                                children: handle({
                                                    ...this.state,
                                                    disabled
                                                })
                                            })
                                        })
                                    ]
                                })
                        }),
                        (0, _jsxruntime.jsx)(_reactmeasure.default, {
                            bounds: true,
                            onResize: this.onResize,
                            children: ({ measureRef })=>(0, _jsxruntime.jsx)("input", {
                                    id: id,
                                    className: (0, _classnames.default)(_base_slidercss.default.hiddenSlider, {
                                        [_base_slidercss.default.disabled]: disabled
                                    }),
                                    ref: (0, _composereactrefs.default)(measureRef, this.inputRef),
                                    type: "range",
                                    onChange: this.onChange,
                                    onKeyDown: this.onKeyDown,
                                    onKeyUp: this.onKeyUp,
                                    onFocus: this.onFocus,
                                    onBlur: this.onBlur,
                                    onMouseEnter: this.onMouseEnter,
                                    onMouseMove: this.onMouseMove,
                                    onMouseLeave: this.onMouseLeave,
                                    onTouchStart: this.onTouchStart,
                                    onTouchEnd: this.onTouchEnd,
                                    onMouseDown: this.onMouseDown,
                                    min: min,
                                    max: max,
                                    step: step,
                                    value: value,
                                    disabled: disabled,
                                    "aria-label": ariaLabel,
                                    "aria-labelledby": ariaLabelledBy,
                                    "aria-describedby": ariaDescribedBy,
                                    "aria-valuetext": ariaValueText
                                })
                        })
                    ]
                })
        });
    }
    valueAsPercent(value) {
        const range = this.props.max - this.props.min;
        const valueFromMin = this.clamp(value) - this.props.min;
        const percent = valueFromMin / range * 100;
        return percent > 99.5 ? 100 : percent;
    }
    normalizeOrigin(origin) {
        const { min, max } = this.props;
        if (origin < min) return min;
        if (origin > max) return max;
        return origin;
    }
    get fillCalculations() {
        const { min, max, origin, snap, value, trackColor, fillColor } = this.props;
        const trackWidth = this.state.width;
        const startingPoint = origin != null ? this.normalizeOrigin(origin) : snap;
        const handleWidth = parseInt(_slidercss.default.handleDiameter, 10);
        const leftValue = startingPoint === undefined || startingPoint === min ? min : Math.min(startingPoint, value);
        const leftAsPercent = (leftValue - min) / (max - min) * 100;
        const startFill = leftAsPercent === 0 ? 0 : handleWidth / 2 + (trackWidth - handleWidth) * leftAsPercent / 100;
        const rightValue = startingPoint === max ? max : startingPoint === undefined ? value : Math.max(startingPoint, value);
        const rightAsPercent = (rightValue - min) / (max - min) * 100;
        const endFill = rightAsPercent === 100 ? trackWidth : handleWidth / 2 + (trackWidth - handleWidth) * rightAsPercent / 100;
        const color = fillColor !== undefined ? fillColor : trackColor !== undefined || value == null ? 'transparent' : undefined;
        return {
            startFill,
            endFill,
            color
        };
    }
    get handlePositionerPercent() {
        const { min, max, value } = this.props;
        const finalValue = value == null ? min + (max - min) / 2 : value;
        return this.valueAsPercent(finalValue);
    }
    get handlePositionerStyle() {
        const { min, max, origin, snap } = this.props;
        const startingPoint = origin != null ? this.normalizeOrigin(origin) : snap;
        const snapAsPercent = startingPoint != null ? (startingPoint - min) / (max - min) * 100 : undefined;
        if (snapAsPercent == null) return {
            width: `${this.handlePositionerPercent}%`
        };
        if (this.handlePositionerPercent >= snapAsPercent) return {
            width: `${this.handlePositionerPercent - snapAsPercent}%`,
            [_base_slidercss.customProperties.handlePositionerMargin]: `${snapAsPercent}%`
        };
        return {
            width: `${snapAsPercent - this.handlePositionerPercent}%`,
            [_base_slidercss.customProperties.handlePositionerMargin]: `${this.handlePositionerPercent}%`,
            transform: `scaleX(-1)`
        };
    }
    clamp(value) {
        return Math.min(Math.max(this.props.min, value), this.props.max);
    }
    constructor(props){
        super(props), this.inputRef = _react.createRef(), this.snapBehavior = this.props.snapBehavior || new _bar_snap_behavior.NeverSnap(), this.isDragging = false, this.keyPressed = false, this.onDragStart = (value)=>{
            var _this_props_onDragStart, _this_props;
            this.dragStartValue = this.clamp(value);
            this.isDragging = true;
            this.setState({
                active: true
            });
            (_this_props_onDragStart = (_this_props = this.props).onDragStart) === null || _this_props_onDragStart === void 0 ? void 0 : _this_props_onDragStart.call(_this_props);
        }, this.onDragEnd = (newValue)=>{
            var _this_inputRef_current, _this_props_onChangeComplete, _this_props, _this_props_onDragEnd, _this_props1;
            if (!this.isDragging) return;
            this.isDragging = false;
            this.setState({
                active: false
            });
            this.props.blurOnDragEnd && ((_this_inputRef_current = this.inputRef.current) === null || _this_inputRef_current === void 0 ? void 0 : _this_inputRef_current.blur());
            newValue != null && ((_this_props_onChangeComplete = (_this_props = this.props).onChangeComplete) === null || _this_props_onChangeComplete === void 0 ? void 0 : _this_props_onChangeComplete.call(_this_props, this.dragStartValue, newValue));
            (_this_props_onDragEnd = (_this_props1 = this.props).onDragEnd) === null || _this_props_onDragEnd === void 0 ? void 0 : _this_props_onDragEnd.call(_this_props1);
        }, this.onMouseUp = (event)=>{
            const target = event.target;
            target.removeEventListener('mouseup', this.onMouseUp);
            const value = this.clamp(parseFloat(target.value));
            this.onDragEnd(value);
        }, this.onMouseDown = (event)=>{
            const target = event.target;
            target.addEventListener('mouseup', this.onMouseUp, {
                once: true
            });
            const value = this.clamp(parseFloat(target.value));
            this.onDragStart(value);
        }, this.onTouchStart = (event)=>{
            if (event.touches.length > 1) return;
            const target = event.target;
            const value = this.clamp(parseFloat(target.value));
            this.onDragStart(value);
        }, this.onTouchEnd = (event)=>{
            if (event.touches.length > 0) return;
            const target = event.target;
            const value = this.clamp(parseFloat(target.value));
            this.onDragEnd(value);
        }, this.onResize = (contentRect)=>{
            if (contentRect.entry && contentRect.bounds) this.setState({
                leftBound: contentRect.bounds.left,
                width: contentRect.entry.width
            });
        }, this.onBarResize = (contentRect)=>{
            var _this_props_onBarResize, _this_props;
            if (contentRect.offset) (_this_props_onBarResize = (_this_props = this.props).onBarResize) === null || _this_props_onBarResize === void 0 ? void 0 : _this_props_onBarResize.call(_this_props, {
                width: contentRect.offset.width,
                start: contentRect.offset.left
            });
        }, this.onKeyDown = ()=>{
            this.keyPressed = true;
            this.snapBehavior.onKeyDown();
        }, this.onKeyUp = ()=>{
            this.keyPressed = false;
            this.snapBehavior.onKeyUp();
        }, this.onFocus = ()=>this.setState({
                focused: true
            }), this.onBlur = ()=>this.setState({
                focused: false
            }), this.onMouseEnter = ()=>this.setState({
                trackHovering: true
            }), this.onMouseMove = (e)=>{
            const handleWidth = parseInt(_slidercss.default.handleDiameter, 10);
            const trackWidth = this.state.width;
            const handleOverlayDiameter = parseInt(_slidercss.default.handleOverlayDiameter, 10);
            const mouseX = e.clientX - this.state.leftBound;
            const handleX = handleWidth / 2 + (trackWidth - handleWidth) * this.handlePositionerPercent / 100;
            if (mouseX >= handleX - handleOverlayDiameter / 2 && mouseX <= handleX + handleOverlayDiameter / 2) this.setState({
                handleHovering: true
            });
            else this.setState({
                handleHovering: false
            });
        }, this.onMouseLeave = ()=>this.setState({
                trackHovering: false,
                handleHovering: false
            }), this.onChange = (event)=>{
            var _this_props_onChangeComplete, _this_props;
            const newValue = this.clamp(parseFloat(event.target.value));
            const range = this.props.max - this.props.min;
            const pxPerUnit = this.state.width / range;
            this.snapBehavior.onChange(this.props, newValue, pxPerUnit);
            if (this.keyPressed) (_this_props_onChangeComplete = (_this_props = this.props).onChangeComplete) === null || _this_props_onChangeComplete === void 0 ? void 0 : _this_props_onChangeComplete.call(_this_props, this.props.value, newValue);
        };
        this.state = {
            active: false,
            focused: false,
            handleHovering: false,
            trackHovering: false,
            leftBound: 0,
            width: 0
        };
        this.dragStartValue = this.clamp(props.value);
    }
}
const defaultTrack = ({ min, max, snap, color })=>{
    const snapIndicatorBufferWidth = snap != null && `calc(${(snap - min) / (max - min) * 100}% - 0.5 * ${_slidercss.default.snapIndicatorSize})`;
    return (0, _jsxruntime.jsxs)("div", {
        className: _slidercss.default.track,
        children: [
            (0, _jsxruntime.jsx)("div", {
                className: _slidercss.default.trackFill,
                style: {
                    [_slidercss.customProperties.trackColor]: color
                }
            }),
            (0, _jsxruntime.jsx)("div", {
                className: _slidercss.default.startStopIndicator
            }),
            (0, _jsxruntime.jsx)("div", {
                className: _slidercss.default.endStopIndicator
            }),
            snapIndicatorBufferWidth && (0, _jsxruntime.jsxs)("div", {
                className: _slidercss.default.snapIndicatorContainer,
                children: [
                    (0, _jsxruntime.jsx)("div", {
                        className: _slidercss.default.snapIndicatorBuffer,
                        style: {
                            width: snapIndicatorBufferWidth
                        }
                    }),
                    (0, _jsxruntime.jsx)("div", {
                        className: _slidercss.default.snapIndicator
                    })
                ]
            })
        ]
    });
};
const defaultFill = ({ disabled, trackWidth, startFill, endFill, color })=>{
    return (0, _jsxruntime.jsx)("div", {
        className: (0, _classnames.default)(_slidercss.default.fill, {
            [_slidercss.default.disabled]: disabled
        }),
        style: {
            [_slidercss.customProperties.fillColor]: color,
            [_slidercss.customProperties.fillStart]: `${startFill}px`,
            [_slidercss.customProperties.fillEnd]: `${trackWidth - endFill}px`
        }
    });
};
const defaultHandle = ({ handleHovering, trackHovering, focused, disabled })=>{
    return (0, _jsxruntime.jsx)("div", {
        className: (0, _classnames.default)(_slidercss.default.handle, {
            [_slidercss.default.focused]: !disabled && focused,
            [_slidercss.default.handleHovering]: !disabled && handleHovering,
            [_slidercss.default.trackHovering]: !disabled && trackHovering,
            [_slidercss.default.disabled]: disabled
        })
    });
};
function SheetScrollIsolation(props) {
    const ref = (0, _behavior.useSheetScrollIsolation)();
    return props.children(ref);
}
