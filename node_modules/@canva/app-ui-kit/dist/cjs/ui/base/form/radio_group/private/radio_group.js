"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "RadioGroup", {
    enumerable: true,
    get: function() {
        return RadioGroup;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _react = _interop_require_wildcard(require("react"));
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _classnames = _interop_require_default(require("classnames"));
const _base_button = require('../../../button/base_button/base_button');
const _controllable_value = require('../../../controllable_value/controllable_value');
const _handle = require('../../../handle/handle');
const _key_combinations = require('../../../key_combinations/key_combinations');
const _layout = require('../../../layout/layout');
const _themecss = _interop_require_default(require('../../../theme/theme.css'));
const _typography = require('../../../typography/typography');
const _radio_groupcss = _interop_require_default(require("./radio_group.css"));
const _radio_item = require("./radio_item");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const RadioGroup = _react.forwardRef(RadioGroupImpl);
function RadioGroupImpl(props, ref) {
    const { value: valueProp, defaultValue: defaultValueProp, options, onChange: onChangeProp, disabled, id, ariaLabel, ariaLabelledBy, ariaDescribedBy, itemsPerRow, className, name, variant = 'default', onFocus, onBlur } = props;
    const radioGroupRef = _react.useRef(null);
    const currentFocusRef = _react.useRef(null);
    const radioGroupOrCurrentFocusRef = variant === 'button' ? radioGroupRef : currentFocusRef;
    _react.useImperativeHandle(ref, ()=>({
            ...(0, _handle.createLayoutHandle)(radioGroupRef),
            ...(0, _handle.createDOMElementHandle)(radioGroupRef),
            ...(0, _handle.createNodeHandle)(radioGroupRef),
            ...(0, _handle.createScrollHandle)(radioGroupRef),
            ...(0, _handle.createTraverseHandle)(radioGroupRef),
            ...(0, _handle.createFocusHandle)(radioGroupOrCurrentFocusRef)
        }));
    const [value, setValue] = (0, _controllable_value.useControllableValue)({
        value: valueProp,
        defaultValue: defaultValueProp
    });
    const onChange = _react.useCallback((value, e)=>{
        setValue(value);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(value, e);
    }, [
        onChangeProp,
        setValue
    ]);
    const onItemFocus = _react.useCallback((e)=>{
        var _radioGroupRef_current;
        const previouslyFocussedElement = e.relatedTarget;
        if (previouslyFocussedElement && (radioGroupRef === null || radioGroupRef === void 0 ? void 0 : (_radioGroupRef_current = radioGroupRef.current) === null || _radioGroupRef_current === void 0 ? void 0 : _radioGroupRef_current.contains(previouslyFocussedElement))) return;
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
    }, [
        onFocus
    ]);
    const onItemBlur = _react.useCallback((e)=>{
        var _radioGroupRef_current;
        const nextElementToBeFocussed = e.relatedTarget;
        if (nextElementToBeFocussed && (radioGroupRef === null || radioGroupRef === void 0 ? void 0 : (_radioGroupRef_current = radioGroupRef.current) === null || _radioGroupRef_current === void 0 ? void 0 : _radioGroupRef_current.contains(nextElementToBeFocussed))) return;
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
    }, [
        onBlur
    ]);
    if (variant === 'button') return (0, _jsxruntime.jsx)(ButtonRadioGroup, {
        options: options,
        value: value,
        onChange: onChange,
        className: className,
        disabled: disabled,
        id: id,
        ariaLabel: ariaLabel,
        ariaLabelledBy: ariaLabelledBy,
        ariaDescribedBy: ariaDescribedBy,
        itemsPerRow: itemsPerRow,
        ref: radioGroupRef,
        onFocus: onFocus && onItemFocus,
        onBlur: onBlur && onItemBlur
    });
    const radioGroup = (0, _jsxruntime.jsx)("div", {
        role: "radiogroup",
        id: id,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-describedby": ariaDescribedBy,
        ref: radioGroupRef,
        className: _radio_groupcss.default.radioGroup,
        children: options.map((option, index)=>{
            const hasFocusRef = value != null ? option.value === value : index === 0;
            var _option_disabled;
            return (0, _react.createElement)(_radio_item.RadioItem, {
                ...option,
                disabled: (_option_disabled = option.disabled) !== null && _option_disabled !== void 0 ? _option_disabled : disabled,
                checked: option.value === value,
                key: index,
                onChange: onChange,
                name: name,
                ref: hasFocusRef ? currentFocusRef : undefined,
                onFocus: onFocus && onItemFocus,
                onBlur: onBlur && onItemBlur
            });
        })
    });
    if (className) return (0, _jsxruntime.jsx)("div", {
        className: className,
        children: radioGroup
    });
    return radioGroup;
}
const ButtonItem = _react.memo(_react.forwardRef(
    ({ selected, disabled, label, description, onClick, tabbable, className, ariaLabel, onFocus, onBlur }, ref)=>{
        const descriptionId = _react.useId();
        return (0, _jsxruntime.jsx)(_base_button.BaseButton, {
            ref: ref,
            className: (0, _classnames.default)(_radio_groupcss.default.buttonItem, {
                [_radio_groupcss.default.buttonItemActive]: selected
            }, className),
            ariaLabel: ariaLabel,
            disabled: disabled,
            onClick: onClick,
            type: "button",
            role: "radio",
            selected: selected,
            tabIndex: selected || tabbable ? undefined : -1,
            onFocus: onFocus,
            onBlur: onBlur,
            ariaDescribedBy: description ? descriptionId : undefined,
            display: "block",
            borderRadius: "element",
            padding: "1u",
            backgroundColor: _themecss.default.colorSurface,
            children: (0, _jsxruntime.jsx)(ButtonItemLabel, {
                label: label,
                description: description,
                disabled: disabled,
                selected: selected,
                descriptionId: descriptionId
            })
        });
    }
));
function ButtonItemLabel({ label, description, disabled, selected, descriptionId }) {
    const labelElement = typeof label === 'string' ? (0, _jsxruntime.jsx)(_typography.Text, {
        tagName: "span",
        margins: "none",
        alignment: "center",
        tone: disabled ? 'tertiary' : 'primary',
        weight: selected ? 'bold' : 'regular',
        children: label
    }) : label;
    if (!description) return labelElement;
    return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
        children: [
            labelElement,
            (0, _jsxruntime.jsx)("div", {
                "aria-hidden": true,
                children: (0, _jsxruntime.jsx)(_typography.Text, {
                    id: descriptionId,
                    tagName: "span",
                    tone: "tertiary",
                    size: "small",
                    children: description
                })
            })
        ]
    });
}
const ButtonItemContainer = _react.forwardRef(function ButtonItemContainer(props, ref) {
    const { selected, option, onChange, disabled, tabbable, className, onFocus, onBlur } = props;
    const onClick = _react.useMemo(()=>{
        return (event)=>!selected && (onChange === null || onChange === void 0 ? void 0 : onChange(option.value, event));
    }, [
        selected,
        option,
        onChange
    ]);
    var _option_disabled;
    return (0, _jsxruntime.jsx)(ButtonItem, {
        ref: ref,
        ariaLabel: option.ariaLabel,
        selected: selected,
        disabled: (_option_disabled = option.disabled) !== null && _option_disabled !== void 0 ? _option_disabled : disabled,
        tabbable: tabbable,
        className: className,
        onClick: onClick,
        onFocus: onFocus,
        onBlur: onBlur,
        label: option.label,
        description: option.description
    });
});
const ButtonRadioGroup = _react.forwardRef(function(props, ref) {
    const { itemsPerRow, disabled, options, value, id, ariaLabel, ariaLabelledBy, ariaDescribedBy, className, onChange, onFocus, onBlur } = props;
    const shouldFocus = _react.useRef(false);
    const activeRef = _react.useRef(null);
    const divRef = _react.useRef(null);
    _react.useImperativeHandle(ref, ()=>({
            ...(0, _handle.createDOMElementHandle)(divRef),
            ...(0, _handle.createLayoutHandle)(divRef),
            ...(0, _handle.createNodeHandle)(divRef),
            ...(0, _handle.createScrollHandle)(divRef),
            ...(0, _handle.createTraverseHandle)(divRef),
            ...(0, _handle.createFocusHandle)(activeRef)
        }));
    _react.useEffect(()=>{
        var _activeRef_current;
        if (shouldFocus.current) (_activeRef_current = activeRef.current) === null || _activeRef_current === void 0 ? void 0 : _activeRef_current.focus();
    }, [
        shouldFocus,
        value
    ]);
    const availableOptions = options.filter((option)=>{
        return !option.disabled;
    });
    const firstAvailableOption = availableOptions[0];
    const moveSelection = (delta)=>{
        const currentIndex = availableOptions.findIndex((option)=>option.value === value);
        const newIndex = ((currentIndex > -1 ? currentIndex : 0) + availableOptions.length + delta) % availableOptions.length;
        shouldFocus.current = true;
        onChange === null || onChange === void 0 ? void 0 : onChange(availableOptions[newIndex].value);
    };
    const { ref: keyRef } = (0, _key_combinations.useKeyCombinationHandler)([
        [
            'ArrowUp',
            ()=>moveSelection(-1)
        ],
        [
            'ArrowDown',
            ()=>moveSelection(1)
        ],
        [
            'previous',
            ()=>moveSelection(-1)
        ],
        [
            'next',
            ()=>moveSelection(1)
        ]
    ], {
        handleInputs: true
    });
    return (0, _jsxruntime.jsx)("div", {
        ref: (0, _composereactrefs.default)(keyRef, divRef),
        className: className,
        role: "radiogroup",
        id: id,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-describedby": ariaDescribedBy,
        children: (0, _jsxruntime.jsx)(_layout.Grid, {
            spacing: "1u",
            columns: itemsPerRow || options.length,
            children: options.map((option, idx)=>{
                const tabbable = option === firstAvailableOption && value === undefined;
                const isCurrentItemSelected = option.value === value;
                const hasFocusRef = value != null ? isCurrentItemSelected : option === firstAvailableOption;
                const buttonItemContainerRef = hasFocusRef || isCurrentItemSelected ? activeRef : undefined;
                return (0, _jsxruntime.jsx)(ButtonItemContainer, {
                    disabled: disabled,
                    selected: isCurrentItemSelected,
                    option: option,
                    tabbable: tabbable,
                    className: option.className,
                    ref: buttonItemContainerRef,
                    onChange: onChange,
                    onFocus: onFocus,
                    onBlur: onBlur
                }, idx);
            })
        })
    });
});
