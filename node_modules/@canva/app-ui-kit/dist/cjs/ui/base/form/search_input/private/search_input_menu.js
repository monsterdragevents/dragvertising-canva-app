"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "SearchInputMenu", {
    enumerable: true,
    get: function() {
        return SearchInputMenu;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _clearable_input = require('../../clearable_input/clearable_input');
const _outside_pointerdown_handler = require('../../../outside_pointerdown_handler/outside_pointerdown_handler');
const _popover = require('../../../surface/popover/popover');
const _search_input_menucss = _interop_require_default(require("./search_input_menu.css"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const InternalSearchInputMenu = (props, ref)=>{
    const { children, detachContent = false, border, onOutsidePointerDown, end, className, error, type = 'search', usePopover = false, captureFocus, ...searchInputProps } = props;
    const hasContent = !!children;
    const withBordersSetInInput = usePopover || !hasContent || detachContent;
    const withShadow = border === 'faintShadow' || border === 'solid' && hasContent;
    const inputRef = _react.useRef(null);
    const outerRef = _react.useRef(null);
    _react.useImperativeHandle(ref, ()=>({
            focus: ()=>{
                var _inputRef_current;
                return (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();
            },
            blur: ()=>{
                var _inputRef_current;
                return (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.blur();
            }
        }));
    const handleOutsideInputInteraction = _react.useCallback(()=>{
        inputRef.current && inputRef.current.blur();
        onOutsidePointerDown && onOutsidePointerDown();
    }, [
        onOutsidePointerDown
    ]);
    const onTabOutside = _react.useCallback((event)=>{
        if (usePopover)
        return;
        if (event.key === 'Tab') setTimeout(()=>{
            var _outerRef_current;
            if (document.activeElement instanceof HTMLElement && !((_outerRef_current = outerRef.current) === null || _outerRef_current === void 0 ? void 0 : _outerRef_current.contains(document.activeElement))) handleOutsideInputInteraction();
        }, 5);
    }, [
        handleOutsideInputInteraction,
        usePopover
    ]);
    _react.useEffect(()=>{
        window.addEventListener('blur', handleOutsideInputInteraction);
        return ()=>window.removeEventListener('blur', handleOutsideInputInteraction);
    }, [
        handleOutsideInputInteraction
    ]);
    const input = (0, _jsxruntime.jsx)(_clearable_input.ClearableInput, {
        ref: inputRef,
        type: type,
        ...searchInputProps,
        borderless: border !== 'solid' || !withBordersSetInInput,
        error: withBordersSetInInput && error,
        inputClassName: _search_input_menucss.default.input,
        className: (0, _classnames.default)({
            [_search_input_menucss.default.inputContainerWithContent]: !withBordersSetInInput
        }),
        iconClassName: (0, _classnames.default)(searchInputProps.iconClassName, _search_input_menucss.default.icon),
        end: end
    });
    return (0, _jsxruntime.jsx)(_outside_pointerdown_handler.OutsidePointerDownHandler, {
        onOutsidePointerDown: handleOutsideInputInteraction,
        children: (0, _jsxruntime.jsx)("div", {
            className: (0, _classnames.default)(_search_input_menucss.default.searchInputMenu, className, {
                [_search_input_menucss.default.faintShadow]: withBordersSetInInput && withShadow
            }),
            ref: outerRef,
            onKeyDown: onTabOutside,
            children: usePopover ? (0, _jsxruntime.jsx)(_popover.Popover, {
                open: hasContent,
                onRequestClose: onOutsidePointerDown,
                reference: input,
                placement: "bottom-start",
                width: "reference",
                offset: "0",
                captureFocus: captureFocus,
                children: (0, _jsxruntime.jsx)("div", {
                    className: _search_input_menucss.default.content,
                    children: children
                })
            }) : (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                children: [
                    input,
                    hasContent && (0, _jsxruntime.jsx)("div", {
                        className: (0, _classnames.default)(_search_input_menucss.default.container, detachContent ? _search_input_menucss.default.detached : _search_input_menucss.default.attached, {
                            [_search_input_menucss.default.faintShadow]: withShadow,
                            [_search_input_menucss.default.solidBorder]: border === 'solid' && !hasContent,
                            [_search_input_menucss.default.error]: error
                        }),
                        children: (0, _jsxruntime.jsx)("div", {
                            className: _search_input_menucss.default.content,
                            children: children
                        })
                    })
                ]
            })
        })
    });
};
const SearchInputMenu = _react.forwardRef(InternalSearchInputMenu);
SearchInputMenu.displayName = 'SearchInputMenu';
