"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "SegmentedControl", {
    enumerable: true,
    get: function() {
        return SegmentedControl;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _classnames = _interop_require_default(require("classnames"));
const _mobxreactlite = require("mobx-react-lite");
const _react = _interop_require_wildcard(require("react"));
const _base_button = require('../../../button/base_button/base_button');
const _controllable_value = require('../../../controllable_value/controllable_value');
const _focusable = require('../../../focusable/focusable');
const _key_combinations = require('../../../key_combinations/key_combinations');
const _layout = require('../../../layout/layout');
const _typography = require('../../../typography/typography');
const _segmented_controlcss = _interop_require_wildcard(require("./segmented_control.css"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function SegmentedControl(props) {
    const { id: idProp, ariaLabel, ariaLabelledBy, ariaDescribedBy, disabled, options, value: valueProp, defaultValue, onChange: onChangeProp, focusRef: focusRefProp, onFocus: onFocusProp, onBlur: onBlurProp, borderless } = props;
    const [value, setValue] = (0, _controllable_value.useControllableValue)({
        value: valueProp,
        defaultValue
    });
    const fallbackId = _react.useId();
    const id = idProp !== null && idProp !== void 0 ? idProp : fallbackId;
    const focusRef = (0, _focusable.useFocusableRef)(focusRefProp);
    const containerRef = _react.useRef(null);
    const availableOptions = _react.useMemo(()=>{
        return options.filter((option)=>{
            return !option.disabled;
        });
    }, [
        options
    ]);
    const itemIds = options.map((option, itemIndex)=>`${id}--${itemIndex}`);
    const activeIndex = options.findIndex((option)=>option.value === value);
    const onChange = _react.useCallback((value)=>{
        setValue(value);
        onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(value);
    }, [
        onChangeProp,
        setValue
    ]);
    const onFocus = _react.useCallback((e)=>{
        var _containerRef_current;
        const previouslyFocussedElement = e.relatedTarget;
        if (previouslyFocussedElement && (containerRef === null || containerRef === void 0 ? void 0 : (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.contains(previouslyFocussedElement))) return;
        onFocusProp === null || onFocusProp === void 0 ? void 0 : onFocusProp(e);
    }, [
        onFocusProp
    ]);
    const onBlur = _react.useCallback((e)=>{
        var _containerRef_current;
        const nextElementToBeFocussed = e.relatedTarget;
        if (nextElementToBeFocussed && (containerRef === null || containerRef === void 0 ? void 0 : (_containerRef_current = containerRef.current) === null || _containerRef_current === void 0 ? void 0 : _containerRef_current.contains(nextElementToBeFocussed))) return;
        onBlurProp === null || onBlurProp === void 0 ? void 0 : onBlurProp(e);
    }, [
        onBlurProp
    ]);
    const moveSelection = _react.useCallback((delta)=>{
        const currentIndex = availableOptions.findIndex((option)=>option.value === value);
        const newIndex = ((currentIndex > -1 ? currentIndex : 0) + availableOptions.length + delta) % availableOptions.length;
        onChange(availableOptions[newIndex].value);
    }, [
        availableOptions,
        value,
        onChange
    ]);
    const { ref: keyRef } = (0, _key_combinations.useKeyCombinationHandler)([
        [
            'ArrowUp',
            ()=>moveSelection(-1)
        ],
        [
            'ArrowDown',
            ()=>moveSelection(1)
        ],
        [
            'previous',
            ()=>moveSelection(-1)
        ],
        [
            'next',
            ()=>moveSelection(1)
        ]
    ], {
        handleInputs: true
    });
    const style = {
        [_segmented_controlcss.customProperties.scIndex]: activeIndex,
        [_segmented_controlcss.customProperties.scOptions]: activeIndex === -1 ? 0 : options.length
    };
    return (0, _jsxruntime.jsx)("div", {
        ref: (0, _composereactrefs.default)(keyRef, focusRef, containerRef),
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-describedby": ariaDescribedBy,
        className: (0, _classnames.default)(_segmented_controlcss.default.segmentedControl, {
            [_segmented_controlcss.default.borderless]: borderless,
            [_segmented_controlcss.default.disabled]: disabled,
            [_segmented_controlcss.default.novalue]: activeIndex === -1
        }),
        style: style,
        id: id,
        role: "radiogroup",
        tabIndex: disabled ? -1 : 0,
        onFocus: onFocus,
        onBlur: onBlur,
        "aria-activedescendant": itemIds[activeIndex !== null && activeIndex !== void 0 ? activeIndex : -1],
        children: (0, _jsxruntime.jsx)(_layout.Grid, {
            spacing: "0.5u",
            columns: options.length,
            children: options.map((option, index)=>{
                var _option_disabled;
                return (0, _jsxruntime.jsx)(SegmentedControlItem, {
                    label: option.label,
                    active: option.value === value,
                    borderless: borderless,
                    disabled: (_option_disabled = option.disabled) !== null && _option_disabled !== void 0 ? _option_disabled : disabled,
                    onChange: onChange,
                    value: option.value,
                    ariaLabel: option.ariaLabel,
                    id: itemIds[index]
                }, index);
            })
        })
    });
}
function SegmentedControlItem(props) {
    const { active, ariaLabel, disabled, borderless, label, onChange, value, id } = props;
    return (0, _jsxruntime.jsx)(_mobxreactlite.Observer, {
        children: ()=>(0, _jsxruntime.jsx)(_base_button.BaseButton, {
                active: active,
                className: (0, _classnames.default)(_segmented_controlcss.default.buttonItem, {
                    [_segmented_controlcss.default.buttonItemActive]: active
                }),
                disabled: disabled,
                role: "radio",
                ariaLabel: ariaLabel,
                id: id,
                tabIndex: -1,
                onClick: ()=>!active && onChange(value),
                alignItems: "center",
                borderRadius: borderless ? 'element' : 'elementSmall',
                justifyContent: "center",
                selected: active,
                tone: "tertiary",
                backgroundColor: {
                    default: 'transparent',
                    hovered: active ? 'transparent' : undefined,
                    pressed: 'transparent',
                    disabled: 'transparent'
                },
                children: typeof label === 'string' ? (0, _jsxruntime.jsx)(_typography.Text, {
                    tagName: "span",
                    alignment: "center",
                    tone: _typography.InheritColor,
                    weight: active ? 'bold' : 'regular',
                    children: label
                }) : label
            })
    });
}
