"use strict"
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get DIVIDER_HEIGHT_MULTIPIER () {
        return DIVIDER_HEIGHT_MULTIPIER;
    },
    get ITEM_HEIGHT_MULTIPIER () {
        return ITEM_HEIGHT_MULTIPIER;
    },
    get Menu () {
        return Menu;
    },
    get MenuDivider () {
        return MenuDivider;
    },
    get MenuItem () {
        return MenuItem;
    },
    get MenuItemButton () {
        return MenuItemButton;
    },
    get TEXT_DIVIDER_HEIGHT_MULTIPIER () {
        return TEXT_DIVIDER_HEIGHT_MULTIPIER;
    },
    get ToggleMenu () {
        return ToggleMenu;
    },
    get renderDecorator () {
        return renderDecorator;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _preconditions = require('../../../../base/preconditions');
const _classnames = _interop_require_default(require("classnames"));
const _mobxreactlite = require("mobx-react-lite");
const _react = _interop_require_wildcard(require("react"));
const _access_mode_state = require('../../a11y/access_mode_state/access_mode_state');
const _box = require('../../box/box');
const _base_button = require('../../button/base_button/base_button');
const _button = require('../../button/button');
const _controllable_value = require('../../controllable_value/controllable_value');
const _divider = require('../../divider/divider');
const _icon = require('../../icons/chevron_down/icon');
const _icon1 = require('../../icons/chevron_right/icon');
const _layout = require('../../layout/layout');
const _truncated = require('../../typography/truncated/truncated');
const _typography = require('../../typography/typography');
const _menucss = _interop_require_wildcard(require("./menu.css"));
const _menumessages = require("./menu.messages");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const MenuContext = _react.createContext(undefined);
const ITEM_HEIGHT_MULTIPIER = 5;
const DIVIDER_HEIGHT_MULTIPIER = 2;
const TEXT_DIVIDER_HEIGHT_MULTIPIER = 4;
const getMenuSpaceStyle = (spacing, variant = 'regular', direction = 'vertical')=>{
    const menuSpace = spacing || (direction === 'horizontal' ? '1u' : variant === 'regular' ? '0' : '0.5u');
    switch(menuSpace){
        case '0.5u':
            return (0, _menucss.getStyle)('spacing050');
        case '1u':
            return (0, _menucss.getStyle)('spacing1');
        default:
            return;
    }
};
const Menu = _react.forwardRef(function Menu(props, ref) {
    const navigationRole = props.role === 'navigation';
    const [hasToggleMenu, setHasToggleMenu] = _react.useState(false);
    const menuClassName = (0, _classnames.default)(_menucss.default.menu, !navigationRole && props.className, getMenuSpaceStyle(props.spacing, props.variant, props.direction), {
        [_menucss.default.rounded]: props.variant === 'rounded',
        [_menucss.default.bleedX]: !!props.bleedX,
        [_menucss.default.horizontal]: props.role !== 'listbox' && props.direction === 'horizontal',
        [_menucss.default.hasToggleMenu]: hasToggleMenu
    });
    var _props_tagName;
    const content = (0, _jsxruntime.jsx)(_box.Box, {
        id: props.id,
        ariaActiveDescendant: props.ariaActiveDescendant,
        ariaMultiSelectable: props.ariaMultiSelectable,
        ariaLabel: props.ariaLabel,
        ariaLabelledBy: props.ariaLabelledBy,
        tagName: (_props_tagName = props.tagName) !== null && _props_tagName !== void 0 ? _props_tagName : 'ul',
        role: props.role === 'navigation' ? 'list' : props.role,
        ref: ref,
        className: menuClassName,
        children: props.children
    });
    const maybeWrappedContent = navigationRole ? (0, _jsxruntime.jsx)("nav", {
        className: navigationRole && props.className,
        children: content
    }) : content;
    const context = _react.useMemo(()=>({
            menuRole: props.role,
            menuDirection: props.role !== 'listbox' ? props.direction : undefined,
            menuVariant: props.variant,
            menuSpacing: props.spacing,
            registerToggleMenu: ()=>setHasToggleMenu(true)
        }), [
        props.role,
        props.direction,
        props.variant,
        props.spacing
    ]);
    return (0, _jsxruntime.jsx)(MenuContext.Provider, {
        value: context,
        children: maybeWrappedContent
    });
});
function getMenuItemRoles(menuRole) {
    switch(menuRole){
        case 'menu':
        case 'menubar':
            return {
                boxRole: 'none',
                buttonRole: 'menuitem'
            };
        case 'listbox':
        case 'group':
            return {
                boxRole: 'option',
                buttonRole: undefined
            };
        default:
            return {
                boxRole: undefined,
                buttonRole: undefined
            };
    }
}
const MenuItem = _react.memo(
    function MenuItem({ id, buttonId, children, className, active, selected, pressed, disabled, disclosure, draggable, onFocus, onBlur, onMouseEnter, onMouseLeave, tabIndex, start, end, label, description, lineClamp, buttonRef, tooltipLabel, tooltipDisabled, tooltipLineClamp, tooltipPlacement, tooltipShortcut, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaHasPopup, ariaControls, ariaSelected, ariaCurrent, href, target, onClick, onContextMenu }) {
        const context = _preconditions.Preconditions.checkExists(_react.useContext(MenuContext), 'MenuItem should not be used outside of a Menu');
        const { boxRole, buttonRole } = getMenuItemRoles(context.menuRole);
        return (0, _jsxruntime.jsx)(_box.Box, {
            tagName: "li",
            id: id,
            role: boxRole,
            className: _menucss.default.menuItem,
            ariaDisabled: disabled,
            ariaSelected: ariaSelected,
            children: (0, _jsxruntime.jsx)(MenuItemButton, {
                id: buttonId,
                role: buttonRole,
                tabIndex: tabIndex,
                buttonRef: buttonRef,
                className: className,
                href: href,
                target: target,
                onClick: onClick,
                start: start,
                end: end,
                label: label,
                description: description,
                lineClamp: lineClamp,
                alignment: context.menuDirection === 'horizontal' ? 'center' : 'start',
                active: active,
                selected: selected,
                pressed: pressed,
                disabled: disabled,
                disclosure: disclosure,
                draggable: draggable,
                onFocus: onFocus,
                onBlur: onBlur,
                onMouseEnter: onMouseEnter,
                onMouseLeave: onMouseLeave,
                onContextMenu: onContextMenu,
                tooltipLabel: tooltipLabel,
                tooltipDisabled: tooltipDisabled,
                tooltipLineClamp: tooltipLineClamp,
                tooltipPlacement: tooltipPlacement,
                tooltipShortcut: tooltipShortcut,
                ariaLabel: ariaLabel,
                ariaLabelledBy: ariaLabelledBy,
                ariaDescribedBy: ariaDescribedBy,
                ariaHasPopup: ariaHasPopup,
                ariaControls: ariaControls,
                ariaCurrent: ariaCurrent,
                children: children
            })
        });
    }
);
const Clickable = _react.forwardRef((props, ref)=>{
    return props.href ? (0, _jsxruntime.jsx)(_base_button.BaseAnchor, {
        ref: ref,
        ...props
    }) : (0, _jsxruntime.jsx)(_base_button.BaseButton, {
        ref: ref,
        ...props
    });
});
const MenuItemButton = (0, _mobxreactlite.observer)(function MenuItemButton({ id, role, alignment, children, className, active, selected, pressed, disabled, draggable, disclosure, onClick, onFocus, onBlur, onMouseEnter, onMouseLeave, onContextMenu, tabIndex, start, end, label, description, lineClamp, buttonRef, tooltipLabel: tooltipLabelProp, tooltipDisabled, tooltipLineClamp, tooltipPlacement, tooltipShortcut, ariaLabel, ariaLabelledBy, ariaDescribedBy, ariaHasPopup, ariaControls, ariaSelected, ariaCurrent, href, target }) {
    const childrenIsTextLike = typeof children === 'string' || typeof children === 'number';
    const textContent = label !== null && label !== void 0 ? label : childrenIsTextLike ? children.toString() : undefined;
    const { isTruncated, ref: isTruncatedRef } = (0, _truncated.useIsTruncated)(textContent);
    const tooltipLabel = tooltipLabelProp !== null && tooltipLabelProp !== void 0 ? tooltipLabelProp : isTruncated ? textContent : undefined;
    const hideOutline = _access_mode_state.accessModeState.isMouseMode;
    const labelId = _react.useId();
    const descriptionId = _react.useId();
    const buttonClassName = (0, _classnames.default)(_menucss.default.menuItemButton, {
        [_menucss.default.hideOutline]: hideOutline
    }, className);
    const contentNodes = [];
    if (children != null && !childrenIsTextLike) contentNodes.push(children);
    else {
        textContent !== undefined && contentNodes.push((0, _jsxruntime.jsx)(_typography.Text, {
            ref: textContent != null ? isTruncatedRef : undefined,
            id: label ? labelId : undefined,
            tagName: "span",
            tone: _typography.InheritColor,
            alignment: alignment,
            lineClamp: lineClamp,
            className: _menucss.default.menuItemButtonLabel,
            children: textContent
        }, contentNodes.length));
        label && description && contentNodes.push((0, _jsxruntime.jsx)(_typography.Text, {
            id: descriptionId,
            tagName: "span",
            size: "small",
            tone: "tertiary",
            alignment: alignment,
            children: description
        }, contentNodes.length));
    }
    const content = contentNodes.length > 1 ? (0, _jsxruntime.jsx)(_layout.Rows, {
        tagName: "span",
        spacing: "0",
        children: contentNodes
    }) : contentNodes;
    const setRef = _react.useCallback((handle)=>{
        if (buttonRef == null) return;
        var _handle_dangerouslyGetElement;
        const element = (_handle_dangerouslyGetElement = handle === null || handle === void 0 ? void 0 : handle.dangerouslyGetElement()) !== null && _handle_dangerouslyGetElement !== void 0 ? _handle_dangerouslyGetElement : null;
        if (typeof buttonRef === 'function') buttonRef(element);
        else buttonRef.current = element;
    }, [
        buttonRef
    ]);
    return (0, _jsxruntime.jsx)(Clickable, {
        id: id,
        role: role,
        tabIndex: tabIndex,
        ref: setRef,
        className: buttonClassName,
        active: active,
        selected: active !== null && active !== void 0 ? active : selected,
        pressed: pressed,
        disabled: disabled,
        draggable: draggable,
        disclosure: disclosure,
        onClick: onClick,
        onFocus: onFocus,
        onBlur: onBlur,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onContextMenu: onContextMenu,
        tooltipLabel: tooltipLabel,
        tooltipDisabled: tooltipDisabled,
        tooltipLineClamp: tooltipLineClamp,
        tooltipPlacement: tooltipPlacement,
        tooltipShortcut: tooltipShortcut,
        ariaLabel: ariaLabel,
        ariaLabelledBy: label ? labelId : ariaLabelledBy,
        ariaDescribedBy: description ? descriptionId : ariaDescribedBy,
        ariaHasPopup: ariaHasPopup,
        ariaControls: ariaControls,
        ariaCurrent: ariaCurrent,
        href: href,
        target: target,
        width: "full",
        alignItems: "center",
        tone: "tertiary",
        children: start || end ? (0, _jsxruntime.jsxs)(_layout.Columns, {
            tagName: "span",
            alignY: "center",
            spacing: "1u",
            children: [
                start ? renderDecorator(typeof start === 'function' ? start() : start) : null,
                (0, _jsxruntime.jsx)(_layout.Column, {
                    tagName: "span",
                    children: content
                }),
                end ? renderDecorator(typeof end === 'function' ? end() : end) : null
            ]
        }) : content
    });
});
const renderDecorator = (decorator)=>_react.isValidElement(decorator) && decorator.type === _react.Fragment ? (0, _jsxruntime.jsx)(_jsxruntime.Fragment, {
        children: _react.Children.map(decorator.props.children, (child)=>child && renderDecorator(child))
    }) : (0, _jsxruntime.jsx)(_layout.Column, {
        tagName: "span",
        width: "content",
        children: decorator
    });
const MenuDivider = _react.memo(function MenuDivider({ id, children }) {
    const context = _preconditions.Preconditions.checkExists(_react.useContext(MenuContext), 'MenuDivider should not be used outside of a Menu');
    const dividerDirection = context.menuDirection === 'horizontal' ? 'vertical' : 'horizontal';
    const showChildren = context.menuDirection !== 'horizontal' && children;
    return (0, _jsxruntime.jsxs)("li", {
        role: "none",
        id: id,
        children: [
            (0, _jsxruntime.jsx)("div", {
                className: _menucss.default.menuDivider,
                children: (0, _jsxruntime.jsx)(_divider.Divider, {
                    direction: dividerDirection
                })
            }),
            showChildren && (0, _jsxruntime.jsx)(_typography.Text, {
                size: "small",
                weight: "bold",
                tagName: "div",
                tone: "secondary",
                className: _menucss.default.menuDividerText,
                children: children
            })
        ]
    });
});
const ToggleMenu = _react.forwardRef(
    function ToggleMenu({ id, menuId: menuIdProp, labelId: labelIdProp, label, labelNode, disabled, draggable, start, end, active, selected, buttonRef, tooltipLabel, tooltipPlacement, href, onClick, onToggleClick, onContextMenu, toggleLabel, defaultExpanded, expanded: expandedProp, buttonClassName, ...props }, ref) {
        const [expanded, setExpanded] = (0, _controllable_value.useControllableValue)({
            value: expandedProp,
            defaultValue: defaultExpanded,
            onChange: onToggleClick
        });
        const toggleExpanded = _react.useCallback(()=>setExpanded(!expanded), [
            expanded,
            setExpanded
        ]);
        const context = _react.useContext(MenuContext);
        _react.useEffect(()=>{
            context === null || context === void 0 ? void 0 : context.registerToggleMenu();
        }, [
            context
        ]);
        const Icon = expanded ? _icon.ChevronDownIcon : _icon1.ChevronRightIcon;
        const generatedMenuId = _react.useId();
        const menuId = menuIdProp !== null && menuIdProp !== void 0 ? menuIdProp : generatedMenuId;
        const generatedLabelId = _react.useId();
        const labelId = labelIdProp !== null && labelIdProp !== void 0 ? labelIdProp : generatedLabelId;
        const toggleButtonProps = {
            onClick: toggleExpanded,
            disclosure: true,
            ariaControls: expanded ? menuId : undefined,
            open: expanded,
            disableActiveStyle: true
        };
        const showSeparateToggleButton = href || onClick;
        const menuItemClickProps = showSeparateToggleButton ? {
            href,
            onClick
        } : {
            ...toggleButtonProps
        };
        return (0, _jsxruntime.jsxs)(_box.Box, {
            ref: ref,
            tagName: context ? 'li' : 'div',
            id: id,
            className: _menucss.default.toggleMenuBox,
            children: [
                (0, _jsxruntime.jsx)(MenuItemButton, {
                    id: labelId,
                    className: buttonClassName,
                    active: active,
                    selected: selected,
                    disabled: disabled,
                    start: (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                        children: [
                            showSeparateToggleButton ? (0, _jsxruntime.jsx)(_layout.Spacer, {
                                size: "1u",
                                direction: "horizontal"
                            }) : (0, _jsxruntime.jsxs)(_box.Box, {
                                tagName: "span",
                                className: _menucss.default.toggleMenuIconBox,
                                children: [
                                    (0, _jsxruntime.jsx)(_layout.Spacer, {
                                        size: "1u",
                                        direction: "horizontal"
                                    }),
                                    (0, _jsxruntime.jsx)(Icon, {
                                        size: "small",
                                        className: _menucss.default.toggleMenuIcon
                                    })
                                ]
                            }),
                            typeof start === 'function' ? start() : start
                        ]
                    }),
                    end: end,
                    lineClamp: 1,
                    buttonRef: buttonRef,
                    onContextMenu: onContextMenu,
                    tooltipLabel: tooltipLabel,
                    tooltipPlacement: tooltipPlacement,
                    ariaLabel: labelNode ? label : undefined,
                    draggable: draggable,
                    ...menuItemClickProps,
                    children: labelNode || label
                }),
                showSeparateToggleButton && (0, _jsxruntime.jsx)(_button.Button, {
                    className: _menucss.default.toggleButton,
                    variant: "tertiary",
                    iconSize: "small",
                    icon: Icon,
                    ariaLabel: (toggleLabel !== null && toggleLabel !== void 0 ? toggleLabel : expanded) ? _menumessages.MenuMessages.collapseMenu(label) : _menumessages.MenuMessages.expandMenu(label),
                    disabled: disabled,
                    ...toggleButtonProps
                }),
                expanded && props.children && (0, _jsxruntime.jsx)(Menu, {
                    id: menuId,
                    ariaLabelledBy: labelId,
                    variant: context === null || context === void 0 ? void 0 : context.menuVariant,
                    spacing: context === null || context === void 0 ? void 0 : context.menuSpacing,
                    ...props
                })
            ]
        });
    }
);
