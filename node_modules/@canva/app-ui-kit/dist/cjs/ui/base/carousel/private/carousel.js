"use strict"
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get Carousel () {
        return Carousel;
    },
    get CarouselSkipLinks () {
        return CarouselSkipLinks;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _preconditions = require('../../../../base/preconditions');
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _identifier = require('../../a11y/identifier/identifier');
const _skip_link = require('../../a11y/skip_link/skip_link');
const _metrics = require('../../metrics/metrics');
const _scroll_controls = require('../../scroll_controls/scroll_controls');
const _scroll_window = require('../../scroll_controls/scroll_window');
const _carouselcss = _interop_require_default(require("./carousel.css"));
const _carouselmessages = require("./carousel.messages");
const _scroll_button = require("./scroll_button");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const Carousel = _react.memo(
    ({ name, children, scrollControlsRef, onScroll, expand = 'none', gutter = 'medium', snap = 'none', snapAlign = 'start', virtualization, scrollableRef: carouselScrollableRef, smoothScroll, skipLinksScrollMarginTop, disableSkipLinks = false, ...buttonProps })=>{
        const prevButtonRef = _react.useRef(null);
        const nextButtonRef = _react.useRef(null);
        const startLinkRef = _react.useRef(null);
        const endLinkRef = _react.useRef(null);
        const gutterSize = getGutterSize(gutter);
        const carouselClassName = (0, _classnames.default)(_carouselcss.default.carousel, {
            [_carouselcss.default.mandatory]: snap === 'mandatory',
            [_carouselcss.default.proximity]: snap === 'proximity'
        });
        const itemClassName = (0, _classnames.default)(getGutterClassName(gutter), _carouselcss.default.item, {
            [_carouselcss.default.snapItemInitial]: snapAlign === 'initial'
        });
        const itemWidthsWithGutter = _react.useMemo(()=>{
            if (!virtualization) return;
            const value = Array.isArray(virtualization.itemWidths) ? virtualization.itemWidths.map((width)=>width + gutterSize) : new Array(children.length).fill(virtualization.itemWidths + gutterSize);
            if (value.length > 0) value[value.length - 1] -= gutterSize;
            return value;
        }, [
            children.length,
            gutterSize,
            virtualization
        ]);
        return (0, _jsxruntime.jsx)(_scroll_controls.ScrollControls, {
            innerRef: carouselScrollableRef,
            ref: scrollControlsRef,
            itemWidths: itemWidthsWithGutter,
            smoothScroll: smoothScroll,
            onScroll: onScroll,
            children: ({ scrollableRef, movePrev, moveNext, scrollState })=>(0, _jsxruntime.jsx)("div", {
                    className: (0, _classnames.default)(_carouselcss.default.carouselContainer, {
                        [_carouselcss.default.expandSmall]: expand === 'small',
                        [_carouselcss.default.expandMedium]: expand === 'medium',
                        [_carouselcss.default.expandLarge]: expand === 'large'
                    }),
                    children: (0, _jsxruntime.jsx)(CarouselSkipLinks, {
                        carouselName: name,
                        disableSkipLinks: disableSkipLinks,
                        scrollMarginTop: skipLinksScrollMarginTop,
                        startLinkRef: startLinkRef,
                        endLinkRef: endLinkRef,
                        children: (0, _jsxruntime.jsx)(_identifier.WithIdentifiers, {
                            children: (id)=>(0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                                    children: [
                                        (0, _jsxruntime.jsx)(ScrollButton, {
                                            scrollableId: id,
                                            direction: "backward",
                                            onClick: movePrev,
                                            scrollState: scrollState,
                                            buttonRef: prevButtonRef,
                                            oppositeButtonRef: nextButtonRef,
                                            startLinkRef: startLinkRef,
                                            endLinkRef: endLinkRef,
                                            ...buttonProps
                                        }),
                                        virtualization ? (0, _jsxruntime.jsx)(VirtualizedChildren, {
                                            id: id,
                                            innerRef: scrollableRef,
                                            virtualization: virtualization,
                                            itemWidthsWithGutter: itemWidthsWithGutter,
                                            children: children,
                                            carouselClassName: carouselClassName,
                                            itemClassName: itemClassName,
                                            gutterSize: gutterSize,
                                            snap: snap
                                        }) : (0, _jsxruntime.jsx)("div", {
                                            ref: scrollableRef,
                                            id: id,
                                            className: carouselClassName,
                                            children: _react.Children.map(children.filter(Boolean), (child)=>(0, _jsxruntime.jsx)("div", {
                                                    className: itemClassName,
                                                    children: child
                                                }))
                                        }),
                                        (0, _jsxruntime.jsx)(ScrollButton, {
                                            scrollableId: id,
                                            direction: "forward",
                                            onClick: moveNext,
                                            scrollState: scrollState,
                                            buttonRef: nextButtonRef,
                                            oppositeButtonRef: prevButtonRef,
                                            startLinkRef: startLinkRef,
                                            endLinkRef: endLinkRef,
                                            ...buttonProps
                                        })
                                    ]
                                })
                        })
                    })
                })
        });
    }
);
const Spacer = _react.memo(({ width })=>(0, _jsxruntime.jsx)("span", {
        className: _carouselcss.default.spacer,
        style: {
            width
        }
    }));
const ScrollButton = _react.memo((props)=>{
    const { buttonVariant } = props;
    switch(buttonVariant){
        case 'none':
            return null;
        case 'chevron':
            return (0, _jsxruntime.jsx)(_scroll_button.ChevronScrollButton, {
                ...props,
                verticalOffsetPx: props.buttonsVerticalOffsetPx
            });
        case 'circular':
        case undefined:
            return (0, _jsxruntime.jsx)(_scroll_button.CircularScrollButton, {
                ...props,
                horizontalOffsetPx: props.buttonsHorizontalOffsetPx,
                verticalOffsetPx: props.buttonsVerticalOffsetPx
            });
        case 'custom':
            return (0, _jsxruntime.jsx)(props.ScrollButton, {
                ...props
            });
        default:
            throw new _preconditions.UnreachableError(buttonVariant);
    }
});
const CarouselSkipLinks = _react.memo(
    function CarouselSkipLinks({ carouselName, children, scrollMarginTop, disableSkipLinks, startLinkRef, endLinkRef }) {
        const idStart = _react.useId();
        const idEnd = _react.useId();
        if (disableSkipLinks) return children;
        return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
            children: [
                (0, _jsxruntime.jsx)(_skip_link.SkipTarget, {
                    id: idStart,
                    scrollMarginTop: scrollMarginTop,
                    label: carouselName ? _carouselmessages.CarouselMessages.namedListStart(carouselName) : _carouselmessages.CarouselMessages.listStart()
                }),
                (0, _jsxruntime.jsx)(_skip_link.SkipLink, {
                    to: idEnd,
                    position: "top",
                    ref: startLinkRef,
                    children: carouselName ? _carouselmessages.CarouselMessages.skipToNamedListEnd(carouselName) : _carouselmessages.CarouselMessages.skipToEnd()
                }),
                children,
                (0, _jsxruntime.jsx)(_skip_link.SkipLink, {
                    to: idStart,
                    position: "bottom",
                    ref: endLinkRef,
                    children: carouselName ? _carouselmessages.CarouselMessages.skipToNamedListStart(carouselName) : _carouselmessages.CarouselMessages.skipToStart()
                }),
                (0, _jsxruntime.jsx)(_skip_link.SkipTarget, {
                    id: idEnd,
                    scrollMarginTop: scrollMarginTop,
                    label: carouselName ? _carouselmessages.CarouselMessages.namedListEnd(carouselName) : _carouselmessages.CarouselMessages.listEnd()
                })
            ]
        });
    }
);
const getGutterSize = (gutter)=>{
    switch(gutter){
        case 'none':
            return 0;
        case 'small':
            return _metrics.baseUnit;
        case 'medium':
            return _metrics.baseUnit * 2;
        case 'large':
            return _metrics.baseUnit * 3;
        default:
            throw new _preconditions.UnreachableError(gutter);
    }
};
const getGutterClassName = (gutter)=>{
    switch(gutter){
        case 'none':
            return undefined;
        case 'small':
            return _carouselcss.default.gutterSmall;
        case 'medium':
            return _carouselcss.default.gutterMedium;
        case 'large':
            return _carouselcss.default.gutterLarge;
        default:
            throw new _preconditions.UnreachableError(gutter);
    }
};
const VirtualizedChildren = _react.memo(
    ({ id, innerRef, virtualization, itemWidthsWithGutter, children, carouselClassName, itemClassName, gutterSize, snap })=>(0, _jsxruntime.jsx)(_scroll_window.ScrollWindow, {
            innerRef: innerRef,
            layout: "horizontal",
            children: ({ scrollableRef, scrollState })=>(0, _jsxruntime.jsx)("div", {
                    ref: scrollableRef,
                    id: id,
                    className: carouselClassName,
                    children: (0, _jsxruntime.jsx)(_scroll_window.WindowedList, {
                        scrollState: scrollState,
                        itemSizes: itemWidthsWithGutter,
                        overscan: virtualization.overscan,
                        children: (windowedListState, itemPositions)=>{
                            var _virtualization_initialRender;
                            const { firstVisible, lastVisible } = windowedListState !== null && windowedListState !== void 0 ? windowedListState : {
                                firstVisible: 0,
                                lastVisible: Math.min((_virtualization_initialRender = virtualization.initialRender) !== null && _virtualization_initialRender !== void 0 ? _virtualization_initialRender : 1, itemPositions.length - 1)
                            };
                            if (snap !== 'none')
                            return _react.Children.map(children, (child, index)=>{
                                const width = Array.isArray(virtualization.itemWidths) ? virtualization.itemWidths[index] : virtualization.itemWidths;
                                return (0, _jsxruntime.jsx)("div", {
                                    className: itemClassName,
                                    children: firstVisible <= index && index < lastVisible ? child : (0, _jsxruntime.jsx)(Spacer, {
                                        width: width
                                    })
                                });
                            });
                            const spaceBefore = itemPositions[firstVisible];
                            let spaceAfter = itemPositions[itemPositions.length - 1] - itemPositions[lastVisible];
                            if (spaceAfter > 0)
                            spaceAfter += gutterSize;
                            return (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                                children: [
                                    (0, _jsxruntime.jsx)(Spacer, {
                                        width: spaceBefore
                                    }),
                                    _react.Children.map(children.slice(firstVisible, lastVisible), (child)=>(0, _jsxruntime.jsx)("div", {
                                            className: itemClassName,
                                            children: child
                                        })),
                                    (0, _jsxruntime.jsx)(Spacer, {
                                        width: spaceAfter
                                    })
                                ]
                            });
                        }
                    })
                })
        })
);
