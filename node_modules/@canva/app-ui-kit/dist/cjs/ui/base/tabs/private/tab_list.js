"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "TabList", {
    enumerable: true,
    get: function() {
        return TabList;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _classnames = _interop_require_default(require("classnames"));
const _mobxreactlite = require("mobx-react-lite");
const _react = require("react");
const _resizeobserverpolyfill = _interop_require_default(require("resize-observer-polyfill"));
const _button = require('../../button/button');
const _icon = require('../../icons/chevron_left/icon');
const _icon1 = require('../../icons/chevron_right/icon');
const _metrics = require('../../metrics/metrics');
const _provider = require('../../provider/provider');
const _scroll_controls = require('../../scroll_controls/scroll_controls');
const _behavior = require("./behavior");
const _tab_listcss = _interop_require_wildcard(require("./tab_list.css"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
function scrollIntoViewHorizontally(container, child) {
    const childOffsetRight = child.offsetLeft + child.offsetWidth;
    const containerScrollRight = container.scrollLeft + container.offsetWidth;
    container.scrollLeft += childOffsetRight - containerScrollRight + (container.offsetWidth - child.offsetWidth) / 2;
}
const useTabListUnderline = ({ activeElementRef, align, spacing, children })=>{
    const ref = (0, _react.useRef)(null);
    const layoutDirection = (0, _provider.useDirection)();
    const [underlineRect, setUnderlineRect] = (0, _react.useState)();
    const [containerWidthHasChanged, setContainerWidthHasChanged] = (0, _react.useState)(false);
    const prevContainerWidth = (0, _react.useRef)(0);
    const remeasure = (0, _react.useCallback)(()=>{
        if (activeElementRef && ref.current) {
            setUnderlineRect({
                x: (layoutDirection === 'RTL' ? activeElementRef.offsetLeft + activeElementRef.offsetWidth - ref.current.offsetWidth : activeElementRef.offsetLeft) + 'px',
                width: activeElementRef.offsetWidth + 'px'
            });
            setContainerWidthHasChanged(prevContainerWidth.current !== ref.current.offsetWidth);
            prevContainerWidth.current = ref.current.offsetWidth;
        }
    }, [activeElementRef, layoutDirection, children]);
    (0, _react.useLayoutEffect)(()=>{
        remeasure();
    }, [
        remeasure,
        spacing,
        align
    ]);
    (0, _react.useEffect)(()=>{
        if (ref.current) {
            const observer = new _resizeobserverpolyfill.default(remeasure);
            observer.observe(ref.current);
            return ()=>observer.disconnect();
        }
    }, [
        ref,
        remeasure
    ]);
    (0, _react.useEffect)(()=>{
        if (activeElementRef && ref.current) {
            scrollIntoViewHorizontally(ref.current, activeElementRef);
            const observer = new _resizeobserverpolyfill.default(remeasure);
            observer.observe(activeElementRef);
            return ()=>observer.disconnect();
        }
    }, [
        activeElementRef,
        remeasure,
        containerWidthHasChanged
    ]);
    return {
        ref,
        underlineRect,
        containerWidthHasChanged
    };
};
const ANIMATION_DURATION = parseInt(_tab_listcss.default.animationDuration, 10) || 0;
const TabListWithUnderline = ({ align, spacing, bleedX, animate, children, underline })=>{
    const { activeElementRef, setIsAnimating } = (0, _behavior.useTabsElements)();
    const { ref, role } = (0, _behavior.useTabList)();
    const { ref: underlineRef, underlineRect, containerWidthHasChanged } = useTabListUnderline({
        align,
        spacing,
        activeElementRef,
        children
    });
    const prevUnderlineRect = (0, _react.useRef)(underlineRect);
    const animationTimeoutRef = (0, _react.useRef)(0);
    (0, _react.useEffect)(()=>{
        if (!setIsAnimating || !underlineRect || !animate) return;
        const prevRect = prevUnderlineRect.current;
        const rectChanged = prevRect && (prevRect.x !== underlineRect.x || prevRect.width !== underlineRect.width);
        if (rectChanged) {
            setIsAnimating(true);
            clearTimeout(animationTimeoutRef.current);
            animationTimeoutRef.current = setTimeout(()=>{
                if (setIsAnimating) setIsAnimating(false);
            }, ANIMATION_DURATION);
        }
        prevUnderlineRect.current = underlineRect;
    }, [
        setIsAnimating,
        animate,
        underlineRect
    ]);
    return (0, _jsxruntime.jsx)(ScrollableOverflowContainer, {
        displayArrows: !!activeElementRef,
        spacing: spacing,
        bleedX: bleedX,
        children: (scrollableRef)=>(0, _jsxruntime.jsx)("div", {
                ref: (0, _composereactrefs.default)(ref, underlineRef, scrollableRef),
                role: role,
                className: (0, _classnames.default)(_tab_listcss.default.tablist, {
                    [_tab_listcss.default.animate]: animate && !containerWidthHasChanged,
                    [_tab_listcss.default.underline]: underline === 'visible' && underlineRect !== undefined,
                    [_tab_listcss.default.alignCenter]: align === 'center',
                    [_tab_listcss.default.alignEnd]: align === 'end',
                    [_tab_listcss.default.stretch]: align === 'stretch'
                }),
                style: {
                    [_tab_listcss.customProperties.underlineX]: underlineRect === null || underlineRect === void 0 ? void 0 : underlineRect.x,
                    [_tab_listcss.customProperties.underlineWidth]: underlineRect === null || underlineRect === void 0 ? void 0 : underlineRect.width,
                    [_tab_listcss.customProperties.spacing]: spacing ? (0, _metrics.getSpaceValue)(spacing) : undefined
                },
                children: children
            })
    });
};
const ScrollableOverflowContainer = (0, _react.memo)(({ displayArrows, spacing, bleedX, children })=>{
    let bleedXAmount = '0px';
    if (spacing === '0') bleedXAmount = '0px';
    else if (spacing === '1u') bleedXAmount = (0, _metrics.getSpaceValue)('0.5u');
    else bleedXAmount = (0, _metrics.getSpaceValue)('1u');
    return (0, _jsxruntime.jsx)(_scroll_controls.ScrollControls, {
        children: ({ scrollableRef, scrollState, moveNext, movePrev })=>(0, _jsxruntime.jsx)(_mobxreactlite.Observer, {
                children: ()=>(0, _jsxruntime.jsxs)("div", {
                        className: (0, _classnames.default)(_tab_listcss.default.scrollContainer, scrollState.atStart === false && _tab_listcss.default.prevScrollable, scrollState.atEnd === false && _tab_listcss.default.nextScrollable, bleedX && _tab_listcss.default.bleed),
                        style: {
                            [_tab_listcss.customProperties.bleedX]: bleedXAmount
                        },
                        children: [
                            children(scrollableRef),
                            displayArrows && (0, _jsxruntime.jsxs)(_jsxruntime.Fragment, {
                                children: [
                                    (0, _jsxruntime.jsx)(_button.BasicButton, {
                                        expandClickableArea: true,
                                        alignment: "start",
                                        ariaHidden: true,
                                        tabIndex: -1,
                                        size: "tiny",
                                        icon: _icon.ChevronLeftIcon,
                                        iconSize: "medium",
                                        onClick: movePrev,
                                        className: (0, _classnames.default)(_tab_listcss.default.scrollPrevButton, !scrollState.atStart && _tab_listcss.default.visible)
                                    }),
                                    (0, _jsxruntime.jsx)(_button.BasicButton, {
                                        expandClickableArea: true,
                                        alignment: "end",
                                        ariaHidden: true,
                                        tabIndex: -1,
                                        size: "tiny",
                                        icon: _icon1.ChevronRightIcon,
                                        iconSize: "medium",
                                        onClick: moveNext,
                                        className: (0, _classnames.default)(_tab_listcss.default.scrollNextButton, !scrollState.atEnd && _tab_listcss.default.visible)
                                    })
                                ]
                            })
                        ]
                    })
            })
    });
});
const TabList = ({ align = 'start', spacing = '2u', animate: animateProp = true, bleedX = true, underline = 'visible', children })=>{
    const animate = (0, _provider.useEnableAnimations)() && animateProp;
    return (0, _jsxruntime.jsx)(_behavior.TabsElementsProvider, {
        children: (0, _jsxruntime.jsx)(TabListWithUnderline, {
            align: align,
            spacing: align === 'stretch' ? '0' : spacing,
            animate: animate,
            bleedX: bleedX,
            underline: underline,
            children: children
        })
    });
};
