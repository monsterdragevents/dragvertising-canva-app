"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get useFocusableChildren () {
        return useFocusableChildren;
    },
    get useKeyboardFocusNavigation () {
        return useKeyboardFocusNavigation;
    }
});
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _react = require("react");
const _access_mode_state = require('../../a11y/access_mode_state/access_mode_state');
const _key_combinations = require('../../key_combinations/key_combinations');
const _behavior = require("./behavior");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const focusableElements = [
    'input:not([disabled]):not([type=hidden])',
    'select:not([disabled])',
    'textarea:not([disabled])',
    'button:not([disabled])',
    'a[href]',
    'area[href]',
    'summary',
    'iframe',
    'object',
    'embed',
    'audio[controls]',
    'video[controls]',
    '[contenteditable]'
];
const FOCUSABLE_ELEMENTS_SELECTOR = focusableElements.join(',');
function getFocusableChildren(element, onlyTabbables) {
    return Array.from(element.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR)).filter((el)=>el instanceof HTMLElement && !el.hidden && !el.ariaHidden && (onlyTabbables === true ? el.tabIndex >= 0 : true));
}
function useFocusableChildren(options) {
    const ref = (0, _react.useRef)(null);
    const [focusableChildren, setFocusableChildren] = (0, _react.useState)([]);
    const update = (0, _react.useCallback)(()=>{
        if (!ref.current) return;
        const focusables = getFocusableChildren(ref.current, options === null || options === void 0 ? void 0 : options.onlyTabbables);
        setFocusableChildren(focusables);
    }, [
        ref,
        options === null || options === void 0 ? void 0 : options.onlyTabbables
    ]);
    (0, _react.useLayoutEffect)(()=>{
        if (!(ref === null || ref === void 0 ? void 0 : ref.current)) return;
        update();
        const observer = new MutationObserver(update);
        observer.observe(ref.current, {
            subtree: true,
            childList: true,
            attributes: true,
            attributeFilter: [
                'tabIndex',
                'disabled'
            ]
        });
        return ()=>{
            observer.disconnect();
        };
    }, [
        update,
        ref
    ]);
    return {
        ref,
        focusableChildren
    };
}
function useKeyboardFocusNavigation() {
    const { ref: focusableChildrenRef, focusableChildren } = useFocusableChildren();
    const { activeElementRef } = (0, _behavior.useTabsElements)();
    (0, _react.useEffect)(()=>{
        const currentFocusedIndex = document.activeElement ? focusableChildren.findIndex((x)=>x === document.activeElement) : -1;
        if (currentFocusedIndex === -1 || !activeElementRef)
        return;
        const activeIndex = focusableChildren.findIndex((x)=>x === activeElementRef);
        if (currentFocusedIndex !== activeIndex)
        activeElementRef.focus();
    }, [
        activeElementRef,
        focusableChildren
    ]);
    const moveFocusTo = (0, _react.useCallback)((index)=>{
        _access_mode_state.accessModeState.setAccessMode('keyboard');
        const nextFocus = index < 0 ? focusableChildren[focusableChildren.length - 1] : focusableChildren[index];
        if (nextFocus) nextFocus.focus();
    }, [
        focusableChildren
    ]);
    const moveFocusBy = (0, _react.useCallback)((increment)=>{
        const focusedIndex = focusableChildren.findIndex((x)=>x === null || x === void 0 ? void 0 : x.matches(':focus'));
        const nextIndex = (focusedIndex + increment) % focusableChildren.length;
        moveFocusTo(nextIndex);
    }, [
        focusableChildren,
        moveFocusTo
    ]);
    const keyMap = (0, _react.useMemo)(()=>{
        return [
            [
                'next',
                (event)=>{
                    moveFocusBy(1);
                    event.preventDefault();
                }
            ],
            [
                'previous',
                (event)=>{
                    moveFocusBy(-1);
                    event.preventDefault();
                }
            ],
            [
                'Home',
                (event)=>{
                    moveFocusTo(0);
                    event.preventDefault();
                }
            ],
            [
                'End',
                (event)=>{
                    moveFocusTo(-1);
                    event.preventDefault();
                }
            ]
        ];
    }, [
        moveFocusTo,
        moveFocusBy
    ]);
    const { ref: keyCombinationHandlerRef } = (0, _key_combinations.useKeyCombinationHandler)(keyMap, {
        handleInputs: false
    });
    return {
        ref: (0, _composereactrefs.default)(keyCombinationHandlerRef, focusableChildrenRef)
    };
}
