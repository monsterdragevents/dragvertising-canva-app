"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get FlyoutMenuContext () {
        return FlyoutMenuContext;
    },
    get FlyoutMenuStore () {
        return FlyoutMenuStore;
    },
    get useFlyoutMenuAutoFocus () {
        return useFlyoutMenuAutoFocus;
    },
    get useFlyoutMenuContext () {
        return useFlyoutMenuContext;
    },
    get useFlyoutMenuHover () {
        return useFlyoutMenuHover;
    },
    get useFlyoutMenuKeyCombinations () {
        return useFlyoutMenuKeyCombinations;
    },
    get useFlyoutMenuKeyboardNavigation () {
        return useFlyoutMenuKeyboardNavigation;
    },
    get useFlyoutMenuStore () {
        return useFlyoutMenuStore;
    },
    get useNavigableRef () {
        return useNavigableRef;
    },
    get useNestedTriggerHover () {
        return useNestedTriggerHover;
    }
});
const _make_observable = require('../../../../base/make_observable/make_observable');
const _mobx = require("mobx");
const _react = _interop_require_wildcard(require("react"));
const _use_keyboard_navigation = require('../../a11y/keyboard_navigation/use_keyboard_navigation');
const _handle = require('../../handle/handle');
const _key_combinations = require('../../key_combinations/key_combinations');
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const FlyoutMenuContext = _react.createContext(null);
class FlyoutMenuStore {
    static _makeObservable(instance) {
        (0, _make_observable.makeObservable)(instance, {
            open: _mobx.observable.ref,
            closeCurrentlyOpenMenu: _mobx.observable.ref,
            currentlyOpenMenu: _mobx.observable.ref,
            parentStore: _mobx.observable.ref
        });
    }
    constructor(){
        this.open = (FlyoutMenuStore._makeObservable(this), false);
        this.itemRefs = new SortedSet(byDocumentPosition);
        this.currentlyOpenMenu = null;
        this.parentStore = null;
    }
}
function useFlyoutMenuStore() {
    return _react.useContext(FlyoutMenuContext);
}
function useFlyoutMenuContext(store) {
    return {
        store: _react.useMemo(()=>store !== null && store !== void 0 ? store : new FlyoutMenuStore(), [
            store
        ]),
        Provider: FlyoutMenuContext.Provider
    };
}
function useNavigableRef({ disabled } = {}) {
    const flyoutMenuStore = useFlyoutMenuStore();
    const ref = _react.useRef(null);
    const setRef = _react.useCallback((el)=>{
        if ((flyoutMenuStore === null || flyoutMenuStore === void 0 ? void 0 : flyoutMenuStore.itemRefs) == null) return;
        const { itemRefs } = flyoutMenuStore;
        if (ref.current && ref.current !== el) itemRefs.delete(ref.current);
        if (disabled) return;
        if (el && ref.current !== el) itemRefs.add(el);
        ref.current = el;
    }, [
        ref,
        disabled,
        flyoutMenuStore
    ]);
    return setRef;
}
function useFlyoutMenuKeyboardNavigation({ store, onExit }) {
    return (0, _use_keyboard_navigation.useKeyboardNavigation)(store.itemRefs.size, {
        mode: 'cycle',
        handleInputs: true,
        onChange: _react.useCallback((index)=>{
            var _store_closeCurrentlyOpenMenu;
            const it = store === null || store === void 0 ? void 0 : store.itemRefs.values();
            let ref;
            for(let i = 0; i <= index; i++)ref = it === null || it === void 0 ? void 0 : it.next().value;
            ref === null || ref === void 0 ? void 0 : ref.focus();
            (_store_closeCurrentlyOpenMenu = store.closeCurrentlyOpenMenu) === null || _store_closeCurrentlyOpenMenu === void 0 ? void 0 : _store_closeCurrentlyOpenMenu.call(store);
        }, [
            store
        ]),
        onExit
    });
}
function useFlyoutMenuAutoFocus(open) {
    const ref = _react.useRef(null);
    const prevOpen = _react.useRef(open);
    _react.useEffect(()=>{
        if (open) {
            prevOpen.current = open;
            return;
        }
        if (prevOpen.current && !open) {
            prevOpen.current = open;
            setTimeout(()=>{
                var _ref_current;
                return (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();
            }, 0);
        }
    }, [
        open
    ]);
    return {
        ref
    };
}
function useFlyoutMenuKeyCombinations({ isNested, isControlled, open, close, moveToFirst, moveToLast }) {
    const [isFocusingItem, setIsFocusingItem] = _react.useState(null);
    const triggerKeyCombinationMap = _react.useMemo(()=>{
        const common = [
            [
                'Enter',
                (e)=>{
                    if (!isControlled) {
                        e.preventDefault();
                        open();
                    }
                    setIsFocusingItem('first');
                }
            ],
            [
                ' ',
                (e)=>{
                    if (!isControlled) {
                        e.preventDefault();
                        open();
                    }
                    setIsFocusingItem('first');
                }
            ]
        ];
        if (isNested) return [
            ...common,
            [
                'next',
                (e)=>{
                    e.preventDefault();
                    if (!isControlled) open();
                    setIsFocusingItem('first');
                }
            ]
        ];
        return [
            ...common,
            [
                'ArrowUp',
                (e)=>{
                    e.preventDefault();
                    if (!isControlled) open();
                    setIsFocusingItem('last');
                }
            ],
            [
                'ArrowDown',
                (e)=>{
                    e.preventDefault();
                    if (!isControlled) open();
                    setIsFocusingItem('first');
                }
            ],
            [
                'Escape',
                ()=>{
                    if (!isControlled) close();
                }
            ],
            [
                'Tab',
                ()=>{
                    if (!isControlled) close();
                }
            ],
            [
                (0, _key_combinations.shift)('Tab'),
                ()=>{
                    if (!isControlled) close();
                }
            ]
        ];
    }, [
        setIsFocusingItem,
        isNested,
        isControlled,
        open,
        close
    ]);
    const { ref: triggerRef } = (0, _key_combinations.useKeyCombinationHandler)(triggerKeyCombinationMap, {
        handleInputs: false
    });
    const menuKeyCombinationMap = _react.useMemo(()=>{
        if (!isNested) return [];
        return [
            [
                'previous',
                (e)=>{
                    e.preventDefault();
                    e.stopPropagation();
                    close();
                }
            ]
        ];
    }, [
        isNested,
        close
    ]);
    const { ref: menuRef, element: menuContainerElement } = (0, _key_combinations.useKeyCombinationHandler)(menuKeyCombinationMap, {
        handleInputs: false
    });
    _react.useEffect(()=>{
        if (menuContainerElement) {
            if (isFocusingItem === 'first') moveToFirst();
            else if (isFocusingItem === 'last') moveToLast();
            setIsFocusingItem(null);
        }
    }, [
        isFocusingItem,
        setIsFocusingItem,
        menuContainerElement,
        moveToFirst,
        moveToLast
    ]);
    return {
        triggerRef,
        menuRef
    };
}
function useFlyoutMenuHover({ store, isOpen, close }) {
    const origin = _react.useRef(null);
    const ref = _react.useCallback((el)=>{
        if (store.parentStore) {
            store.parentStore.closeCurrentlyOpenMenu = el ? close : undefined;
            store.parentStore.currentlyOpenMenu = el;
        }
        el === null || el === void 0 ? void 0 : el.addEventListener('mousemove', (e)=>{
            var _store_currentlyOpenMenu;
            const menuBounds = (_store_currentlyOpenMenu = store.currentlyOpenMenu) === null || _store_currentlyOpenMenu === void 0 ? void 0 : _store_currentlyOpenMenu.getBoundingClientRect();
            const position = {
                x: e.clientX,
                y: e.clientY
            };
            if (menuBounds && origin.current && !isMovingTowards(menuBounds, origin.current, position)) {
                var _store_closeCurrentlyOpenMenu;
                (_store_closeCurrentlyOpenMenu = store.closeCurrentlyOpenMenu) === null || _store_closeCurrentlyOpenMenu === void 0 ? void 0 : _store_closeCurrentlyOpenMenu.call(store);
                origin.current = null;
            } else
                origin.current = position;
        });
    }, [
        store,
        close
    ]);
    return {
        ref
    };
}
function useNestedTriggerHover({ isOpen }) {
    const isOpenRef = _react.useRef(undefined);
    isOpenRef.current = isOpen;
    const ref = _react.useCallback((handle)=>{
        var _dangerouslyGetHTMLElement;
        (_dangerouslyGetHTMLElement = (0, _handle.dangerouslyGetHTMLElement)(handle)) === null || _dangerouslyGetHTMLElement === void 0 ? void 0 : _dangerouslyGetHTMLElement.addEventListener('mousemove', (e)=>{
            isOpenRef.current && e.stopPropagation();
        });
    }, []);
    return {
        ref
    };
}
class SortedSet extends Set {
    add(value) {
        super.add(value);
        this.sort();
        return this;
    }
    delete(value) {
        const success = super.delete(value);
        this.sort();
        return success;
    }
    sort() {
        const elements = [
            ...this
        ];
        this.clear();
        elements.sort(this.comparator).forEach(super.add, this);
    }
    constructor(comparator){
        super(), this.comparator = comparator;
    }
}
function byDocumentPosition(a, b) {
    var _aElement_compareDocumentPosition;
    const aElement = (0, _handle.dangerouslyGetHTMLElement)(a);
    const bElement = (0, _handle.dangerouslyGetHTMLElement)(b);
    if (!(aElement === null || aElement === void 0 ? void 0 : aElement.isConnected) || !(bElement === null || bElement === void 0 ? void 0 : bElement.isConnected)) return 0;
    return bElement && ((_aElement_compareDocumentPosition = aElement.compareDocumentPosition) === null || _aElement_compareDocumentPosition === void 0 ? void 0 : _aElement_compareDocumentPosition.call(aElement, bElement)) & Node.DOCUMENT_POSITION_PRECEDING ? 1 : -1;
}
function isMovingTowards(bounds, origin, current) {
    const vA = {
        x: bounds.left - origin.x,
        y: bounds.top - origin.y
    };
    const vC = {
        x: bounds.left - origin.x,
        y: bounds.bottom - origin.y
    };
    const vB = {
        x: current.x - origin.x,
        y: current.y - origin.y
    };
    return isBetween(vB, vA, vC);
}
function isBetween(b, a, c) {
    return crossProduct(a, b) * crossProduct(a, c) >= 0 && crossProduct(c, b) * crossProduct(c, a) >= 0;
}
function crossProduct(a, b) {
    return a.y * b.x - a.x * b.y;
}
