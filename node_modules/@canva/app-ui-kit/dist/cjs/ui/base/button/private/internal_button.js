"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get AnchorInner () {
        return AnchorInner;
    },
    get AnchorWithTooltip () {
        return AnchorWithTooltip;
    },
    get ButtonInner () {
        return ButtonInner;
    },
    get CircleButtonWithLabel () {
        return CircleButtonWithLabel;
    },
    get CircleButtonWithoutLabel () {
        return CircleButtonWithoutLabel;
    },
    get InternalAnchor () {
        return InternalAnchor;
    },
    get InternalButton () {
        return InternalButton;
    },
    get renderButtonOrAnchor () {
        return renderButtonOrAnchor;
    },
    get useShouldDisableSubmit () {
        return useShouldDisableSubmit;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _composereactrefs = _interop_require_default(require("@seznam/compose-react-refs"));
const _classnames = _interop_require_default(require("classnames"));
const _mobxreactlite = require("mobx-react-lite");
const _react = _interop_require_wildcard(require("react"));
const _access_mode_state = require('../../a11y/access_mode_state/access_mode_state');
const _button_aria_attributes = require('../../a11y/button_aria_attributes/button_aria_attributes');
const _pointer_input_state = require('../../a11y/pointer_input_state/pointer_input_state');
const _screen_reader_content = require('../../a11y/screen_reader_content/screen_reader_content');
const _handle = require('../../handle/handle');
const _skip_render_on_client = require('../../hydration/skip_render_on_client');
const _icon = require('../../icons/animated_spinner/icon');
const _provider = require('../../provider/provider');
const _tooltip = require('../../tooltip/tooltip');
const _truncated = require('../../typography/truncated/truncated');
const _typography = require('../../typography/typography');
const _buttoncss = _interop_require_wildcard(require("./button.css"));
const _buttonmessages = require("./button.messages");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const getButtonContent = (props)=>{
    const { children, iconPosition = 'start', noChildWrapper, icon: Icon, LoadingIcon = _icon.AnimatedSpinnerIcon, isTruncatedRef } = props;
    const content = [];
    let displayIcon = null;
    const hiddenAttrs = {
        ['aria-hidden']: props.loading || undefined
    };
    if (Icon) displayIcon = (0, _jsxruntime.jsx)("span", {
        className: _buttoncss.default.iconWrapper,
        ...hiddenAttrs,
        children: (0, _jsxruntime.jsx)(Icon, {
            size: props.iconSize || 'medium'
        })
    }, "icon");
    if (iconPosition === 'start' || iconPosition === 'top') content.push(displayIcon);
    if (children) content.push(noChildWrapper ? children : (0, _jsxruntime.jsx)("span", {
        className: _buttoncss.default.text,
        ref: isTruncatedRef,
        ...hiddenAttrs,
        children: children
    }, "content"));
    if (iconPosition === 'end') content.push(displayIcon);
    if (props.loading) {
        const loadingIconSize = props.iconSize || 'medium';
        content.push((0, _jsxruntime.jsxs)("span", {
            className: _buttoncss.default.loadingIconWrapper,
            children: [
                (0, _jsxruntime.jsx)(LoadingIcon, {
                    size: loadingIconSize
                }),
                (0, _jsxruntime.jsx)(_screen_reader_content.ScreenReaderContent, {
                    ariaLive: "assertive",
                    children: props.loadingMessage || _buttonmessages.ButtonMessages.loading()
                })
            ]
        }, "loading"));
    }
    return content;
};
const useClassName = (isAnchor, { children, alignment = 'center', active, selected, pressed, disableActiveStyle, disclosure, loading, disabled, stretch, variant, hideOutline, iconPosition, shape, size, expandClickableArea, icon, iconSize })=>{
    const trueSize = getSize({
        children,
        iconSize,
        size,
        variant
    });
    const squareSizing = allowSquareSizing({
        children,
        variant,
        stretch,
        icon
    });
    const iconOnly = icon != null && !children;
    return (0, _classnames.default)(_buttoncss.default.base, {
        [_buttoncss.default.anchor]: isAnchor,
        [_buttoncss.default.button]: variant !== 'basic',
        [_buttoncss.default.hideOutline]: hideOutline,
        [_buttoncss.default.topIcon]: iconPosition === 'top',
        [_buttoncss.default.startIcon]: !iconOnly && icon && (!iconPosition || iconPosition === 'start'),
        [_buttoncss.default.endIcon]: !iconOnly && icon && iconPosition === 'end',
        [_buttoncss.default.noMinWidth]: squareSizing,
        [_buttoncss.default.circleShape]: shape === 'circle',
        [_buttoncss.default.expandClickableArea]: expandClickableArea
    }, (0, _buttoncss.getStyle)(variant), !disableActiveStyle && getStateStyle({
        active,
        disclosure,
        selected,
        pressed
    }), trueSize && (0, _buttoncss.getStyle)(trueSize), {
        [_buttoncss.default.stretch]: stretch,
        [_buttoncss.default.loading]: loading,
        [_buttoncss.default.disabled]: disabled,
        [_buttoncss.default.startAlign]: alignment === 'start',
        [_buttoncss.default.centerAlign]: iconOnly || alignment === 'center',
        [_buttoncss.default.endAlign]: alignment === 'end',
        [_buttoncss.default.hoverSupported]: (0, _pointer_input_state.useIsHoveringInput)(),
        [_buttoncss.default.animate]: (0, _provider.useEnableAnimations)(),
        [_buttoncss.default.tinyWidth]: trueSize === 'tiny' && squareSizing,
        [_buttoncss.default.xsmallWidth]: trueSize === 'xsmall' && squareSizing,
        [_buttoncss.default.smallWidth]: trueSize === 'small' && squareSizing,
        [_buttoncss.default.mediumWidth]: trueSize === 'medium' && squareSizing,
        [_buttoncss.default.largeWidth]: trueSize === 'large' && squareSizing
    });
};
function getStateStyle(props) {
    var _props_selected;
    const selected = (_props_selected = props.selected) !== null && _props_selected !== void 0 ? _props_selected : props.disclosure ? undefined : props.active;
    var _props_pressed;
    const pressed = (_props_pressed = props.pressed) !== null && _props_pressed !== void 0 ? _props_pressed : props.disclosure ? props.active : undefined;
    return {
        [_buttoncss.default.selected]: selected,
        [_buttoncss.default.activeDisclosure]: pressed
    };
}
const useShouldDisableSubmit = (initialShouldDisableSubmit)=>{
    const [disableSubmit, setDisableSubmit] = _react.useState(initialShouldDisableSubmit);
    _react.useLayoutEffect(()=>{
        setDisableSubmit(false);
    }, []);
    return disableSubmit;
};
const ButtonInner = (0, _mobxreactlite.observer)(_react.forwardRef(function ButtonInner(props, ref) {
    const buttonRef = _react.useRef(null);
    _react.useImperativeHandle(ref, ()=>(0, _handle.createBasicHTMLHandle)(buttonRef), [
        buttonRef
    ]);
    const composedRef = (0, _composereactrefs.default)(buttonRef, props.buttonRef, ref);
    const isSubmitButton = props.type === 'submit';
    const disabledAttribute = useShouldDisableSubmit(isSubmitButton);
    const disabledStyle = disabledAttribute || props.disabled;
    const disabled = disabledAttribute || props.disabled || props.loading;
    const className = useClassName(false, {
        ...props,
        hideOutline: _access_mode_state.accessModeState.isMouseMode,
        disabled: disabledStyle
    });
    const elevationEnabled = props.elevated && props.shape === 'circle' && props.variant !== 'contrast';
    const children = getButtonContent(props);
    const onClickImpl = props.onClick;
    const onClick = _react.useCallback((e)=>{
        if (disabled) e.preventDefault();
        else onClickImpl === null || onClickImpl === void 0 ? void 0 : onClickImpl(e);
    }, [
        disabled,
        onClickImpl
    ]);
    const stopPropagationWhenDisabled = disabled ? (e)=>{
        const shouldPrevent = [
            'click',
            'mousedown',
            'mouseup',
            'submit'
        ].includes(e.type) || !('code' in e) || [
            'Enter',
            'Space'
        ].includes(e.code);
        if (shouldPrevent) {
            e.stopPropagation();
            e.preventDefault();
        }
    } : undefined;
    var _props_ariaPressed;
    return (0, _jsxruntime.jsx)(ElevatedWrapper, {
        containerClassName: props.containerClassName,
        enabled: elevationEnabled,
        children: (0, _jsxruntime.jsx)("button", {
            ref: composedRef,
            id: props.id,
            onMouseDown: (e)=>{
                var _props_onMouseDown;
                return _access_mode_state.accessModeState.setAccessMode('mouse') && ((_props_onMouseDown = props.onMouseDown) === null || _props_onMouseDown === void 0 ? void 0 : _props_onMouseDown.call(props, e));
            },
            className: (0, _classnames.default)(className, props.className),
            form: props.form,
            onMouseUp: props.onMouseUp,
            onMouseEnter: props.onMouseEnter,
            onMouseLeave: props.onMouseLeave,
            onPointerDown: props.onPointerDown,
            onPointerUp: props.onPointerUp,
            onPointerLeave: props.onPointerLeave,
            onContextMenu: props.onContextMenu,
            onBlur: props.onBlur,
            onFocus: props.onFocus,
            onDragStart: props.onDragStart,
            onDragEnd: props.onDragEnd,
            draggable: props.draggable,
            onClick: onClick,
            onClickCapture: stopPropagationWhenDisabled,
            onMouseDownCapture: stopPropagationWhenDisabled,
            onKeyDownCapture: stopPropagationWhenDisabled,
            onMouseUpCapture: stopPropagationWhenDisabled,
            disabled: disabledAttribute,
            type: props.type || 'button',
            ...(0, _button_aria_attributes.getButtonAriaAttributes)({
                ...props,
                tagName: 'button',
                selected: (_props_ariaPressed = props.ariaPressed) !== null && _props_ariaPressed !== void 0 ? _props_ariaPressed : props.selected,
                disabled
            }),
            children: children
        })
    });
}));
const AnchorInner = (0, _mobxreactlite.observer)(_react.forwardRef(function AnchorInner(props, ref) {
    const anchorRef = _react.useRef(null);
    _react.useImperativeHandle(ref, ()=>(0, _handle.createBasicHTMLHandle)(anchorRef), [
        anchorRef
    ]);
    const composedRef = (0, _composereactrefs.default)(anchorRef, props.buttonRef, ref);
    const semanticallyDisabled = props.disabled || props.loading;
    const targetBlank = props.target === '_blank';
    const rel = targetBlank && !props.rel ? 'noopener' : props.rel;
    const className = useClassName(true, {
        ...props,
        hideOutline: _access_mode_state.accessModeState.isMouseMode
    });
    const children = getButtonContent(props);
    let linkProps;
    if (!semanticallyDisabled) linkProps = {
        onClick: props.onClick,
        onDragStart: props.onDragStart,
        onDragEnd: props.onDragEnd,
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onContextMenu: props.onContextMenu,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        href: props.href,
        target: props.target,
        rel,
        download: props.download,
        draggable: props.draggable
    };
    else
    linkProps = {
        onClick: (e)=>e.preventDefault(),
        onFocus: props.onFocus,
        onBlur: props.onBlur,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        href: props.href,
        target: props.target,
        download: props.download
    };
    return (0, _jsxruntime.jsxs)("a", {
        id: props.id,
        ref: composedRef,
        ...linkProps,
        className: (0, _classnames.default)(className, props.className),
        ...(0, _button_aria_attributes.getButtonAriaAttributes)({
            tagName: 'a',
            disabled: semanticallyDisabled,
            ...props
        }),
        children: [
            children,
            props.target != null && (0, _jsxruntime.jsx)(_skip_render_on_client.SkipRenderOnClient, {
                tagName: "span",
                shouldRenderOnClient: ()=>targetBlank,
                children: (0, _jsxruntime.jsx)(_screen_reader_content.ScreenReaderContent, {
                    tagName: "span",
                    children: _buttonmessages.ButtonMessages.opensInNewWindow()
                })
            })
        ]
    });
}));
const ButtonWithTooltipInner = _react.forwardRef(({ buttonProps, tooltipTriggerProps }, ref)=>{
    const ariaProps = getAriaProps({
        props: buttonProps,
        tooltipTriggerProps
    });
    const onMouseEnter = (event)=>{
        var _buttonProps_onMouseEnter, _tooltipTriggerProps_onMouseEnter;
        (_buttonProps_onMouseEnter = buttonProps.onMouseEnter) === null || _buttonProps_onMouseEnter === void 0 ? void 0 : _buttonProps_onMouseEnter.call(buttonProps, event);
        (_tooltipTriggerProps_onMouseEnter = tooltipTriggerProps.onMouseEnter) === null || _tooltipTriggerProps_onMouseEnter === void 0 ? void 0 : _tooltipTriggerProps_onMouseEnter.call(tooltipTriggerProps);
    };
    const onMouseLeave = (event)=>{
        var _buttonProps_onMouseLeave, _tooltipTriggerProps_onMouseLeave;
        (_buttonProps_onMouseLeave = buttonProps.onMouseLeave) === null || _buttonProps_onMouseLeave === void 0 ? void 0 : _buttonProps_onMouseLeave.call(buttonProps, event);
        (_tooltipTriggerProps_onMouseLeave = tooltipTriggerProps.onMouseLeave) === null || _tooltipTriggerProps_onMouseLeave === void 0 ? void 0 : _tooltipTriggerProps_onMouseLeave.call(tooltipTriggerProps);
    };
    const onMouseDown = (event)=>{
        var _buttonProps_onMouseDown, _tooltipTriggerProps_onMouseDown;
        (_buttonProps_onMouseDown = buttonProps.onMouseDown) === null || _buttonProps_onMouseDown === void 0 ? void 0 : _buttonProps_onMouseDown.call(buttonProps, event);
        (_tooltipTriggerProps_onMouseDown = tooltipTriggerProps.onMouseDown) === null || _tooltipTriggerProps_onMouseDown === void 0 ? void 0 : _tooltipTriggerProps_onMouseDown.call(tooltipTriggerProps);
    };
    const onFocus = (event)=>{
        var _buttonProps_onFocus, _tooltipTriggerProps_onFocus;
        (_buttonProps_onFocus = buttonProps.onFocus) === null || _buttonProps_onFocus === void 0 ? void 0 : _buttonProps_onFocus.call(buttonProps, event);
        (_tooltipTriggerProps_onFocus = tooltipTriggerProps.onFocus) === null || _tooltipTriggerProps_onFocus === void 0 ? void 0 : _tooltipTriggerProps_onFocus.call(tooltipTriggerProps);
    };
    const onBlur = (event)=>{
        var _buttonProps_onBlur, _tooltipTriggerProps_onBlur;
        (_buttonProps_onBlur = buttonProps.onBlur) === null || _buttonProps_onBlur === void 0 ? void 0 : _buttonProps_onBlur.call(buttonProps, event);
        (_tooltipTriggerProps_onBlur = tooltipTriggerProps.onBlur) === null || _tooltipTriggerProps_onBlur === void 0 ? void 0 : _tooltipTriggerProps_onBlur.call(tooltipTriggerProps);
    };
    return (0, _jsxruntime.jsx)(ButtonInner, {
        ...buttonProps,
        ref: ref,
        ...ariaProps,
        onFocus: onFocus,
        onBlur: onBlur,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onMouseDown: onMouseDown,
        tooltipLabel: undefined
    });
});
const ButtonWithTooltip = (0, _mobxreactlite.observer)(_react.forwardRef(function ButtonWithTooltip(props, ref) {
    return (0, _jsxruntime.jsx)(_tooltip.Tooltip, {
        label: props.tooltipLabel,
        description: props.tooltipDescription,
        shortcut: props.tooltipShortcut,
        disabled: props.tooltipDisabled,
        placement: props.tooltipPlacement,
        lineClamp: props.tooltipLineClamp,
        closeOnClick: props.tooltipCloseOnClick,
        children: (triggerProps)=>{
            return (0, _jsxruntime.jsx)(ButtonWithTooltipInner, {
                ref: ref,
                buttonProps: props,
                tooltipTriggerProps: triggerProps
            });
        }
    });
}));
const AnchorWithTooltipInner = _react.forwardRef(({ anchorProps, tooltipTriggerProps }, ref)=>{
    const ariaProps = getAriaProps({
        props: anchorProps,
        tooltipTriggerProps
    });
    const onMouseEnter = (event)=>{
        var _anchorProps_onMouseEnter, _tooltipTriggerProps_onMouseEnter;
        (_anchorProps_onMouseEnter = anchorProps.onMouseEnter) === null || _anchorProps_onMouseEnter === void 0 ? void 0 : _anchorProps_onMouseEnter.call(anchorProps, event);
        (_tooltipTriggerProps_onMouseEnter = tooltipTriggerProps.onMouseEnter) === null || _tooltipTriggerProps_onMouseEnter === void 0 ? void 0 : _tooltipTriggerProps_onMouseEnter.call(tooltipTriggerProps);
    };
    const onMouseLeave = (event)=>{
        var _anchorProps_onMouseLeave, _tooltipTriggerProps_onMouseLeave;
        (_anchorProps_onMouseLeave = anchorProps.onMouseLeave) === null || _anchorProps_onMouseLeave === void 0 ? void 0 : _anchorProps_onMouseLeave.call(anchorProps, event);
        (_tooltipTriggerProps_onMouseLeave = tooltipTriggerProps.onMouseLeave) === null || _tooltipTriggerProps_onMouseLeave === void 0 ? void 0 : _tooltipTriggerProps_onMouseLeave.call(tooltipTriggerProps);
    };
    const onMouseDown = (event)=>{
        var _anchorProps_onMouseDown, _tooltipTriggerProps_onMouseDown;
        (_anchorProps_onMouseDown = anchorProps.onMouseDown) === null || _anchorProps_onMouseDown === void 0 ? void 0 : _anchorProps_onMouseDown.call(anchorProps, event);
        (_tooltipTriggerProps_onMouseDown = tooltipTriggerProps.onMouseDown) === null || _tooltipTriggerProps_onMouseDown === void 0 ? void 0 : _tooltipTriggerProps_onMouseDown.call(tooltipTriggerProps);
    };
    const onFocus = (event)=>{
        var _anchorProps_onFocus, _tooltipTriggerProps_onFocus;
        (_anchorProps_onFocus = anchorProps.onFocus) === null || _anchorProps_onFocus === void 0 ? void 0 : _anchorProps_onFocus.call(anchorProps, event);
        (_tooltipTriggerProps_onFocus = tooltipTriggerProps.onFocus) === null || _tooltipTriggerProps_onFocus === void 0 ? void 0 : _tooltipTriggerProps_onFocus.call(tooltipTriggerProps);
    };
    const onBlur = (event)=>{
        var _anchorProps_onBlur, _tooltipTriggerProps_onBlur;
        (_anchorProps_onBlur = anchorProps.onBlur) === null || _anchorProps_onBlur === void 0 ? void 0 : _anchorProps_onBlur.call(anchorProps, event);
        (_tooltipTriggerProps_onBlur = tooltipTriggerProps.onBlur) === null || _tooltipTriggerProps_onBlur === void 0 ? void 0 : _tooltipTriggerProps_onBlur.call(tooltipTriggerProps);
    };
    return (0, _jsxruntime.jsx)(AnchorInner, {
        ...anchorProps,
        ref: ref,
        ...ariaProps,
        onFocus: onFocus,
        onBlur: onBlur,
        onMouseEnter: onMouseEnter,
        onMouseLeave: onMouseLeave,
        onMouseDown: onMouseDown,
        tooltipLabel: undefined
    });
});
const AnchorWithTooltip = (0, _mobxreactlite.observer)(_react.forwardRef(function AnchorWithTooltip(props, ref) {
    return (0, _jsxruntime.jsx)(_tooltip.Tooltip, {
        label: props.tooltipLabel,
        description: props.tooltipDescription,
        shortcut: props.tooltipShortcut,
        disabled: props.tooltipDisabled,
        placement: props.tooltipPlacement,
        lineClamp: props.tooltipLineClamp,
        closeOnClick: props.tooltipCloseOnClick,
        children: (triggerProps)=>(0, _jsxruntime.jsx)(AnchorWithTooltipInner, {
                ref: ref,
                anchorProps: props,
                tooltipTriggerProps: triggerProps
            })
    });
}));
const CircleButtonWithoutLabel = _react.forwardRef((props, ref)=>{
    return (0, _jsxruntime.jsx)(InternalButton, {
        ...props,
        shape: "circle",
        ref: ref
    });
});
const CircleButtonWithLabel = _react.forwardRef(({ variant, children, tooltipLabel: tooltipLabelProp, ...props }, ref)=>{
    const labelId = _react.useId();
    const size = getSize({
        ...props,
        variant
    });
    const { isTruncated, ref: isTruncatedRef } = (0, _truncated.useIsTruncated)(children);
    const tooltipLabel = tooltipLabelProp || (isTruncated ? children : undefined);
    return (0, _jsxruntime.jsxs)("div", {
        className: (0, _classnames.default)(_buttoncss.default.circleShapeWrapper, {
            [_buttoncss.default.circleShapeWrapperXsmall]: size === 'xsmall',
            [_buttoncss.default.circleShapeWrapperSmall]: size === 'small',
            [_buttoncss.default.circleShapeWrapperMedium]: size === 'medium',
            [_buttoncss.default.circleShapeWrapperLarge]: size === 'large'
        }),
        children: [
            (0, _jsxruntime.jsx)(InternalButton, {
                ...props,
                tooltipPlacement: props.tooltipPlacement || 'top',
                shape: "circle",
                ref: ref,
                variant: variant,
                ariaLabelledBy: labelId,
                tooltipLabel: tooltipLabel
            }),
            (0, _jsxruntime.jsx)("label", {
                className: _buttoncss.default.circleButtonLabel,
                children: (0, _jsxruntime.jsx)(_typography.Text, {
                    size: "small",
                    id: labelId,
                    tagName: "span",
                    alignment: "center",
                    tone: "secondary",
                    lineClamp: 2,
                    ref: typeof children !== 'object' ? isTruncatedRef : undefined,
                    children: children
                })
            })
        ]
    });
});
function getAriaProps({ props, tooltipTriggerProps }) {
    const ariaProps = {
        ariaLabel: props.ariaLabel
    };
    if ((props.children == null || typeof props.children !== 'string') && props.ariaLabelledBy == null && props.ariaLabel == null)
    ariaProps.ariaLabel = props.tooltipDescription != null ? `${props.tooltipLabel}: ${props.tooltipDescription}` : props.tooltipLabel;
    else {
        const hasRedundantTooltip = typeof props.children !== 'object' && props.children === props.tooltipLabel || props.ariaLabel === props.tooltipLabel;
        if (!hasRedundantTooltip && props.ariaDescribedBy == null) ariaProps.ariaDescribedBy = tooltipTriggerProps.tooltipId;
    }
    return ariaProps;
}
function allowSquareSizing({ children, stretch, variant, icon }) {
    return !children && !!icon && !stretch && [
        'subtleLinkButton'
    ].indexOf(variant) === -1;
}
function getSize({ children, iconSize, size, variant }) {
    if ([
        'subtleLinkButton'
    ].indexOf(variant) !== -1) return;
    if (size && size !== 'default') return size;
    if (variant === 'basic')
    return;
    if (!children && iconSize && [
        'tiny',
        'small',
        'large'
    ].indexOf(iconSize) !== -1) return iconSize;
    return 'medium';
}
const ElevatedWrapper = (0, _mobxreactlite.observer)(function ElevatedWrapper(props) {
    if (props.enabled) return (0, _jsxruntime.jsx)("span", {
        className: (0, _classnames.default)(_buttoncss.default.elevatedWrapper, props.containerClassName, props.isInsideButton && _buttoncss.default.elevatedWrapperInsideButton),
        children: props.children
    });
    return props.children;
});
const InternalButton = _react.forwardRef(({ tooltipLabel: tooltipLabelProp, ...props }, ref)=>{
    const { isTruncated, ref: isTruncatedRef } = (0, _truncated.useIsTruncated)(props.children);
    const trackTruncation = typeof props.children !== 'object' && props.variant !== 'basic';
    const tooltipLabel = tooltipLabelProp || (isTruncated && trackTruncation ? props.children : undefined);
    if (tooltipLabel != null && tooltipLabel.length > 0) return (0, _jsxruntime.jsx)(ButtonWithTooltip, {
        ...props,
        ref: ref,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined,
        tooltipLabel: tooltipLabel
    });
    return (0, _jsxruntime.jsx)(ButtonInner, {
        ...props,
        ref: ref,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined,
        tooltipLabel: undefined,
        tooltipDescription: undefined
    });
});
const InternalAnchor = _react.forwardRef(({ tooltipLabel: tooltipLabelProp, ...props }, ref)=>{
    const { isTruncated, ref: isTruncatedRef } = (0, _truncated.useIsTruncated)(props.children);
    const trackTruncation = typeof props.children !== 'object' && props.variant !== 'basic';
    const tooltipLabel = tooltipLabelProp || (isTruncated ? props.children : undefined);
    if (tooltipLabel != null && tooltipLabel.length > 0) return (0, _jsxruntime.jsx)(AnchorWithTooltip, {
        ref: ref,
        ...props,
        tooltipLabel: tooltipLabel,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined
    });
    return (0, _jsxruntime.jsx)(AnchorInner, {
        ref: ref,
        ...props,
        tooltipLabel: undefined,
        tooltipDescription: undefined,
        isTruncatedRef: trackTruncation ? isTruncatedRef : undefined
    });
});
const renderButtonOrAnchor = ({ ...props }, ref)=>{
    if (props.type === 'link') return (0, _jsxruntime.jsx)(InternalAnchor, {
        ...props,
        ref: ref
    });
    return (0, _jsxruntime.jsx)(InternalButton, {
        ...props,
        ref: ref
    });
};
