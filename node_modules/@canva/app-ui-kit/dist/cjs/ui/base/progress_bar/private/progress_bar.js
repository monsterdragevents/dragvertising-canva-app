"use strict"
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: Object.getOwnPropertyDescriptor(all, name).get
    });
}
_export(exports, {
    get ProgressBar () {
        return ProgressBar;
    },
    get TRANSITION_END_TIMEOUT_MS () {
        return TRANSITION_END_TIMEOUT_MS;
    }
});
const _jsxruntime = require("react/jsx-runtime");
const _preconditions = require('../../../../base/preconditions');
const _classnames = _interop_require_default(require("classnames"));
const _react = _interop_require_wildcard(require("react"));
const _reactmeasure = _interop_require_default(require("react-measure"));
const _provider = require('../../provider/provider');
const _progress_barcss = _interop_require_wildcard(require("./progress_bar.css"));
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interop_require_wildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {
        __proto__: null
    };
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const TRANSITION_END_TIMEOUT_MS = parseInt(_progress_barcss.default.widthTransitionDurationMs, 10) + 100 || 2000;
const bubbleStyles = [
    _progress_barcss.default.bubble0,
    _progress_barcss.default.bubble1,
    _progress_barcss.default.bubble2,
    _progress_barcss.default.bubble3
];
const bubbleTTLs = [
    2000,
    3000,
    4000,
    2000
];
const bubbleUpdateInterval = 1000;
const bubblePerPixelRatio = 0.13;
const ProgressBar = (props)=>{
    const { value, ariaLabel, size = 'medium', tone = 'info', disableAnimations, onProgressAnimationEnd, disableBubbles, stretch = false } = props;
    const [bubbles, setBubbles] = _react.useState([]);
    const enableAnimations = (0, _provider.useEnableAnimations)();
    const privateFields = _react.useRef({
        bubbleUpdateTimer: 0,
        currentProgressValueTransitionEndHandled: false,
        onProgressAnimationEndTimeout: 0,
        width: 0
    });
    const updateBubbles = _react.useCallback(()=>{
        const now = Date.now();
        const valueWidth = privateFields.current.width / 100 * value;
        const requiredBubblesAmount = Math.ceil(valueWidth * bubblePerPixelRatio);
        const requiredBubblesAmountDelta = requiredBubblesAmount - bubbles.length;
        const newBubblesAmount = requiredBubblesAmountDelta < 0 ? requiredBubblesAmount : Math.ceil(bubbles.length + requiredBubblesAmountDelta / 2);
        let bubblesChanged = false;
        const newBubbles = Array.from({
            length: newBubblesAmount
        }, (_, i)=>{
            const bubble = bubbles[i];
            if (bubble === undefined || now > bubbleTTLs[bubble.type] + bubble.start) {
                bubblesChanged = true;
                return {
                    swap: bubble ? !bubble.swap : false,
                    type: Math.floor(Math.random() * bubbleStyles.length),
                    position: Math.floor(Math.random() * valueWidth),
                    start: now
                };
            }
            return bubble;
        });
        if (bubblesChanged) setBubbles(newBubbles);
        window.clearTimeout(privateFields.current.bubbleUpdateTimer);
        privateFields.current.bubbleUpdateTimer = window.setTimeout(updateBubbles, bubbleUpdateInterval);
    }, [
        bubbles,
        value
    ]);
    const onProgressTransitionEnd = _react.useCallback(()=>{
        window.clearTimeout(privateFields.current.onProgressAnimationEndTimeout);
        if (!privateFields.current.currentProgressValueTransitionEndHandled) {
            privateFields.current.currentProgressValueTransitionEndHandled = true;
            onProgressAnimationEnd && onProgressAnimationEnd(value);
        }
    }, [
        onProgressAnimationEnd,
        value
    ]);
    _react.useEffect(()=>{
        const bubbleUpdateTimer = privateFields.current.bubbleUpdateTimer;
        return ()=>{
            window.clearTimeout(bubbleUpdateTimer);
        };
    }, []);
    _react.useEffect(()=>{
        if (enableAnimations && !disableBubbles) updateBubbles();
        validateProgressValue(value);
        privateFields.current.currentProgressValueTransitionEndHandled = false;
        window.clearTimeout(privateFields.current.onProgressAnimationEndTimeout);
        privateFields.current.onProgressAnimationEndTimeout = window.setTimeout(onProgressTransitionEnd, TRANSITION_END_TIMEOUT_MS);
    }, [
        value,
        disableBubbles,
        onProgressTransitionEnd,
        updateBubbles,
        enableAnimations
    ]);
    const onResize = (contentRect)=>{
        if (contentRect.entry) privateFields.current.width = contentRect.entry.width;
    };
    const valueBackgroundStyle = {
        transform: `scaleX(${value / 100})`
    };
    return (0, _jsxruntime.jsx)(_reactmeasure.default, {
        onResize: onResize,
        children: ({ measureRef })=>(0, _jsxruntime.jsx)("div", {
                ref: measureRef,
                className: (0, _classnames.default)(_progress_barcss.default.progressBar, {
                    [_progress_barcss.default.stretch]: stretch,
                    [_progress_barcss.default.small]: size === 'small',
                    [_progress_barcss.default.critical]: tone === 'critical',
                    [_progress_barcss.default.animate]: !disableAnimations && enableAnimations
                }),
                role: "progressbar",
                "aria-label": ariaLabel,
                "aria-valuemin": 0,
                "aria-valuenow": value,
                "aria-valuemax": 100,
                children: (0, _jsxruntime.jsx)("div", {
                    className: _progress_barcss.default.valueContainer,
                    style: {
                        [_progress_barcss.customProperties.valueContainerOffset]: `${value - 100}%`
                    },
                    children: (0, _jsxruntime.jsxs)("div", {
                        className: _progress_barcss.default.valueContainer,
                        style: {
                            [_progress_barcss.customProperties.valueContainerOffset]: `${100 - value}%`
                        },
                        children: [
                            (0, _jsxruntime.jsx)("div", {
                                className: _progress_barcss.default.valueBackground,
                                style: valueBackgroundStyle,
                                onTransitionEnd: onProgressTransitionEnd
                            }),
                            bubbles.map(({ position, type, swap }, i)=>(0, _jsxruntime.jsx)("div", {
                                    className: (0, _classnames.default)(bubbleStyles[type], {
                                        [_progress_barcss.default.bubbleSwap]: swap
                                    }),
                                    style: {
                                        [_progress_barcss.customProperties.bubbleSide]: `${position}px`
                                    }
                                }, i))
                        ]
                    })
                })
            })
    });
};
function validateProgressValue(value) {
    _preconditions.Preconditions.checkState(value >= 0 && value <= 100, `value must be in [0, 100]; got ${value}`);
}
